/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
			/******/
		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
			/******/
		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
		/******/
	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
			/******/
		}
		/******/
	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
			/******/
		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
		/******/
	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
		/******/
	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
		/******/
	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assets/js/index.js");
	/******/
})
/************************************************************************/
/******/({

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = function (it) {
				if (typeof it != 'function') {
					throw TypeError(String(it) + ' is not a function');
				} return it;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

			module.exports = function (it) {
				if (!isObject(it) && it !== null) {
					throw TypeError("Can't set " + String(it) + ' as a prototype');
				} return it;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

			var UNSCOPABLES = wellKnownSymbol('unscopables');
			var ArrayPrototype = Array.prototype;

			// Array.prototype[@@unscopables]
			// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
			if (ArrayPrototype[UNSCOPABLES] == undefined) {
				definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
					configurable: true,
					value: create(null)
				});
			}

			// add a key to Array.prototype[@@unscopables]
			module.exports = function (key) {
				ArrayPrototype[UNSCOPABLES][key] = true;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;

			// `AdvanceStringIndex` abstract operation
			// https://tc39.github.io/ecma262/#sec-advancestringindex
			module.exports = function (S, index, unicode) {
				return index + (unicode ? charAt(S, index).length : 1);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

			module.exports = function (it) {
				if (!isObject(it)) {
					throw TypeError(String(it) + ' is not an object');
				} return it;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;
			var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");
			var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

			var STRICT_METHOD = arrayMethodIsStrict('forEach');
			var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

			// `Array.prototype.forEach` method implementation
			// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
			module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
				return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
			} : [].forEach;


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
			var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

			// `Array.prototype.{ indexOf, includes }` methods implementation
			var createMethod = function (IS_INCLUDES) {
				return function ($this, el, fromIndex) {
					var O = toIndexedObject($this);
					var length = toLength(O.length);
					var index = toAbsoluteIndex(fromIndex, length);
					var value;
					// Array#includes uses SameValueZero equality algorithm
					// eslint-disable-next-line no-self-compare
					if (IS_INCLUDES && el != el) while (length > index) {
						value = O[index++];
						// eslint-disable-next-line no-self-compare
						if (value != value) return true;
						// Array#indexOf ignores holes, Array#includes - not
					} else for (; length > index; index++) {
						if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
					} return !IS_INCLUDES && -1;
				};
			};

			module.exports = {
				// `Array.prototype.includes` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.includes
				includes: createMethod(true),
				// `Array.prototype.indexOf` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
				indexOf: createMethod(false)
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
			var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
			var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
			var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
			var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

			var push = [].push;

			// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
			var createMethod = function (TYPE) {
				var IS_MAP = TYPE == 1;
				var IS_FILTER = TYPE == 2;
				var IS_SOME = TYPE == 3;
				var IS_EVERY = TYPE == 4;
				var IS_FIND_INDEX = TYPE == 6;
				var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
				return function ($this, callbackfn, that, specificCreate) {
					var O = toObject($this);
					var self = IndexedObject(O);
					var boundFunction = bind(callbackfn, that, 3);
					var length = toLength(self.length);
					var index = 0;
					var create = specificCreate || arraySpeciesCreate;
					var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
					var value, result;
					for (; length > index; index++) if (NO_HOLES || index in self) {
						value = self[index];
						result = boundFunction(value, index, O);
						if (TYPE) {
							if (IS_MAP) target[index] = result; // map
							else if (result) switch (TYPE) {
								case 3: return true;              // some
								case 5: return value;             // find
								case 6: return index;             // findIndex
								case 2: push.call(target, value); // filter
							} else if (IS_EVERY) return false;  // every
						}
					}
					return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
				};
			};

			module.exports = {
				// `Array.prototype.forEach` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
				forEach: createMethod(0),
				// `Array.prototype.map` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.map
				map: createMethod(1),
				// `Array.prototype.filter` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.filter
				filter: createMethod(2),
				// `Array.prototype.some` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.some
				some: createMethod(3),
				// `Array.prototype.every` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.every
				every: createMethod(4),
				// `Array.prototype.find` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.find
				find: createMethod(5),
				// `Array.prototype.findIndex` method
				// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
				findIndex: createMethod(6)
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");

			var SPECIES = wellKnownSymbol('species');

			module.exports = function (METHOD_NAME) {
				// We can't use this feature detection in V8 since it causes
				// deoptimization and serious performance degradation
				// https://github.com/zloirock/core-js/issues/677
				return V8_VERSION >= 51 || !fails(function () {
					var array = [];
					var constructor = array.constructor = {};
					constructor[SPECIES] = function () {
						return { foo: 1 };
					};
					return array[METHOD_NAME](Boolean).foo !== 1;
				});
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-method-is-strict.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			module.exports = function (METHOD_NAME, argument) {
				var method = [][METHOD_NAME];
				return !!method && fails(function () {
					// eslint-disable-next-line no-useless-call,no-throw-literal
					method.call(null, argument || function () { throw 1; }, 1);
				});
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-method-uses-to-length.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-uses-to-length.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

			var defineProperty = Object.defineProperty;
			var cache = {};

			var thrower = function (it) { throw it; };

			module.exports = function (METHOD_NAME, options) {
				if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
				if (!options) options = {};
				var method = [][METHOD_NAME];
				var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
				var argument0 = has(options, 0) ? options[0] : thrower;
				var argument1 = has(options, 1) ? options[1] : undefined;

				return cache[METHOD_NAME] = !!method && !fails(function () {
					if (ACCESSORS && !DESCRIPTORS) return true;
					var O = { length: -1 };

					if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
					else O[1] = 1;

					method.call(O, argument0, argument1);
				});
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var SPECIES = wellKnownSymbol('species');

			// `ArraySpeciesCreate` abstract operation
			// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
			module.exports = function (originalArray, length) {
				var C;
				if (isArray(originalArray)) {
					C = originalArray.constructor;
					// cross-realm fallback
					if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
					else if (isObject(C)) {
						C = C[SPECIES];
						if (C === null) C = undefined;
					}
				} return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			var toString = {}.toString;

			module.exports = function (it) {
				return toString.call(it).slice(8, -1);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
			var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var TO_STRING_TAG = wellKnownSymbol('toStringTag');
			// ES3 wrong here
			var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

			// fallback for IE11 Script Access Denied error
			var tryGet = function (it, key) {
				try {
					return it[key];
				} catch (error) { /* empty */ }
			};

			// getting tag from ES6+ `Object.prototype.toString`
			module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
				var O, tag, result;
				return it === undefined ? 'Undefined' : it === null ? 'Null'
					// @@toStringTag case
					: typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
						// builtinTag case
						: CORRECT_ARGUMENTS ? classofRaw(O)
							// ES3 arguments fallback
							: (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
			var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

			module.exports = function (target, source) {
				var keys = ownKeys(source);
				var defineProperty = definePropertyModule.f;
				var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
				for (var i = 0; i < keys.length; i++) {
					var key = keys[i];
					if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
				}
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			module.exports = !fails(function () {
				function F() { /* empty */ }
				F.prototype.constructor = null;
				return Object.getPrototypeOf(new F()) !== F.prototype;
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
			var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
			var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
			var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
			var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

			var returnThis = function () { return this; };

			module.exports = function (IteratorConstructor, NAME, next) {
				var TO_STRING_TAG = NAME + ' Iterator';
				IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
				setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
				Iterators[TO_STRING_TAG] = returnThis;
				return IteratorConstructor;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
			var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

			module.exports = DESCRIPTORS ? function (object, key, value) {
				return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
			} : function (object, key, value) {
				object[key] = value;
				return object;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = function (bitmap, value) {
				return {
					enumerable: !(bitmap & 1),
					configurable: !(bitmap & 2),
					writable: !(bitmap & 4),
					value: value
				};
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
			var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

			module.exports = function (object, key, value) {
				var propertyKey = toPrimitive(key);
				if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
				else object[propertyKey] = value;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
			var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
			var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
			var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
			var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
			var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

			var IteratorPrototype = IteratorsCore.IteratorPrototype;
			var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
			var ITERATOR = wellKnownSymbol('iterator');
			var KEYS = 'keys';
			var VALUES = 'values';
			var ENTRIES = 'entries';

			var returnThis = function () { return this; };

			module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
				createIteratorConstructor(IteratorConstructor, NAME, next);

				var getIterationMethod = function (KIND) {
					if (KIND === DEFAULT && defaultIterator) return defaultIterator;
					if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
					switch (KIND) {
						case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
						case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
						case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
					} return function () { return new IteratorConstructor(this); };
				};

				var TO_STRING_TAG = NAME + ' Iterator';
				var INCORRECT_VALUES_NAME = false;
				var IterablePrototype = Iterable.prototype;
				var nativeIterator = IterablePrototype[ITERATOR]
					|| IterablePrototype['@@iterator']
					|| DEFAULT && IterablePrototype[DEFAULT];
				var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
				var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
				var CurrentIteratorPrototype, methods, KEY;

				// fix native
				if (anyNativeIterator) {
					CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
					if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
						if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
							if (setPrototypeOf) {
								setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
							} else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
								createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
							}
						}
						// Set @@toStringTag to native iterators
						setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
						if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
					}
				}

				// fix Array#{values, @@iterator}.name in V8 / FF
				if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
					INCORRECT_VALUES_NAME = true;
					defaultIterator = function values() { return nativeIterator.call(this); };
				}

				// define iterator
				if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
					createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
				}
				Iterators[NAME] = defaultIterator;

				// export additional methods
				if (DEFAULT) {
					methods = {
						values: getIterationMethod(VALUES),
						keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
						entries: getIterationMethod(ENTRIES)
					};
					if (FORCED) for (KEY in methods) {
						if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
							redefine(IterablePrototype, KEY, methods[KEY]);
						}
					} else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
				}

				return methods;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/define-well-known-symbol.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
			var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

			module.exports = function (NAME) {
				var Symbol = path.Symbol || (path.Symbol = {});
				if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
					value: wrappedWellKnownSymbolModule.f(NAME)
				});
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			// Thank's IE8 for his funny defineProperty
			module.exports = !fails(function () {
				return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

			var document = global.document;
			// typeof document.createElement is 'object' in old IE
			var EXISTS = isObject(document) && isObject(document.createElement);

			module.exports = function (it) {
				return EXISTS ? document.createElement(it) : {};
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			// iterable DOM collections
			// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
			module.exports = {
				CSSRuleList: 0,
				CSSStyleDeclaration: 0,
				CSSValueList: 0,
				ClientRectList: 0,
				DOMRectList: 0,
				DOMStringList: 0,
				DOMTokenList: 1,
				DataTransferItemList: 0,
				FileList: 0,
				HTMLAllCollection: 0,
				HTMLCollection: 0,
				HTMLFormElement: 0,
				HTMLSelectElement: 0,
				MediaList: 0,
				MimeTypeArray: 0,
				NamedNodeMap: 0,
				NodeList: 1,
				PaintRequestList: 0,
				Plugin: 0,
				PluginArray: 0,
				SVGLengthList: 0,
				SVGNumberList: 0,
				SVGPathSegList: 0,
				SVGPointList: 0,
				SVGStringList: 0,
				SVGTransformList: 0,
				SourceBufferList: 0,
				StyleSheetList: 0,
				TextTrackCueList: 0,
				TextTrackList: 0,
				TouchList: 0
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

			module.exports = getBuiltIn('navigator', 'userAgent') || '';


			/***/
		}),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

			var process = global.process;
			var versions = process && process.versions;
			var v8 = versions && versions.v8;
			var match, version;

			if (v8) {
				match = v8.split('.');
				version = match[0] + match[1];
			} else if (userAgent) {
				match = userAgent.match(/Edge\/(\d+)/);
				if (!match || match[1] >= 74) {
					match = userAgent.match(/Chrome\/(\d+)/);
					if (match) version = match[1];
				}
			}

			module.exports = version && +version;


			/***/
		}),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			// IE8- don't enum bug keys
			module.exports = [
				'constructor',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'toLocaleString',
				'toString',
				'valueOf'
			];


			/***/
		}),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
			var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
			var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
			var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

			/*
				options.target      - name of the target object
				options.global      - target is the global object
				options.stat        - export as static methods of target
				options.proto       - export as prototype methods of target
				options.real        - real prototype method for the `pure` version
				options.forced      - export even if the native feature is available
				options.bind        - bind methods to the target, required for the `pure` version
				options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
				options.unsafe      - use the simple assignment of property instead of delete + defineProperty
				options.sham        - add a flag to not completely full polyfills
				options.enumerable  - export as enumerable property
				options.noTargetGet - prevent calling a getter on target
			*/
			module.exports = function (options, source) {
				var TARGET = options.target;
				var GLOBAL = options.global;
				var STATIC = options.stat;
				var FORCED, target, key, targetProperty, sourceProperty, descriptor;
				if (GLOBAL) {
					target = global;
				} else if (STATIC) {
					target = global[TARGET] || setGlobal(TARGET, {});
				} else {
					target = (global[TARGET] || {}).prototype;
				}
				if (target) for (key in source) {
					sourceProperty = source[key];
					if (options.noTargetGet) {
						descriptor = getOwnPropertyDescriptor(target, key);
						targetProperty = descriptor && descriptor.value;
					} else targetProperty = target[key];
					FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
					// contained in target
					if (!FORCED && targetProperty !== undefined) {
						if (typeof sourceProperty === typeof targetProperty) continue;
						copyConstructorProperties(sourceProperty, targetProperty);
					}
					// add a flag to not completely full polyfills
					if (options.sham || (targetProperty && targetProperty.sham)) {
						createNonEnumerableProperty(sourceProperty, 'sham', true);
					}
					// extend global
					redefine(target, key, sourceProperty, options);
				}
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = function (exec) {
				try {
					return !!exec();
				} catch (error) {
					return true;
				}
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			// TODO: Remove from `core-js@4` since it's moved to entry points
			__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
			var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

			var SPECIES = wellKnownSymbol('species');

			var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
				// #replace needs built-in support for named groups.
				// #match works fine because it just return the exec results, even if it has
				// a "grops" property.
				var re = /./;
				re.exec = function () {
					var result = [];
					result.groups = { a: '7' };
					return result;
				};
				return ''.replace(re, '$<a>') !== '7';
			});

			// IE <= 11 replaces $0 with the whole match, as if it was $&
			// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
			var REPLACE_KEEPS_$0 = (function () {
				return 'a'.replace(/./, '$0') === '$0';
			})();

			var REPLACE = wellKnownSymbol('replace');
			// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
			var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
				if (/./[REPLACE]) {
					return /./[REPLACE]('a', '$0') === '';
				}
				return false;
			})();

			// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
			// Weex JS has frozen built-in prototypes, so use try / catch wrapper
			var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
				var re = /(?:)/;
				var originalExec = re.exec;
				re.exec = function () { return originalExec.apply(this, arguments); };
				var result = 'ab'.split(re);
				return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
			});

			module.exports = function (KEY, length, exec, sham) {
				var SYMBOL = wellKnownSymbol(KEY);

				var DELEGATES_TO_SYMBOL = !fails(function () {
					// String methods call symbol-named RegEp methods
					var O = {};
					O[SYMBOL] = function () { return 7; };
					return ''[KEY](O) != 7;
				});

				var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
					// Symbol-named RegExp methods call .exec
					var execCalled = false;
					var re = /a/;

					if (KEY === 'split') {
						// We can't use real regex here since it causes deoptimization
						// and serious performance degradation in V8
						// https://github.com/zloirock/core-js/issues/306
						re = {};
						// RegExp[@@split] doesn't call the regex's exec method, but first creates
						// a new one. We need to return the patched regex when creating the new one.
						re.constructor = {};
						re.constructor[SPECIES] = function () { return re; };
						re.flags = '';
						re[SYMBOL] = /./[SYMBOL];
					}

					re.exec = function () { execCalled = true; return null; };

					re[SYMBOL]('');
					return !execCalled;
				});

				if (
					!DELEGATES_TO_SYMBOL ||
					!DELEGATES_TO_EXEC ||
					(KEY === 'replace' && !(
						REPLACE_SUPPORTS_NAMED_GROUPS &&
						REPLACE_KEEPS_$0 &&
						!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
					)) ||
					(KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
				) {
					var nativeRegExpMethod = /./[SYMBOL];
					var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
						if (regexp.exec === regexpExec) {
							if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
								// The native String method already delegates to @@method (this
								// polyfilled function), leasing to infinite recursion.
								// We avoid it by directly calling the native @@method method.
								return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
							}
							return { done: true, value: nativeMethod.call(str, regexp, arg2) };
						}
						return { done: false };
					}, {
						REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
						REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
					});
					var stringMethod = methods[0];
					var regexMethod = methods[1];

					redefine(String.prototype, KEY, stringMethod);
					redefine(RegExp.prototype, SYMBOL, length == 2
						// 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
						// 21.2.5.11 RegExp.prototype[@@split](string, limit)
						? function (string, arg) { return regexMethod.call(string, this, arg); }
						// 21.2.5.6 RegExp.prototype[@@match](string)
						// 21.2.5.9 RegExp.prototype[@@search](string)
						: function (string) { return regexMethod.call(string, this); }
					);
				}

				if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

			// optional / simple context binding
			module.exports = function (fn, that, length) {
				aFunction(fn);
				if (that === undefined) return fn;
				switch (length) {
					case 0: return function () {
						return fn.call(that);
					};
					case 1: return function (a) {
						return fn.call(that, a);
					};
					case 2: return function (a, b) {
						return fn.call(that, a, b);
					};
					case 3: return function (a, b, c) {
						return fn.call(that, a, b, c);
					};
				}
				return function (/* ...args */) {
					return fn.apply(that, arguments);
				};
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

			var aFunction = function (variable) {
				return typeof variable == 'function' ? variable : undefined;
			};

			module.exports = function (namespace, method) {
				return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
					: path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function (global) {
				var check = function (it) {
					return it && it.Math == Math && it;
				};

				// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
				module.exports =
					// eslint-disable-next-line no-undef
					check(typeof globalThis == 'object' && globalThis) ||
					check(typeof window == 'object' && window) ||
					check(typeof self == 'object' && self) ||
					check(typeof global == 'object' && global) ||
					// eslint-disable-next-line no-new-func
					Function('return this')();

				/* WEBPACK VAR INJECTION */
			}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

			/***/
		}),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			var hasOwnProperty = {}.hasOwnProperty;

			module.exports = function (it, key) {
				return hasOwnProperty.call(it, key);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = {};


			/***/
		}),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

			module.exports = getBuiltIn('document', 'documentElement');


			/***/
		}),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

			// Thank's IE8 for his funny defineProperty
			module.exports = !DESCRIPTORS && !fails(function () {
				return Object.defineProperty(createElement('div'), 'a', {
					get: function () { return 7; }
				}).a != 7;
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

			var split = ''.split;

			// fallback for non-array-like ES3 and non-enumerable old V8 strings
			module.exports = fails(function () {
				// throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
				// eslint-disable-next-line no-prototype-builtins
				return !Object('z').propertyIsEnumerable(0);
			}) ? function (it) {
				return classof(it) == 'String' ? split.call(it, '') : Object(it);
			} : Object;


			/***/
		}),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

			var functionToString = Function.toString;

			// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
			if (typeof store.inspectSource != 'function') {
				store.inspectSource = function (it) {
					return functionToString.call(it);
				};
			}

			module.exports = store.inspectSource;


			/***/
		}),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
			var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

			var WeakMap = global.WeakMap;
			var set, get, has;

			var enforce = function (it) {
				return has(it) ? get(it) : set(it, {});
			};

			var getterFor = function (TYPE) {
				return function (it) {
					var state;
					if (!isObject(it) || (state = get(it)).type !== TYPE) {
						throw TypeError('Incompatible receiver, ' + TYPE + ' required');
					} return state;
				};
			};

			if (NATIVE_WEAK_MAP) {
				var store = new WeakMap();
				var wmget = store.get;
				var wmhas = store.has;
				var wmset = store.set;
				set = function (it, metadata) {
					wmset.call(store, it, metadata);
					return metadata;
				};
				get = function (it) {
					return wmget.call(store, it) || {};
				};
				has = function (it) {
					return wmhas.call(store, it);
				};
			} else {
				var STATE = sharedKey('state');
				hiddenKeys[STATE] = true;
				set = function (it, metadata) {
					createNonEnumerableProperty(it, STATE, metadata);
					return metadata;
				};
				get = function (it) {
					return objectHas(it, STATE) ? it[STATE] : {};
				};
				has = function (it) {
					return objectHas(it, STATE);
				};
			}

			module.exports = {
				set: set,
				get: get,
				has: has,
				enforce: enforce,
				getterFor: getterFor
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

			// `IsArray` abstract operation
			// https://tc39.github.io/ecma262/#sec-isarray
			module.exports = Array.isArray || function isArray(arg) {
				return classof(arg) == 'Array';
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			var replacement = /#|\.prototype\./;

			var isForced = function (feature, detection) {
				var value = data[normalize(feature)];
				return value == POLYFILL ? true
					: value == NATIVE ? false
						: typeof detection == 'function' ? fails(detection)
							: !!detection;
			};

			var normalize = isForced.normalize = function (string) {
				return String(string).replace(replacement, '.').toLowerCase();
			};

			var data = isForced.data = {};
			var NATIVE = isForced.NATIVE = 'N';
			var POLYFILL = isForced.POLYFILL = 'P';

			module.exports = isForced;


			/***/
		}),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = function (it) {
				return typeof it === 'object' ? it !== null : typeof it === 'function';
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = false;


			/***/
		}),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var MATCH = wellKnownSymbol('match');

			// `IsRegExp` abstract operation
			// https://tc39.github.io/ecma262/#sec-isregexp
			module.exports = function (it) {
				var isRegExp;
				return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

			var ITERATOR = wellKnownSymbol('iterator');
			var BUGGY_SAFARI_ITERATORS = false;

			var returnThis = function () { return this; };

			// `%IteratorPrototype%` object
			// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
			var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

			if ([].keys) {
				arrayIterator = [].keys();
				// Safari 8 has buggy iterators w/o `next`
				if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
				else {
					PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
					if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
				}
			}

			if (IteratorPrototype == undefined) IteratorPrototype = {};

			// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
			if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
				createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
			}

			module.exports = {
				IteratorPrototype: IteratorPrototype,
				BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			module.exports = {};


			/***/
		}),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
				// Chrome 38 Symbol has incorrect toString conversion
				// eslint-disable-next-line no-undef
				return !String(Symbol());
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

			var WeakMap = global.WeakMap;

			module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
			var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
			var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
			var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
			var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
			var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

			var GT = '>';
			var LT = '<';
			var PROTOTYPE = 'prototype';
			var SCRIPT = 'script';
			var IE_PROTO = sharedKey('IE_PROTO');

			var EmptyConstructor = function () { /* empty */ };

			var scriptTag = function (content) {
				return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
			};

			// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
			var NullProtoObjectViaActiveX = function (activeXDocument) {
				activeXDocument.write(scriptTag(''));
				activeXDocument.close();
				var temp = activeXDocument.parentWindow.Object;
				activeXDocument = null; // avoid memory leak
				return temp;
			};

			// Create object with fake `null` prototype: use iframe Object with cleared prototype
			var NullProtoObjectViaIFrame = function () {
				// Thrash, waste and sodomy: IE GC bug
				var iframe = documentCreateElement('iframe');
				var JS = 'java' + SCRIPT + ':';
				var iframeDocument;
				iframe.style.display = 'none';
				html.appendChild(iframe);
				// https://github.com/zloirock/core-js/issues/475
				iframe.src = String(JS);
				iframeDocument = iframe.contentWindow.document;
				iframeDocument.open();
				iframeDocument.write(scriptTag('document.F=Object'));
				iframeDocument.close();
				return iframeDocument.F;
			};

			// Check for document.domain and active x support
			// No need to use active x approach when document.domain is not set
			// see https://github.com/es-shims/es5-shim/issues/150
			// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
			// avoid IE GC bug
			var activeXDocument;
			var NullProtoObject = function () {
				try {
					/* global ActiveXObject */
					activeXDocument = document.domain && new ActiveXObject('htmlfile');
				} catch (error) { /* ignore */ }
				NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
				var length = enumBugKeys.length;
				while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
				return NullProtoObject();
			};

			hiddenKeys[IE_PROTO] = true;

			// `Object.create` method
			// https://tc39.github.io/ecma262/#sec-object.create
			module.exports = Object.create || function create(O, Properties) {
				var result;
				if (O !== null) {
					EmptyConstructor[PROTOTYPE] = anObject(O);
					result = new EmptyConstructor();
					EmptyConstructor[PROTOTYPE] = null;
					// add "__proto__" for Object.getPrototypeOf polyfill
					result[IE_PROTO] = O;
				} else result = NullProtoObject();
				return Properties === undefined ? result : defineProperties(result, Properties);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

			// `Object.defineProperties` method
			// https://tc39.github.io/ecma262/#sec-object.defineproperties
			module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
				anObject(O);
				var keys = objectKeys(Properties);
				var length = keys.length;
				var index = 0;
				var key;
				while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
				return O;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

			var nativeDefineProperty = Object.defineProperty;

			// `Object.defineProperty` method
			// https://tc39.github.io/ecma262/#sec-object.defineproperty
			exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
				anObject(O);
				P = toPrimitive(P, true);
				anObject(Attributes);
				if (IE8_DOM_DEFINE) try {
					return nativeDefineProperty(O, P, Attributes);
				} catch (error) { /* empty */ }
				if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
				if ('value' in Attributes) O[P] = Attributes.value;
				return O;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
			var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

			var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

			// `Object.getOwnPropertyDescriptor` method
			// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
			exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
				O = toIndexedObject(O);
				P = toPrimitive(P, true);
				if (IE8_DOM_DEFINE) try {
					return nativeGetOwnPropertyDescriptor(O, P);
				} catch (error) { /* empty */ }
				if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;

			var toString = {}.toString;

			var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
				? Object.getOwnPropertyNames(window) : [];

			var getWindowNames = function (it) {
				try {
					return nativeGetOwnPropertyNames(it);
				} catch (error) {
					return windowNames.slice();
				}
			};

			// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
			module.exports.f = function getOwnPropertyNames(it) {
				return windowNames && toString.call(it) == '[object Window]'
					? getWindowNames(it)
					: nativeGetOwnPropertyNames(toIndexedObject(it));
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
			var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

			var hiddenKeys = enumBugKeys.concat('length', 'prototype');

			// `Object.getOwnPropertyNames` method
			// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
			exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
				return internalObjectKeys(O, hiddenKeys);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			exports.f = Object.getOwnPropertySymbols;


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
			var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
			var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

			var IE_PROTO = sharedKey('IE_PROTO');
			var ObjectPrototype = Object.prototype;

			// `Object.getPrototypeOf` method
			// https://tc39.github.io/ecma262/#sec-object.getprototypeof
			module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
				O = toObject(O);
				if (has(O, IE_PROTO)) return O[IE_PROTO];
				if (typeof O.constructor == 'function' && O instanceof O.constructor) {
					return O.constructor.prototype;
				} return O instanceof Object ? ObjectPrototype : null;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
			var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

			module.exports = function (object, names) {
				var O = toIndexedObject(object);
				var i = 0;
				var result = [];
				var key;
				for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
				// Don't enum bug & hidden keys
				while (names.length > i) if (has(O, key = names[i++])) {
					~indexOf(result, key) || result.push(key);
				}
				return result;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
			var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

			// `Object.keys` method
			// https://tc39.github.io/ecma262/#sec-object.keys
			module.exports = Object.keys || function keys(O) {
				return internalObjectKeys(O, enumBugKeys);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
			var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

			// Nashorn ~ JDK8 bug
			var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

			// `Object.prototype.propertyIsEnumerable` method implementation
			// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
			exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
				var descriptor = getOwnPropertyDescriptor(this, V);
				return !!descriptor && descriptor.enumerable;
			} : nativePropertyIsEnumerable;


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

			// `Object.setPrototypeOf` method
			// https://tc39.github.io/ecma262/#sec-object.setprototypeof
			// Works with __proto__ only. Old v8 can't work with null proto objects.
			/* eslint-disable no-proto */
			module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
				var CORRECT_SETTER = false;
				var test = {};
				var setter;
				try {
					setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
					setter.call(test, []);
					CORRECT_SETTER = test instanceof Array;
				} catch (error) { /* empty */ }
				return function setPrototypeOf(O, proto) {
					anObject(O);
					aPossiblePrototype(proto);
					if (CORRECT_SETTER) setter.call(O, proto);
					else O.__proto__ = proto;
					return O;
				};
			}() : undefined);


			/***/
		}),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
			var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

			// `Object.prototype.toString` method implementation
			// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
			module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
				return '[object ' + classof(this) + ']';
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
			var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
			var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

			// all object keys, includes non-enumerable and symbols
			module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
				var keys = getOwnPropertyNamesModule.f(anObject(it));
				var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
				return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

			module.exports = global;


			/***/
		}),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
			var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
			var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

			var getInternalState = InternalStateModule.get;
			var enforceInternalState = InternalStateModule.enforce;
			var TEMPLATE = String(String).split('String');

			(module.exports = function (O, key, value, options) {
				var unsafe = options ? !!options.unsafe : false;
				var simple = options ? !!options.enumerable : false;
				var noTargetGet = options ? !!options.noTargetGet : false;
				if (typeof value == 'function') {
					if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
					enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
				}
				if (O === global) {
					if (simple) O[key] = value;
					else setGlobal(key, value);
					return;
				} else if (!unsafe) {
					delete O[key];
				} else if (!noTargetGet && O[key]) {
					simple = true;
				}
				if (simple) O[key] = value;
				else createNonEnumerableProperty(O, key, value);
				// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
			})(Function.prototype, 'toString', function toString() {
				return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
			var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

			// `RegExpExec` abstract operation
			// https://tc39.github.io/ecma262/#sec-regexpexec
			module.exports = function (R, S) {
				var exec = R.exec;
				if (typeof exec === 'function') {
					var result = exec.call(R, S);
					if (typeof result !== 'object') {
						throw TypeError('RegExp exec method returned something other than an Object or null');
					}
					return result;
				}

				if (classof(R) !== 'RegExp') {
					throw TypeError('RegExp#exec called on incompatible receiver');
				}

				return regexpExec.call(R, S);
			};



			/***/
		}),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var regexpFlags = __webpack_require__(/*! ./regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
			var stickyHelpers = __webpack_require__(/*! ./regexp-sticky-helpers */ "./node_modules/core-js/internals/regexp-sticky-helpers.js");

			var nativeExec = RegExp.prototype.exec;
			// This always refers to the native implementation, because the
			// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
			// which loads this file before patching the method.
			var nativeReplace = String.prototype.replace;

			var patchedExec = nativeExec;

			var UPDATES_LAST_INDEX_WRONG = (function () {
				var re1 = /a/;
				var re2 = /b*/g;
				nativeExec.call(re1, 'a');
				nativeExec.call(re2, 'a');
				return re1.lastIndex !== 0 || re2.lastIndex !== 0;
			})();

			var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

			// nonparticipating capturing group, copied from es5-shim's String#split patch.
			var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

			var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

			if (PATCH) {
				patchedExec = function exec(str) {
					var re = this;
					var lastIndex, reCopy, match, i;
					var sticky = UNSUPPORTED_Y && re.sticky;
					var flags = regexpFlags.call(re);
					var source = re.source;
					var charsAdded = 0;
					var strCopy = str;

					if (sticky) {
						flags = flags.replace('y', '');
						if (flags.indexOf('g') === -1) {
							flags += 'g';
						}

						strCopy = String(str).slice(re.lastIndex);
						// Support anchored sticky behavior.
						if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
							source = '(?: ' + source + ')';
							strCopy = ' ' + strCopy;
							charsAdded++;
						}
						// ^(? + rx + ) is needed, in combination with some str slicing, to
						// simulate the 'y' flag.
						reCopy = new RegExp('^(?:' + source + ')', flags);
					}

					if (NPCG_INCLUDED) {
						reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
					}
					if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

					match = nativeExec.call(sticky ? reCopy : re, strCopy);

					if (sticky) {
						if (match) {
							match.input = match.input.slice(charsAdded);
							match[0] = match[0].slice(charsAdded);
							match.index = re.lastIndex;
							re.lastIndex += match[0].length;
						} else re.lastIndex = 0;
					} else if (UPDATES_LAST_INDEX_WRONG && match) {
						re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
					}
					if (NPCG_INCLUDED && match && match.length > 1) {
						// Fix browsers whose `exec` methods don't consistently return `undefined`
						// for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
						nativeReplace.call(match[0], reCopy, function () {
							for (i = 1; i < arguments.length - 2; i++) {
								if (arguments[i] === undefined) match[i] = undefined;
							}
						});
					}

					return match;
				};
			}

			module.exports = patchedExec;


			/***/
		}),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

			// `RegExp.prototype.flags` getter implementation
			// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
			module.exports = function () {
				var that = anObject(this);
				var result = '';
				if (that.global) result += 'g';
				if (that.ignoreCase) result += 'i';
				if (that.multiline) result += 'm';
				if (that.dotAll) result += 's';
				if (that.unicode) result += 'u';
				if (that.sticky) result += 'y';
				return result;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/regexp-sticky-helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-sticky-helpers.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";


			var fails = __webpack_require__(/*! ./fails */ "./node_modules/core-js/internals/fails.js");

			// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
			// so we use an intermediate function.
			function RE(s, f) {
				return RegExp(s, f);
			}

			exports.UNSUPPORTED_Y = fails(function () {
				// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
				var re = RE('a', 'y');
				re.lastIndex = 2;
				return re.exec('abcd') != null;
			});

			exports.BROKEN_CARET = fails(function () {
				// https://bugzilla.mozilla.org/show_bug.cgi?id=773687
				var re = RE('^r', 'gy');
				re.lastIndex = 2;
				return re.exec('str') != null;
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			// `RequireObjectCoercible` abstract operation
			// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
			module.exports = function (it) {
				if (it == undefined) throw TypeError("Can't call method on " + it);
				return it;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

			module.exports = function (key, value) {
				try {
					createNonEnumerableProperty(global, key, value);
				} catch (error) {
					global[key] = value;
				} return value;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var TO_STRING_TAG = wellKnownSymbol('toStringTag');

			module.exports = function (it, TAG, STATIC) {
				if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
					defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
				}
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
			var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

			var keys = shared('keys');

			module.exports = function (key) {
				return keys[key] || (keys[key] = uid(key));
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

			var SHARED = '__core-js_shared__';
			var store = global[SHARED] || setGlobal(SHARED, {});

			module.exports = store;


			/***/
		}),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
			var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

			(module.exports = function (key, value) {
				return store[key] || (store[key] = value !== undefined ? value : {});
			})('versions', []).push({
				version: '3.6.5',
				mode: IS_PURE ? 'pure' : 'global',
				copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
			});


			/***/
		}),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var SPECIES = wellKnownSymbol('species');

			// `SpeciesConstructor` abstract operation
			// https://tc39.github.io/ecma262/#sec-speciesconstructor
			module.exports = function (O, defaultConstructor) {
				var C = anObject(O).constructor;
				var S;
				return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

			// `String.prototype.{ codePointAt, at }` methods implementation
			var createMethod = function (CONVERT_TO_STRING) {
				return function ($this, pos) {
					var S = String(requireObjectCoercible($this));
					var position = toInteger(pos);
					var size = S.length;
					var first, second;
					if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
					first = S.charCodeAt(position);
					return first < 0xD800 || first > 0xDBFF || position + 1 === size
						|| (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
						? CONVERT_TO_STRING ? S.charAt(position) : first
						: CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
				};
			};

			module.exports = {
				// `String.prototype.codePointAt` method
				// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
				codeAt: createMethod(false),
				// `String.prototype.at` method
				// https://github.com/mathiasbynens/String.prototype.at
				charAt: createMethod(true)
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/string-repeat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

			// `String.prototype.repeat` method implementation
			// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
			module.exports = ''.repeat || function repeat(count) {
				var str = String(requireObjectCoercible(this));
				var result = '';
				var n = toInteger(count);
				if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
				for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
				return result;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

			// `thisNumberValue` abstract operation
			// https://tc39.github.io/ecma262/#sec-thisnumbervalue
			module.exports = function (value) {
				if (typeof value != 'number' && classof(value) != 'Number') {
					throw TypeError('Incorrect invocation');
				}
				return +value;
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

			var max = Math.max;
			var min = Math.min;

			// Helper for a popular repeating case of the spec:
			// Let integer be ? ToInteger(index).
			// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
			module.exports = function (index, length) {
				var integer = toInteger(index);
				return integer < 0 ? max(integer + length, 0) : min(integer, length);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			// toObject with fallback for non-array-like ES3 strings
			var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

			module.exports = function (it) {
				return IndexedObject(requireObjectCoercible(it));
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			var ceil = Math.ceil;
			var floor = Math.floor;

			// `ToInteger` abstract operation
			// https://tc39.github.io/ecma262/#sec-tointeger
			module.exports = function (argument) {
				return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

			var min = Math.min;

			// `ToLength` abstract operation
			// https://tc39.github.io/ecma262/#sec-tolength
			module.exports = function (argument) {
				return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

			// `ToObject` abstract operation
			// https://tc39.github.io/ecma262/#sec-toobject
			module.exports = function (argument) {
				return Object(requireObjectCoercible(argument));
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

			// `ToPrimitive` abstract operation
			// https://tc39.github.io/ecma262/#sec-toprimitive
			// instead of the ES6 spec version, we didn't implement @@toPrimitive case
			// and the second argument - flag - preferred type is a string
			module.exports = function (input, PREFERRED_STRING) {
				if (!isObject(input)) return input;
				var fn, val;
				if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
				if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
				if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
				throw TypeError("Can't convert object to primitive value");
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var TO_STRING_TAG = wellKnownSymbol('toStringTag');
			var test = {};

			test[TO_STRING_TAG] = 'z';

			module.exports = String(test) === '[object z]';


			/***/
		}),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			var id = 0;
			var postfix = Math.random();

			module.exports = function (key) {
				return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
			};


			/***/
		}),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

			module.exports = NATIVE_SYMBOL
				// eslint-disable-next-line no-undef
				&& !Symbol.sham
				// eslint-disable-next-line no-undef
				&& typeof Symbol.iterator == 'symbol';


			/***/
		}),

/***/ "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			exports.f = wellKnownSymbol;


			/***/
		}),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
			var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
			var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

			var WellKnownSymbolsStore = shared('wks');
			var Symbol = global.Symbol;
			var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

			module.exports = function (name) {
				if (!has(WellKnownSymbolsStore, name)) {
					if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
					else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
				} return WellKnownSymbolsStore[name];
			};


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var $find = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find;
			var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
			var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

			var FIND = 'find';
			var SKIPS_HOLES = true;

			var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

			// Shouldn't skip holes
			if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

			// `Array.prototype.find` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.find
			$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
				find: function find(callbackfn /* , that = undefined */) {
					return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
				}
			});

			// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
			addToUnscopables(FIND);


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

			// `Array.prototype.forEach` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
			$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
				forEach: forEach
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
			var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
			var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
			var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

			var ARRAY_ITERATOR = 'Array Iterator';
			var setInternalState = InternalStateModule.set;
			var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

			// `Array.prototype.entries` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.entries
			// `Array.prototype.keys` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.keys
			// `Array.prototype.values` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.values
			// `Array.prototype[@@iterator]` method
			// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
			// `CreateArrayIterator` internal method
			// https://tc39.github.io/ecma262/#sec-createarrayiterator
			module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
				setInternalState(this, {
					type: ARRAY_ITERATOR,
					target: toIndexedObject(iterated), // target
					index: 0,                          // next index
					kind: kind                         // kind
				});
				// `%ArrayIteratorPrototype%.next` method
				// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
			}, function () {
				var state = getInternalState(this);
				var target = state.target;
				var kind = state.kind;
				var index = state.index++;
				if (!target || index >= target.length) {
					state.target = undefined;
					return { value: undefined, done: true };
				}
				if (kind == 'keys') return { value: index, done: false };
				if (kind == 'values') return { value: target[index], done: false };
				return { value: [index, target[index]], done: false };
			}, 'values');

			// argumentsList[@@iterator] is %ArrayProto_values%
			// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
			// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
			Iterators.Arguments = Iterators.Array;

			// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
			addToUnscopables('keys');
			addToUnscopables('values');
			addToUnscopables('entries');


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
			var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
			var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
			var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

			var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
			var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

			var SPECIES = wellKnownSymbol('species');
			var nativeSlice = [].slice;
			var max = Math.max;

			// `Array.prototype.slice` method
			// https://tc39.github.io/ecma262/#sec-array.prototype.slice
			// fallback for not array-like ES3 strings and DOM objects
			$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
				slice: function slice(start, end) {
					var O = toIndexedObject(this);
					var length = toLength(O.length);
					var k = toAbsoluteIndex(start, length);
					var fin = toAbsoluteIndex(end === undefined ? length : end, length);
					// inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
					var Constructor, result, n;
					if (isArray(O)) {
						Constructor = O.constructor;
						// cross-realm fallback
						if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
							Constructor = undefined;
						} else if (isObject(Constructor)) {
							Constructor = Constructor[SPECIES];
							if (Constructor === null) Constructor = undefined;
						}
						if (Constructor === Array || Constructor === undefined) {
							return nativeSlice.call(O, k, fin);
						}
					}
					result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
					for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
					result.length = n;
					return result;
				}
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.number.to-fixed.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
			var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
			var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			var nativeToFixed = 1.0.toFixed;
			var floor = Math.floor;

			var pow = function (x, n, acc) {
				return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
			};

			var log = function (x) {
				var n = 0;
				var x2 = x;
				while (x2 >= 4096) {
					n += 12;
					x2 /= 4096;
				}
				while (x2 >= 2) {
					n += 1;
					x2 /= 2;
				} return n;
			};

			var FORCED = nativeToFixed && (
				0.00008.toFixed(3) !== '0.000' ||
				0.9.toFixed(0) !== '1' ||
				1.255.toFixed(2) !== '1.25' ||
				1000000000000000128.0.toFixed(0) !== '1000000000000000128'
			) || !fails(function () {
				// V8 ~ Android 4.3-
				nativeToFixed.call({});
			});

			// `Number.prototype.toFixed` method
			// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
			$({ target: 'Number', proto: true, forced: FORCED }, {
				// eslint-disable-next-line max-statements
				toFixed: function toFixed(fractionDigits) {
					var number = thisNumberValue(this);
					var fractDigits = toInteger(fractionDigits);
					var data = [0, 0, 0, 0, 0, 0];
					var sign = '';
					var result = '0';
					var e, z, j, k;

					var multiply = function (n, c) {
						var index = -1;
						var c2 = c;
						while (++index < 6) {
							c2 += n * data[index];
							data[index] = c2 % 1e7;
							c2 = floor(c2 / 1e7);
						}
					};

					var divide = function (n) {
						var index = 6;
						var c = 0;
						while (--index >= 0) {
							c += data[index];
							data[index] = floor(c / n);
							c = (c % n) * 1e7;
						}
					};

					var dataToString = function () {
						var index = 6;
						var s = '';
						while (--index >= 0) {
							if (s !== '' || index === 0 || data[index] !== 0) {
								var t = String(data[index]);
								s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
							}
						} return s;
					};

					if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
					// eslint-disable-next-line no-self-compare
					if (number != number) return 'NaN';
					if (number <= -1e21 || number >= 1e21) return String(number);
					if (number < 0) {
						sign = '-';
						number = -number;
					}
					if (number > 1e-21) {
						e = log(number * pow(2, 69, 1)) - 69;
						z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
						z *= 0x10000000000000;
						e = 52 - e;
						if (e > 0) {
							multiply(0, z);
							j = fractDigits;
							while (j >= 7) {
								multiply(1e7, 0);
								j -= 7;
							}
							multiply(pow(10, j, 1), 0);
							j = e - 1;
							while (j >= 23) {
								divide(1 << 23);
								j -= 23;
							}
							divide(1 << j);
							multiply(1, 1);
							divide(2);
							result = dataToString();
						} else {
							multiply(0, z);
							multiply(1 << -e, 0);
							result = dataToString() + repeat.call('0', fractDigits);
						}
					}
					if (fractDigits > 0) {
						k = result.length;
						result = sign + (k <= fractDigits
							? '0.' + repeat.call('0', fractDigits - k) + result
							: result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
					} else {
						result = sign + result;
					} return result;
				}
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
			var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

			// `Object.keys` method
			// https://tc39.github.io/ecma262/#sec-object.keys
			$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
				keys: function keys(it) {
					return nativeKeys(toObject(it));
				}
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
			var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
			var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

			// `Object.prototype.toString` method
			// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
			if (!TO_STRING_TAG_SUPPORT) {
				redefine(Object.prototype, 'toString', toString, { unsafe: true });
			}


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var exec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

			$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
				exec: exec
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;
			var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
			var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

			var STRING_ITERATOR = 'String Iterator';
			var setInternalState = InternalStateModule.set;
			var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

			// `String.prototype[@@iterator]` method
			// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
			defineIterator(String, 'String', function (iterated) {
				setInternalState(this, {
					type: STRING_ITERATOR,
					string: String(iterated),
					index: 0
				});
				// `%StringIteratorPrototype%.next` method
				// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
			}, function next() {
				var state = getInternalState(this);
				var string = state.string;
				var index = state.index;
				var point;
				if (index >= string.length) return { value: undefined, done: true };
				point = charAt(string, index);
				state.index += point.length;
				return { value: point, done: false };
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
			var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
			var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
			var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
			var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

			var max = Math.max;
			var min = Math.min;
			var floor = Math.floor;
			var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
			var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

			var maybeToString = function (it) {
				return it === undefined ? it : String(it);
			};

			// @@replace logic
			fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
				var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
				var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
				var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

				return [
					// `String.prototype.replace` method
					// https://tc39.github.io/ecma262/#sec-string.prototype.replace
					function replace(searchValue, replaceValue) {
						var O = requireObjectCoercible(this);
						var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
						return replacer !== undefined
							? replacer.call(searchValue, O, replaceValue)
							: nativeReplace.call(String(O), searchValue, replaceValue);
					},
					// `RegExp.prototype[@@replace]` method
					// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
					function (regexp, replaceValue) {
						if (
							(!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
							(typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
						) {
							var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
							if (res.done) return res.value;
						}

						var rx = anObject(regexp);
						var S = String(this);

						var functionalReplace = typeof replaceValue === 'function';
						if (!functionalReplace) replaceValue = String(replaceValue);

						var global = rx.global;
						if (global) {
							var fullUnicode = rx.unicode;
							rx.lastIndex = 0;
						}
						var results = [];
						while (true) {
							var result = regExpExec(rx, S);
							if (result === null) break;

							results.push(result);
							if (!global) break;

							var matchStr = String(result[0]);
							if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
						}

						var accumulatedResult = '';
						var nextSourcePosition = 0;
						for (var i = 0; i < results.length; i++) {
							result = results[i];

							var matched = String(result[0]);
							var position = max(min(toInteger(result.index), S.length), 0);
							var captures = [];
							// NOTE: This is equivalent to
							//   captures = result.slice(1).map(maybeToString)
							// but for some reason `nativeSlice.call(result, 1, result.length)` (called in
							// the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
							// causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
							for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
							var namedCaptures = result.groups;
							if (functionalReplace) {
								var replacerArgs = [matched].concat(captures, position, S);
								if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
								var replacement = String(replaceValue.apply(undefined, replacerArgs));
							} else {
								replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
							}
							if (position >= nextSourcePosition) {
								accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
								nextSourcePosition = position + matched.length;
							}
						}
						return accumulatedResult + S.slice(nextSourcePosition);
					}
				];

				// https://tc39.github.io/ecma262/#sec-getsubstitution
				function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
					var tailPos = position + matched.length;
					var m = captures.length;
					var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
					if (namedCaptures !== undefined) {
						namedCaptures = toObject(namedCaptures);
						symbols = SUBSTITUTION_SYMBOLS;
					}
					return nativeReplace.call(replacement, symbols, function (match, ch) {
						var capture;
						switch (ch.charAt(0)) {
							case '$': return '$';
							case '&': return matched;
							case '`': return str.slice(0, position);
							case "'": return str.slice(tailPos);
							case '<':
								capture = namedCaptures[ch.slice(1, -1)];
								break;
							default: // \d\d?
								var n = +ch;
								if (n === 0) return match;
								if (n > m) {
									var f = floor(n / 10);
									if (f === 0) return match;
									if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
									return match;
								}
								capture = captures[n - 1];
						}
						return capture === undefined ? '' : capture;
					});
				}
			});


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.string.split.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.split.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
			var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
			var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
			var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
			var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
			var callRegExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
			var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

			var arrayPush = [].push;
			var min = Math.min;
			var MAX_UINT32 = 0xFFFFFFFF;

			// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
			var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

			// @@split logic
			fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
				var internalSplit;
				if (
					'abbc'.split(/(b)*/)[1] == 'c' ||
					'test'.split(/(?:)/, -1).length != 4 ||
					'ab'.split(/(?:ab)*/).length != 2 ||
					'.'.split(/(.?)(.?)/).length != 4 ||
					'.'.split(/()()/).length > 1 ||
					''.split(/.?/).length
				) {
					// based on es5-shim implementation, need to rework it
					internalSplit = function (separator, limit) {
						var string = String(requireObjectCoercible(this));
						var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
						if (lim === 0) return [];
						if (separator === undefined) return [string];
						// If `separator` is not a regex, use native split
						if (!isRegExp(separator)) {
							return nativeSplit.call(string, separator, lim);
						}
						var output = [];
						var flags = (separator.ignoreCase ? 'i' : '') +
							(separator.multiline ? 'm' : '') +
							(separator.unicode ? 'u' : '') +
							(separator.sticky ? 'y' : '');
						var lastLastIndex = 0;
						// Make `global` and avoid `lastIndex` issues by working with a copy
						var separatorCopy = new RegExp(separator.source, flags + 'g');
						var match, lastIndex, lastLength;
						while (match = regexpExec.call(separatorCopy, string)) {
							lastIndex = separatorCopy.lastIndex;
							if (lastIndex > lastLastIndex) {
								output.push(string.slice(lastLastIndex, match.index));
								if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
								lastLength = match[0].length;
								lastLastIndex = lastIndex;
								if (output.length >= lim) break;
							}
							if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
						}
						if (lastLastIndex === string.length) {
							if (lastLength || !separatorCopy.test('')) output.push('');
						} else output.push(string.slice(lastLastIndex));
						return output.length > lim ? output.slice(0, lim) : output;
					};
					// Chakra, V8
				} else if ('0'.split(undefined, 0).length) {
					internalSplit = function (separator, limit) {
						return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
					};
				} else internalSplit = nativeSplit;

				return [
					// `String.prototype.split` method
					// https://tc39.github.io/ecma262/#sec-string.prototype.split
					function split(separator, limit) {
						var O = requireObjectCoercible(this);
						var splitter = separator == undefined ? undefined : separator[SPLIT];
						return splitter !== undefined
							? splitter.call(separator, O, limit)
							: internalSplit.call(String(O), separator, limit);
					},
					// `RegExp.prototype[@@split]` method
					// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
					//
					// NOTE: This cannot be properly polyfilled in engines that don't support
					// the 'y' flag.
					function (regexp, limit) {
						var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
						if (res.done) return res.value;

						var rx = anObject(regexp);
						var S = String(this);
						var C = speciesConstructor(rx, RegExp);

						var unicodeMatching = rx.unicode;
						var flags = (rx.ignoreCase ? 'i' : '') +
							(rx.multiline ? 'm' : '') +
							(rx.unicode ? 'u' : '') +
							(SUPPORTS_Y ? 'y' : 'g');

						// ^(? + rx + ) is needed, in combination with some S slicing, to
						// simulate the 'y' flag.
						var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
						var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
						if (lim === 0) return [];
						if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
						var p = 0;
						var q = 0;
						var A = [];
						while (q < S.length) {
							splitter.lastIndex = SUPPORTS_Y ? q : 0;
							var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
							var e;
							if (
								z === null ||
								(e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
							) {
								q = advanceStringIndex(S, q, unicodeMatching);
							} else {
								A.push(S.slice(p, q));
								if (A.length === lim) return A;
								for (var i = 1; i <= z.length - 1; i++) {
									A.push(z[i]);
									if (A.length === lim) return A;
								}
								q = p = e;
							}
						}
						A.push(S.slice(p));
						return A;
					}
				];
			}, !SUPPORTS_Y);


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";
			// `Symbol.prototype.description` getter
			// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
			var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

			var NativeSymbol = global.Symbol;

			if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
				// Safari 12 bug
				NativeSymbol().description !== undefined
			)) {
				var EmptyStringDescriptionStore = {};
				// wrap Symbol constructor for correct work with undefined description
				var SymbolWrapper = function Symbol() {
					var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
					var result = this instanceof SymbolWrapper
						? new NativeSymbol(description)
						// in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
						: description === undefined ? NativeSymbol() : NativeSymbol(description);
					if (description === '') EmptyStringDescriptionStore[result] = true;
					return result;
				};
				copyConstructorProperties(SymbolWrapper, NativeSymbol);
				var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
				symbolPrototype.constructor = SymbolWrapper;

				var symbolToString = symbolPrototype.toString;
				var native = String(NativeSymbol('test')) == 'Symbol(test)';
				var regexp = /^Symbol\((.*)\)[^)]+$/;
				defineProperty(symbolPrototype, 'description', {
					configurable: true,
					get: function description() {
						var symbol = isObject(this) ? this.valueOf() : this;
						var string = symbolToString.call(symbol);
						if (has(EmptyStringDescriptionStore, symbol)) return '';
						var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
						return desc === '' ? undefined : desc;
					}
				});

				$({ global: true, forced: true }, {
					Symbol: SymbolWrapper
				});
			}


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

			// `Symbol.iterator` well-known symbol
			// https://tc39.github.io/ecma262/#sec-symbol.iterator
			defineWellKnownSymbol('iterator');


			/***/
		}),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";

			var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
			var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
			var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
			var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
			var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");
			var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
			var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
			var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
			var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
			var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
			var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
			var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
			var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
			var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
			var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
			var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
			var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
			var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
			var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
			var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
			var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
			var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
			var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
			var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
			var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
			var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
			var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
			var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
			var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
			var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
			var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;

			var HIDDEN = sharedKey('hidden');
			var SYMBOL = 'Symbol';
			var PROTOTYPE = 'prototype';
			var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
			var setInternalState = InternalStateModule.set;
			var getInternalState = InternalStateModule.getterFor(SYMBOL);
			var ObjectPrototype = Object[PROTOTYPE];
			var $Symbol = global.Symbol;
			var $stringify = getBuiltIn('JSON', 'stringify');
			var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
			var nativeDefineProperty = definePropertyModule.f;
			var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
			var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
			var AllSymbols = shared('symbols');
			var ObjectPrototypeSymbols = shared('op-symbols');
			var StringToSymbolRegistry = shared('string-to-symbol-registry');
			var SymbolToStringRegistry = shared('symbol-to-string-registry');
			var WellKnownSymbolsStore = shared('wks');
			var QObject = global.QObject;
			// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
			var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

			// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
			var setSymbolDescriptor = DESCRIPTORS && fails(function () {
				return nativeObjectCreate(nativeDefineProperty({}, 'a', {
					get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
				})).a != 7;
			}) ? function (O, P, Attributes) {
				var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
				if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
				nativeDefineProperty(O, P, Attributes);
				if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
					nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
				}
			} : nativeDefineProperty;

			var wrap = function (tag, description) {
				var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
				setInternalState(symbol, {
					type: SYMBOL,
					tag: tag,
					description: description
				});
				if (!DESCRIPTORS) symbol.description = description;
				return symbol;
			};

			var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
				return typeof it == 'symbol';
			} : function (it) {
				return Object(it) instanceof $Symbol;
			};

			var $defineProperty = function defineProperty(O, P, Attributes) {
				if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
				anObject(O);
				var key = toPrimitive(P, true);
				anObject(Attributes);
				if (has(AllSymbols, key)) {
					if (!Attributes.enumerable) {
						if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
						O[HIDDEN][key] = true;
					} else {
						if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
						Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
					} return setSymbolDescriptor(O, key, Attributes);
				} return nativeDefineProperty(O, key, Attributes);
			};

			var $defineProperties = function defineProperties(O, Properties) {
				anObject(O);
				var properties = toIndexedObject(Properties);
				var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
				$forEach(keys, function (key) {
					if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
				});
				return O;
			};

			var $create = function create(O, Properties) {
				return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
			};

			var $propertyIsEnumerable = function propertyIsEnumerable(V) {
				var P = toPrimitive(V, true);
				var enumerable = nativePropertyIsEnumerable.call(this, P);
				if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
				return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
			};

			var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
				var it = toIndexedObject(O);
				var key = toPrimitive(P, true);
				if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
				var descriptor = nativeGetOwnPropertyDescriptor(it, key);
				if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
					descriptor.enumerable = true;
				}
				return descriptor;
			};

			var $getOwnPropertyNames = function getOwnPropertyNames(O) {
				var names = nativeGetOwnPropertyNames(toIndexedObject(O));
				var result = [];
				$forEach(names, function (key) {
					if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
				});
				return result;
			};

			var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
				var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
				var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
				var result = [];
				$forEach(names, function (key) {
					if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
						result.push(AllSymbols[key]);
					}
				});
				return result;
			};

			// `Symbol` constructor
			// https://tc39.github.io/ecma262/#sec-symbol-constructor
			if (!NATIVE_SYMBOL) {
				$Symbol = function Symbol() {
					if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
					var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
					var tag = uid(description);
					var setter = function (value) {
						if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
						if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
						setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
					};
					if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
					return wrap(tag, description);
				};

				redefine($Symbol[PROTOTYPE], 'toString', function toString() {
					return getInternalState(this).tag;
				});

				redefine($Symbol, 'withoutSetter', function (description) {
					return wrap(uid(description), description);
				});

				propertyIsEnumerableModule.f = $propertyIsEnumerable;
				definePropertyModule.f = $defineProperty;
				getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
				getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
				getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

				wrappedWellKnownSymbolModule.f = function (name) {
					return wrap(wellKnownSymbol(name), name);
				};

				if (DESCRIPTORS) {
					// https://github.com/tc39/proposal-Symbol-description
					nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
						configurable: true,
						get: function description() {
							return getInternalState(this).description;
						}
					});
					if (!IS_PURE) {
						redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
					}
				}
			}

			$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
				Symbol: $Symbol
			});

			$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
				defineWellKnownSymbol(name);
			});

			$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
				// `Symbol.for` method
				// https://tc39.github.io/ecma262/#sec-symbol.for
				'for': function (key) {
					var string = String(key);
					if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
					var symbol = $Symbol(string);
					StringToSymbolRegistry[string] = symbol;
					SymbolToStringRegistry[symbol] = string;
					return symbol;
				},
				// `Symbol.keyFor` method
				// https://tc39.github.io/ecma262/#sec-symbol.keyfor
				keyFor: function keyFor(sym) {
					if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
					if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
				},
				useSetter: function () { USE_SETTER = true; },
				useSimple: function () { USE_SETTER = false; }
			});

			$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
				// `Object.create` method
				// https://tc39.github.io/ecma262/#sec-object.create
				create: $create,
				// `Object.defineProperty` method
				// https://tc39.github.io/ecma262/#sec-object.defineproperty
				defineProperty: $defineProperty,
				// `Object.defineProperties` method
				// https://tc39.github.io/ecma262/#sec-object.defineproperties
				defineProperties: $defineProperties,
				// `Object.getOwnPropertyDescriptor` method
				// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
				getOwnPropertyDescriptor: $getOwnPropertyDescriptor
			});

			$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
				// `Object.getOwnPropertyNames` method
				// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
				getOwnPropertyNames: $getOwnPropertyNames,
				// `Object.getOwnPropertySymbols` method
				// https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
				getOwnPropertySymbols: $getOwnPropertySymbols
			});

			// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
			// https://bugs.chromium.org/p/v8/issues/detail?id=3443
			$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
				getOwnPropertySymbols: function getOwnPropertySymbols(it) {
					return getOwnPropertySymbolsModule.f(toObject(it));
				}
			});

			// `JSON.stringify` method behavior with symbols
			// https://tc39.github.io/ecma262/#sec-json.stringify
			if ($stringify) {
				var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
					var symbol = $Symbol();
					// MS Edge converts symbol values to JSON as {}
					return $stringify([symbol]) != '[null]'
						// WebKit converts symbol values to JSON as null
						|| $stringify({ a: symbol }) != '{}'
						// V8 throws on boxed symbols
						|| $stringify(Object(symbol)) != '{}';
				});

				$({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
					// eslint-disable-next-line no-unused-vars
					stringify: function stringify(it, replacer, space) {
						var args = [it];
						var index = 1;
						var $replacer;
						while (arguments.length > index) args.push(arguments[index++]);
						$replacer = replacer;
						if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
						if (!isArray(replacer)) replacer = function (key, value) {
							if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
							if (!isSymbol(value)) return value;
						};
						args[1] = replacer;
						return $stringify.apply(null, args);
					}
				});
			}

			// `Symbol.prototype[@@toPrimitive]` method
			// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
			if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
				createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
			}
			// `Symbol.prototype[@@toStringTag]` property
			// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
			setToStringTag($Symbol, SYMBOL);

			hiddenKeys[HIDDEN] = true;


			/***/
		}),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
			var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

			for (var COLLECTION_NAME in DOMIterables) {
				var Collection = global[COLLECTION_NAME];
				var CollectionPrototype = Collection && Collection.prototype;
				// some Chrome versions have non-configurable methods on DOMTokenList
				if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
					createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
				} catch (error) {
					CollectionPrototype.forEach = forEach;
				}
			}


			/***/
		}),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
			var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
			var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
			var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
			var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

			var ITERATOR = wellKnownSymbol('iterator');
			var TO_STRING_TAG = wellKnownSymbol('toStringTag');
			var ArrayValues = ArrayIteratorMethods.values;

			for (var COLLECTION_NAME in DOMIterables) {
				var Collection = global[COLLECTION_NAME];
				var CollectionPrototype = Collection && Collection.prototype;
				if (CollectionPrototype) {
					// some Chrome versions have non-configurable methods on DOMTokenList
					if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
						createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
					} catch (error) {
						CollectionPrototype[ITERATOR] = ArrayValues;
					}
					if (!CollectionPrototype[TO_STRING_TAG]) {
						createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
					}
					if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
						// some Chrome versions have non-configurable methods on DOMTokenList
						if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
							createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
						} catch (error) {
							CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
						}
					}
				}
			}


			/***/
		}),

/***/ "./node_modules/custom-event-polyfill/custom-event-polyfill.js":
/*!*********************************************************************!*\
  !*** ./node_modules/custom-event-polyfill/custom-event-polyfill.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			// Polyfill for creating CustomEvents on IE9/10/11

			// code pulled from:
			// https://github.com/d4tocchini/customevent-polyfill
			// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill

			try {
				var ce = new window.CustomEvent('test');
				ce.preventDefault();
				if (ce.defaultPrevented !== true) {
					// IE has problems with .preventDefault() on custom events
					// http://stackoverflow.com/questions/23349191
					throw new Error('Could not prevent default');
				}
			} catch (e) {
				var CustomEvent = function (event, params) {
					var evt, origPrevent;
					params = params || {
						bubbles: false,
						cancelable: false,
						detail: undefined
					};

					evt = document.createEvent("CustomEvent");
					evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
					origPrevent = evt.preventDefault;
					evt.preventDefault = function () {
						origPrevent.call(this);
						try {
							Object.defineProperty(this, 'defaultPrevented', {
								get: function () {
									return true;
								}
							});
						} catch (e) {
							this.defaultPrevented = true;
						}
					};
					return evt;
				};

				CustomEvent.prototype = window.Event.prototype;
				window.CustomEvent = CustomEvent; // expose definition to window
			}


			/***/
		}),

/***/ "./node_modules/custom-select/build/index.js":
/*!***************************************************!*\
  !*** ./node_modules/custom-select/build/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			"use strict";


			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

			var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * custom-select
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * A lightweight JS script for custom select creation.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Needs no dependencies.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * v0.0.1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * (https://github.com/custom-select/custom-select)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2016 Gionatan Lombardi & Marco Nucara
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * MIT License
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

			exports.default = customSelect;

			__webpack_require__(/*! custom-event-polyfill */ "./node_modules/custom-event-polyfill/custom-event-polyfill.js");

			var defaultParams = {
				containerClass: 'custom-select-container',
				openerClass: 'custom-select-opener',
				panelClass: 'custom-select-panel',
				optionClass: 'custom-select-option',
				optgroupClass: 'custom-select-optgroup',
				isSelectedClass: 'is-selected',
				hasFocusClass: 'has-focus',
				isDisabledClass: 'is-disabled',
				isOpenClass: 'is-open'
			};

			function builder(el, builderParams) {
				var containerClass = 'customSelect';
				var isOpen = false;
				var uId = '';
				var select = el;
				var container = void 0;
				var opener = void 0;
				var focusedElement = void 0;
				var selectedElement = void 0;
				var panel = void 0;
				var currLabel = void 0;

				var resetSearchTimeout = void 0;
				var searchKey = '';

				//
				// Inner Functions
				//

				// Sets the focused element with the neccessary classes substitutions
				function setFocusedElement(cstOption) {
					if (focusedElement) {
						focusedElement.classList.remove(builderParams.hasFocusClass);
					}
					if (typeof cstOption !== 'undefined') {
						focusedElement = cstOption;
						focusedElement.classList.add(builderParams.hasFocusClass);
						// Offset update: checks if the focused element is in the visible part of the panelClass
						// if not dispatches a custom event
						if (isOpen) {
							if (cstOption.offsetTop < cstOption.offsetParent.scrollTop || cstOption.offsetTop > cstOption.offsetParent.scrollTop + cstOption.offsetParent.clientHeight - cstOption.clientHeight) {
								cstOption.dispatchEvent(new CustomEvent('custom-select:focus-outside-panel', { bubbles: true }));
							}
						}
					} else {
						focusedElement = undefined;
					}
				}

				// Reassigns the focused and selected custom option
				// Updates the opener text
				// IMPORTANT: the setSelectedElement function doesn't change the select value!
				function setSelectedElement(cstOption) {
					if (selectedElement) {
						selectedElement.classList.remove(builderParams.isSelectedClass);
						selectedElement.removeAttribute('id');
						opener.removeAttribute('aria-activedescendant');
					}
					if (typeof cstOption !== 'undefined') {
						cstOption.classList.add(builderParams.isSelectedClass);
						cstOption.setAttribute('id', containerClass + '-' + uId + '-selectedOption');
						opener.setAttribute('aria-activedescendant', containerClass + '-' + uId + '-selectedOption');
						selectedElement = cstOption;
						opener.children[0].textContent = selectedElement.customSelectOriginalOption.text;
					} else {
						selectedElement = undefined;
						opener.children[0].textContent = '';
					}
					setFocusedElement(cstOption);
				}

				function setValue(value) {
					// Gets the option with the provided value
					var toSelect = select.querySelector('option[value=\'' + value + '\']');
					// If no option has the provided value get the first
					if (!toSelect) {
						var _select$options = _slicedToArray(select.options, 1);

						toSelect = _select$options[0];
					}
					// The option with the provided value becomes the selected one
					// And changes the select current value
					toSelect.selected = true;

					setSelectedElement(select.options[select.selectedIndex].customSelectCstOption);
				}

				function moveFocuesedElement(direction) {
					// Get all the .custom-select-options
					// Get the index of the current focused one
					var currentFocusedIndex = [].indexOf.call(select.options, focusedElement.customSelectOriginalOption);
					// If the next or prev custom option exist
					// Sets it as the new focused one
					if (select.options[currentFocusedIndex + direction]) {
						setFocusedElement(select.options[currentFocusedIndex + direction].customSelectCstOption);
					}
				}

				// Open/Close function (toggle)
				function open(bool) {
					// Open
					if (bool || typeof bool === 'undefined') {
						// If present closes an opened instance of the plugin
						// Only one at time can be open
						var openedCustomSelect = document.querySelector('.' + containerClass + '.' + builderParams.isOpenClass);
						if (openedCustomSelect) {
							openedCustomSelect.customSelect.open = false;
						}

						// Opens only the clicked one
						container.classList.add(builderParams.isOpenClass);

						// aria-expanded update
						container.classList.add(builderParams.isOpenClass);
						opener.setAttribute('aria-expanded', 'true');

						// Updates the scrollTop position of the panel in relation with the focused option
						if (selectedElement) {
							panel.scrollTop = selectedElement.offsetTop;
						}

						// Dispatches the custom event open
						container.dispatchEvent(new CustomEvent('custom-select:open'));

						// Sets the global state
						isOpen = true;

						// Close
					} else {
						// Removes the css classes
						container.classList.remove(builderParams.isOpenClass);

						// aria-expanded update
						opener.setAttribute('aria-expanded', 'false');

						// Sets the global state
						isOpen = false;

						// When closing the panel the focused custom option must be the selected one
						setFocusedElement(selectedElement);

						// Dispatches the custom event close
						container.dispatchEvent(new CustomEvent('custom-select:close'));
					}
					return isOpen;
				}

				function clickEvent(e) {
					// Opener click
					if (e.target === opener || opener.contains(e.target)) {
						if (isOpen) {
							open(false);
						} else {
							open();
						}
						// Custom Option click
					} else if (e.target.classList && e.target.classList.contains(builderParams.optionClass) && panel.contains(e.target)) {
						setSelectedElement(e.target);
						// Sets the corrisponding select's option to selected updating the select's value too
						selectedElement.customSelectOriginalOption.selected = true;
						open(false);
						// Triggers the native change event of the select
						select.dispatchEvent(new CustomEvent('change'));
						// click on label or select (click on label corrispond to select click)
					} else if (e.target === select) {
						// if the original select is focusable (for any external reason) let the focus
						// else trigger the focus on opener
						if (opener !== document.activeElement && select !== document.activeElement) {
							opener.focus();
						}
						// Click outside the container closes the panel
					} else if (isOpen && !container.contains(e.target)) {
						open(false);
					}
				}

				function mouseoverEvent(e) {
					// On mouse move over and options it bacames the focused one
					if (e.target.classList && e.target.classList.contains(builderParams.optionClass)) {
						setFocusedElement(e.target);
					}
				}

				function keydownEvent(e) {
					if (!isOpen) {
						// On "Arrow down", "Arrow up" and "Space" keys opens the panel
						if (e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 32) {
							open();
						}
					} else {
						switch (e.keyCode) {
							case 13:
							case 32:
								// On "Enter" or "Space" selects the focused element as the selected one
								setSelectedElement(focusedElement);
								// Sets the corrisponding select's option to selected updating the select's value too
								selectedElement.customSelectOriginalOption.selected = true;
								// Triggers the native change event of the select
								select.dispatchEvent(new CustomEvent('change'));
								open(false);
								break;
							case 27:
								// On "Escape" closes the panel
								open(false);
								break;

							case 38:
								// On "Arrow up" set focus to the prev option if present
								moveFocuesedElement(-1);
								break;
							case 40:
								// On "Arrow down" set focus to the next option if present
								moveFocuesedElement(+1);
								break;
							default:
								// search in panel (autocomplete)
								if (e.keyCode >= 48 && e.keyCode <= 90) {
									// clear existing reset timeout
									if (resetSearchTimeout) {
										clearTimeout(resetSearchTimeout);
									}

									// reset timeout for empty search key
									resetSearchTimeout = setTimeout(function () {
										searchKey = '';
									}, 1500);

									// update search keyword appending the current key
									searchKey += String.fromCharCode(e.keyCode);

									// search the element
									for (var i = 0, l = select.options.length; i < l; i++) {
										// removed cause not supported by IE:
										// if (options[i].text.startsWith(searchKey))
										if (select.options[i].text.toUpperCase().substr(0, searchKey.length) === searchKey) {
											setFocusedElement(select.options[i].customSelectCstOption);
											break;
										}
									}
								}
								break;
						}
					}
				}

				function changeEvent() {
					var index = select.selectedIndex;
					var element = index === -1 ? undefined : select.options[index].customSelectCstOption;

					setSelectedElement(element);
				}

				// When the option is outside the visible part of the opened panel, updates the scrollTop position
				// This is the default behaviour
				// To block it the plugin user must
				// add a "custom-select:focus-outside-panel" eventListener on the panel
				// with useCapture set to true
				// and stopPropagation
				function scrollToFocused(e) {
					var currPanel = e.currentTarget;
					var currOption = e.target;
					// Up
					if (currOption.offsetTop < currPanel.scrollTop) {
						currPanel.scrollTop = currOption.offsetTop;
						// Down
					} else {
						currPanel.scrollTop = currOption.offsetTop + currOption.clientHeight - currPanel.clientHeight;
					}
				}

				function addEvents() {
					document.addEventListener('click', clickEvent);
					panel.addEventListener('mouseover', mouseoverEvent);
					panel.addEventListener('custom-select:focus-outside-panel', scrollToFocused);
					select.addEventListener('change', changeEvent);
					container.addEventListener('keydown', keydownEvent);
				}

				function removeEvents() {
					document.removeEventListener('click', clickEvent);
					panel.removeEventListener('mouseover', mouseoverEvent);
					panel.removeEventListener('custom-select:focus-outside-panel', scrollToFocused);
					select.removeEventListener('change', changeEvent);
					container.removeEventListener('keydown', keydownEvent);
				}

				function disabled(bool) {
					if (bool && !select.disabled) {
						container.classList.add(builderParams.isDisabledClass);
						select.disabled = true;
						opener.removeAttribute('tabindex');
						container.dispatchEvent(new CustomEvent('custom-select:disabled'));
						removeEvents();
					} else if (!bool && select.disabled) {
						container.classList.remove(builderParams.isDisabledClass);
						select.disabled = false;
						opener.setAttribute('tabindex', '0');
						container.dispatchEvent(new CustomEvent('custom-select:enabled'));
						addEvents();
					}
				}

				// Form a given select children DOM tree (options and optgroup),
				// Creates the corresponding custom HTMLElements list (divs with different classes and attributes)
				function parseMarkup(children) {
					var nodeList = children;
					var cstList = [];

					if (typeof nodeList.length === 'undefined') {
						throw new TypeError('Invalid Argument');
					}

					for (var i = 0, li = nodeList.length; i < li; i++) {
						if (nodeList[i] instanceof HTMLElement && nodeList[i].tagName.toUpperCase() === 'OPTGROUP') {
							var cstOptgroup = document.createElement('div');
							cstOptgroup.classList.add(builderParams.optgroupClass);
							cstOptgroup.setAttribute('data-label', nodeList[i].label);

							// IMPORTANT: Stores in a property of the created custom option group
							// a hook to the the corrisponding select's option group
							cstOptgroup.customSelectOriginalOptgroup = nodeList[i];

							// IMPORTANT: Stores in a property of select's option group
							// a hook to the created custom option group
							nodeList[i].customSelectCstOptgroup = cstOptgroup;

							var subNodes = parseMarkup(nodeList[i].children);
							for (var j = 0, lj = subNodes.length; j < lj; j++) {
								cstOptgroup.appendChild(subNodes[j]);
							}

							cstList.push(cstOptgroup);
						} else if (nodeList[i] instanceof HTMLElement && nodeList[i].tagName.toUpperCase() === 'OPTION') {
							var cstOption = document.createElement('div');
							cstOption.classList.add(builderParams.optionClass);
							cstOption.textContent = nodeList[i].text;
							cstOption.setAttribute('data-value', nodeList[i].value);
							cstOption.setAttribute('role', 'option');

							// IMPORTANT: Stores in a property of the created custom option
							// a hook to the the corrisponding select's option
							cstOption.customSelectOriginalOption = nodeList[i];

							// IMPORTANT: Stores in a property of select's option
							// a hook to the created custom option
							nodeList[i].customSelectCstOption = cstOption;

							// If the select's option is selected
							if (nodeList[i].selected) {
								setSelectedElement(cstOption);
							}
							cstList.push(cstOption);
						} else {
							throw new TypeError('Invalid Argument');
						}
					}
					return cstList;
				}

				function _append(nodePar, appendIntoOriginal, targetPar) {
					var target = void 0;
					if (typeof targetPar === 'undefined' || targetPar === select) {
						target = panel;
					} else if (targetPar instanceof HTMLElement && targetPar.tagName.toUpperCase() === 'OPTGROUP' && select.contains(targetPar)) {
						target = targetPar.customSelectCstOptgroup;
					} else {
						throw new TypeError('Invalid Argument');
					}

					// If the node provided is a single HTMLElement it is stored in an array
					var node = nodePar instanceof HTMLElement ? [nodePar] : nodePar;

					// Injects the options|optgroup in the select
					if (appendIntoOriginal) {
						for (var i = 0, l = node.length; i < l; i++) {
							if (target === panel) {
								select.appendChild(node[i]);
							} else {
								target.customSelectOriginalOptgroup.appendChild(node[i]);
							}
						}
					}

					// The custom markup to append
					var markupToInsert = parseMarkup(node);

					// Injects the created DOM content in the panel
					for (var _i = 0, _l = markupToInsert.length; _i < _l; _i++) {
						target.appendChild(markupToInsert[_i]);
					}

					return node;
				}

				function _insertBefore(node, targetPar) {
					var target = void 0;
					if (targetPar instanceof HTMLElement && targetPar.tagName.toUpperCase() === 'OPTION' && select.contains(targetPar)) {
						target = targetPar.customSelectCstOption;
					} else if (targetPar instanceof HTMLElement && targetPar.tagName.toUpperCase() === 'OPTGROUP' && select.contains(targetPar)) {
						target = targetPar.customSelectCstOptgroup;
					} else {
						throw new TypeError('Invalid Argument');
					}

					// The custom markup to append
					var markupToInsert = parseMarkup(node.length ? node : [node]);

					target.parentNode.insertBefore(markupToInsert[0], target);

					// Injects the option or optgroup node in the original select and returns the injected node
					return targetPar.parentNode.insertBefore(node.length ? node[0] : node, targetPar);
				}

				function remove(node) {
					var cstNode = void 0;
					if (node instanceof HTMLElement && node.tagName.toUpperCase() === 'OPTION' && select.contains(node)) {
						cstNode = node.customSelectCstOption;
					} else if (node instanceof HTMLElement && node.tagName.toUpperCase() === 'OPTGROUP' && select.contains(node)) {
						cstNode = node.customSelectCstOptgroup;
					} else {
						throw new TypeError('Invalid Argument');
					}
					cstNode.parentNode.removeChild(cstNode);
					var removedNode = node.parentNode.removeChild(node);
					changeEvent();
					return removedNode;
				}

				function empty() {
					var removed = [];
					while (select.children.length) {
						panel.removeChild(panel.children[0]);
						removed.push(select.removeChild(select.children[0]));
					}
					setSelectedElement();
					return removed;
				}

				function destroy() {
					for (var i = 0, l = select.options.length; i < l; i++) {
						delete select.options[i].customSelectCstOption;
					}
					var optGroup = select.getElementsByTagName('optgroup');
					for (var _i2 = 0, _l2 = optGroup.length; _i2 < _l2; _i2++) {
						delete optGroup.customSelectCstOptgroup;
					}

					removeEvents();

					return container.parentNode.replaceChild(select, container);
				}
				//
				// Custom Select DOM tree creation
				//

				// Creates the container/wrapper
				container = document.createElement('div');
				container.classList.add(builderParams.containerClass, containerClass);

				// Creates the opener
				opener = document.createElement('span');
				opener.className = builderParams.openerClass;
				opener.setAttribute('role', 'combobox');
				opener.setAttribute('aria-autocomplete', 'list');
				opener.setAttribute('aria-expanded', 'false');
				opener.innerHTML = '<span>\n   ' + (select.selectedIndex !== -1 ? select.options[select.selectedIndex].text : '') + '\n   </span>';

				// Creates the panel
				// and injects the markup of the select inside
				// with some tag and attributes replacement
				panel = document.createElement('div');
				// Create random id
				var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
				for (var i = 0; i < 5; i++) {
					uId += possible.charAt(Math.floor(Math.random() * possible.length));
				}
				panel.id = containerClass + '-' + uId + '-panel';
				panel.className = builderParams.panelClass;
				panel.setAttribute('role', 'listbox');
				opener.setAttribute('aria-owns', panel.id);

				_append(select.children, false);

				// Injects the container in the original DOM position of the select
				container.appendChild(opener);
				select.parentNode.replaceChild(container, select);
				container.appendChild(select);
				container.appendChild(panel);

				// ARIA labelledby - label
				if (document.querySelector('label[for="' + select.id + '"]')) {
					currLabel = document.querySelector('label[for="' + select.id + '"]');
				} else if (container.parentNode.tagName.toUpperCase() === 'LABEL') {
					currLabel = container.parentNode;
				}
				if (typeof currLabel !== 'undefined') {
					currLabel.setAttribute('id', containerClass + '-' + uId + '-label');
					opener.setAttribute('aria-labelledby', containerClass + '-' + uId + '-label');
				}

				// Event Init
				if (select.disabled) {
					container.classList.add(builderParams.isDisabledClass);
				} else {
					opener.setAttribute('tabindex', '0');
					select.setAttribute('tabindex', '-1');
					addEvents();
				}

				// Stores the plugin public exposed methods and properties, directly in the container HTMLElement
				container.customSelect = {
					get pluginOptions() {
						return builderParams;
					},
					get open() {
						return isOpen;
					},
					set open(bool) {
						open(bool);
					},
					get disabled() {
						return select.disabled;
					},
					set disabled(bool) {
						disabled(bool);
					},
					get value() {
						return select.value;
					},
					set value(val) {
						setValue(val);
					},
					append: function append(node, target) {
						return _append(node, true, target);
					},
					insertBefore: function insertBefore(node, target) {
						return _insertBefore(node, target);
					},
					remove: remove,
					empty: empty,
					destroy: destroy,
					opener: opener,
					select: select,
					panel: panel,
					container: container
				};

				// Stores the plugin directly in the original select
				select.customSelect = container.customSelect;

				// Returns the plugin instance, with the public exposed methods and properties
				return container.customSelect;
			}

			function customSelect(element, customParams) {
				// Overrides the default options with the ones provided by the user
				var nodeList = [];
				var selects = [];

				return function init() {
					// The plugin is called on a single HTMLElement
					if (element && element instanceof HTMLElement && element.tagName.toUpperCase() === 'SELECT') {
						nodeList.push(element);
						// The plugin is called on a selector
					} else if (element && typeof element === 'string') {
						var elementsList = document.querySelectorAll(element);
						for (var i = 0, l = elementsList.length; i < l; ++i) {
							if (elementsList[i] instanceof HTMLElement && elementsList[i].tagName.toUpperCase() === 'SELECT') {
								nodeList.push(elementsList[i]);
							}
						}
						// The plugin is called on any HTMLElements list (NodeList, HTMLCollection, Array, etc.)
					} else if (element && element.length) {
						for (var _i3 = 0, _l3 = element.length; _i3 < _l3; ++_i3) {
							if (element[_i3] instanceof HTMLElement && element[_i3].tagName.toUpperCase() === 'SELECT') {
								nodeList.push(element[_i3]);
							}
						}
					}

					// Launches the plugin over every HTMLElement
					// And stores every plugin instance
					for (var _i4 = 0, _l4 = nodeList.length; _i4 < _l4; ++_i4) {
						selects.push(builder(nodeList[_i4], _extends({}, defaultParams, customParams)));
					}

					// Returns all plugin instances
					return selects;
				}();
			}

			//# sourceMappingURL=index.js.map

			/***/
		}),

/***/ "./node_modules/desandro-matches-selector/matches-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/desandro-matches-selector/matches-selector.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

			/*jshint browser: true, strict: true, undef: true, unused: true */

			(function (window, factory) {
				/*global define: false, module: false */
				'use strict';
				// universal module definition
				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
							__WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory() {
				'use strict';

				var matchesMethod = (function () {
					var ElemProto = window.Element.prototype;
					// check for the standard method name first
					if (ElemProto.matches) {
						return 'matches';
					}
					// check un-prefixed
					if (ElemProto.matchesSelector) {
						return 'matchesSelector';
					}
					// check vendor prefixes
					var prefixes = ['webkit', 'moz', 'ms', 'o'];

					for (var i = 0; i < prefixes.length; i++) {
						var prefix = prefixes[i];
						var method = prefix + 'MatchesSelector';
						if (ElemProto[method]) {
							return method;
						}
					}
				})();

				return function matchesSelector(elem, selector) {
					return elem[matchesMethod](selector);
				};

			}));


			/***/
		}),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

			/* jshint unused: true, undef: true, strict: true */

			(function (global, factory) {
				// universal module definition
				/* jshint strict: false */ /* globals define, module, window */
				if (true) {
					// AMD - RequireJS
					!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
							__WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(typeof window != 'undefined' ? window : this, function () {

				"use strict";

				function EvEmitter() { }

				var proto = EvEmitter.prototype;

				proto.on = function (eventName, listener) {
					if (!eventName || !listener) {
						return;
					}
					// set events hash
					var events = this._events = this._events || {};
					// set listeners array
					var listeners = events[eventName] = events[eventName] || [];
					// only add once
					if (listeners.indexOf(listener) == -1) {
						listeners.push(listener);
					}

					return this;
				};

				proto.once = function (eventName, listener) {
					if (!eventName || !listener) {
						return;
					}
					// add event
					this.on(eventName, listener);
					// set once flag
					// set onceEvents hash
					var onceEvents = this._onceEvents = this._onceEvents || {};
					// set onceListeners object
					var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
					// set flag
					onceListeners[listener] = true;

					return this;
				};

				proto.off = function (eventName, listener) {
					var listeners = this._events && this._events[eventName];
					if (!listeners || !listeners.length) {
						return;
					}
					var index = listeners.indexOf(listener);
					if (index != -1) {
						listeners.splice(index, 1);
					}

					return this;
				};

				proto.emitEvent = function (eventName, args) {
					var listeners = this._events && this._events[eventName];
					if (!listeners || !listeners.length) {
						return;
					}
					// copy over to avoid interference if .off() in listener
					listeners = listeners.slice(0);
					args = args || [];
					// once stuff
					var onceListeners = this._onceEvents && this._onceEvents[eventName];

					for (var i = 0; i < listeners.length; i++) {
						var listener = listeners[i]
						var isOnce = onceListeners && onceListeners[listener];
						if (isOnce) {
							// remove listener
							// remove before trigger to prevent recursion
							this.off(eventName, listener);
							// unset once flag
							delete onceListeners[listener];
						}
						// trigger listener
						listener.apply(this, args);
					}

					return this;
				};

				proto.allOff = function () {
					delete this._events;
					delete this._onceEvents;
				};

				return EvEmitter;

			}));


			/***/
		}),

/***/ "./node_modules/fizzy-ui-utils/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/fizzy-ui-utils/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Fizzy UI utils v2.0.7
 * MIT license
 */

			/*jshint browser: true, undef: true, unused: true, strict: true */

			(function (window, factory) {
				// universal module definition
				/*jshint strict: false */ /*globals define, module, require */

				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
						__webpack_require__(/*! desandro-matches-selector/matches-selector */ "./node_modules/desandro-matches-selector/matches-selector.js")
					], __WEBPACK_AMD_DEFINE_RESULT__ = (function (matchesSelector) {
						return factory(window, matchesSelector);
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory(window, matchesSelector) {

				'use strict';

				var utils = {};

				// ----- extend ----- //

				// extends objects
				utils.extend = function (a, b) {
					for (var prop in b) {
						a[prop] = b[prop];
					}
					return a;
				};

				// ----- modulo ----- //

				utils.modulo = function (num, div) {
					return ((num % div) + div) % div;
				};

				// ----- makeArray ----- //

				var arraySlice = Array.prototype.slice;

				// turn element or nodeList into an array
				utils.makeArray = function (obj) {
					if (Array.isArray(obj)) {
						// use object if already an array
						return obj;
					}
					// return empty array if undefined or null. #6
					if (obj === null || obj === undefined) {
						return [];
					}

					var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
					if (isArrayLike) {
						// convert nodeList to array
						return arraySlice.call(obj);
					}

					// array of single index
					return [obj];
				};

				// ----- removeFrom ----- //

				utils.removeFrom = function (ary, obj) {
					var index = ary.indexOf(obj);
					if (index != -1) {
						ary.splice(index, 1);
					}
				};

				// ----- getParent ----- //

				utils.getParent = function (elem, selector) {
					while (elem.parentNode && elem != document.body) {
						elem = elem.parentNode;
						if (matchesSelector(elem, selector)) {
							return elem;
						}
					}
				};

				// ----- getQueryElement ----- //

				// use element as selector string
				utils.getQueryElement = function (elem) {
					if (typeof elem == 'string') {
						return document.querySelector(elem);
					}
					return elem;
				};

				// ----- handleEvent ----- //

				// enable .ontype to trigger from .addEventListener( elem, 'type' )
				utils.handleEvent = function (event) {
					var method = 'on' + event.type;
					if (this[method]) {
						this[method](event);
					}
				};

				// ----- filterFindElements ----- //

				utils.filterFindElements = function (elems, selector) {
					// make array of elems
					elems = utils.makeArray(elems);
					var ffElems = [];

					elems.forEach(function (elem) {
						// check that elem is an actual element
						if (!(elem instanceof HTMLElement)) {
							return;
						}
						// add elem if no selector
						if (!selector) {
							ffElems.push(elem);
							return;
						}
						// filter & find items if we have a selector
						// filter
						if (matchesSelector(elem, selector)) {
							ffElems.push(elem);
						}
						// find children
						var childElems = elem.querySelectorAll(selector);
						// concat childElems to filterFound array
						for (var i = 0; i < childElems.length; i++) {
							ffElems.push(childElems[i]);
						}
					});

					return ffElems;
				};

				// ----- debounceMethod ----- //

				utils.debounceMethod = function (_class, methodName, threshold) {
					threshold = threshold || 100;
					// original method
					var method = _class.prototype[methodName];
					var timeoutName = methodName + 'Timeout';

					_class.prototype[methodName] = function () {
						var timeout = this[timeoutName];
						clearTimeout(timeout);

						var args = arguments;
						var _this = this;
						this[timeoutName] = setTimeout(function () {
							method.apply(_this, args);
							delete _this[timeoutName];
						}, threshold);
					};
				};

				// ----- docReady ----- //

				utils.docReady = function (callback) {
					var readyState = document.readyState;
					if (readyState == 'complete' || readyState == 'interactive') {
						// do async to allow for other scripts to run. metafizzy/flickity#441
						setTimeout(callback);
					} else {
						document.addEventListener('DOMContentLoaded', callback);
					}
				};

				// ----- htmlInit ----- //

				// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
				utils.toDashed = function (str) {
					return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {
						return $1 + '-' + $2;
					}).toLowerCase();
				};

				var console = window.console;
				/**
				 * allow user to initialize classes via [data-namespace] or .js-namespace class
				 * htmlInit( Widget, 'widgetName' )
				 * options are parsed from data-namespace-options
				 */
				utils.htmlInit = function (WidgetClass, namespace) {
					utils.docReady(function () {
						var dashedNamespace = utils.toDashed(namespace);
						var dataAttr = 'data-' + dashedNamespace;
						var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
						var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
						var elems = utils.makeArray(dataAttrElems)
							.concat(utils.makeArray(jsDashElems));
						var dataOptionsAttr = dataAttr + '-options';
						var jQuery = window.jQuery;

						elems.forEach(function (elem) {
							var attr = elem.getAttribute(dataAttr) ||
								elem.getAttribute(dataOptionsAttr);
							var options;
							try {
								options = attr && JSON.parse(attr);
							} catch (error) {
								// log error, do not initialize
								if (console) {
									console.error('Error parsing ' + dataAttr + ' on ' + elem.className +
										': ' + error);
								}
								return;
							}
							// initialize
							var instance = new WidgetClass(elem, options);
							// make available via $().data('namespace')
							if (jQuery) {
								jQuery.data(elem, namespace, instance);
							}
						});

					});
				};

				// -----  ----- //

				return utils;

			}));


			/***/
		}),

/***/ "./node_modules/get-size/get-size.js":
/*!*******************************************!*\
  !*** ./node_modules/get-size/get-size.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */

			/* jshint browser: true, strict: true, undef: true, unused: true */
			/* globals console: false */

			(function (window, factory) {
				/* jshint strict: false */ /* globals define, module */
				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
							__WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			})(window, function factory() {
				'use strict';

				// -------------------------- helpers -------------------------- //

				// get a number from a string, not a percentage
				function getStyleSize(value) {
					var num = parseFloat(value);
					// not a percent like '100%', and a number
					var isValid = value.indexOf('%') == -1 && !isNaN(num);
					return isValid && num;
				}

				function noop() { }

				var logError = typeof console == 'undefined' ? noop :
					function (message) {
						console.error(message);
					};

				// -------------------------- measurements -------------------------- //

				var measurements = [
					'paddingLeft',
					'paddingRight',
					'paddingTop',
					'paddingBottom',
					'marginLeft',
					'marginRight',
					'marginTop',
					'marginBottom',
					'borderLeftWidth',
					'borderRightWidth',
					'borderTopWidth',
					'borderBottomWidth'
				];

				var measurementsLength = measurements.length;

				function getZeroSize() {
					var size = {
						width: 0,
						height: 0,
						innerWidth: 0,
						innerHeight: 0,
						outerWidth: 0,
						outerHeight: 0
					};
					for (var i = 0; i < measurementsLength; i++) {
						var measurement = measurements[i];
						size[measurement] = 0;
					}
					return size;
				}

				// -------------------------- getStyle -------------------------- //

				/**
				 * getStyle, get style of element, check for Firefox bug
				 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
				 */
				function getStyle(elem) {
					var style = getComputedStyle(elem);
					if (!style) {
						logError('Style returned ' + style +
							'. Are you running this code in a hidden iframe on Firefox? ' +
							'See https://bit.ly/getsizebug1');
					}
					return style;
				}

				// -------------------------- setup -------------------------- //

				var isSetup = false;

				var isBoxSizeOuter;

				/**
				 * setup
				 * check isBoxSizerOuter
				 * do on first getSize() rather than on page load for Firefox bug
				 */
				function setup() {
					// setup once
					if (isSetup) {
						return;
					}
					isSetup = true;

					// -------------------------- box sizing -------------------------- //

					/**
					 * Chrome & Safari measure the outer-width on style.width on border-box elems
					 * IE11 & Firefox<29 measures the inner-width
					 */
					var div = document.createElement('div');
					div.style.width = '200px';
					div.style.padding = '1px 2px 3px 4px';
					div.style.borderStyle = 'solid';
					div.style.borderWidth = '1px 2px 3px 4px';
					div.style.boxSizing = 'border-box';

					var body = document.body || document.documentElement;
					body.appendChild(div);
					var style = getStyle(div);
					// round value for browser zoom. desandro/masonry#928
					isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
					getSize.isBoxSizeOuter = isBoxSizeOuter;

					body.removeChild(div);
				}

				// -------------------------- getSize -------------------------- //

				function getSize(elem) {
					setup();

					// use querySeletor if elem is string
					if (typeof elem == 'string') {
						elem = document.querySelector(elem);
					}

					// do not proceed on non-objects
					if (!elem || typeof elem != 'object' || !elem.nodeType) {
						return;
					}

					var style = getStyle(elem);

					// if hidden, everything is 0
					if (style.display == 'none') {
						return getZeroSize();
					}

					var size = {};
					size.width = elem.offsetWidth;
					size.height = elem.offsetHeight;

					var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

					// get all measurements
					for (var i = 0; i < measurementsLength; i++) {
						var measurement = measurements[i];
						var value = style[measurement];
						var num = parseFloat(value);
						// any 'auto', 'medium' value will be 0
						size[measurement] = !isNaN(num) ? num : 0;
					}

					var paddingWidth = size.paddingLeft + size.paddingRight;
					var paddingHeight = size.paddingTop + size.paddingBottom;
					var marginWidth = size.marginLeft + size.marginRight;
					var marginHeight = size.marginTop + size.marginBottom;
					var borderWidth = size.borderLeftWidth + size.borderRightWidth;
					var borderHeight = size.borderTopWidth + size.borderBottomWidth;

					var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

					// overwrite width and height if we can get it from style
					var styleWidth = getStyleSize(style.width);
					if (styleWidth !== false) {
						size.width = styleWidth +
							// add padding and border unless it's already including it
							(isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
					}

					var styleHeight = getStyleSize(style.height);
					if (styleHeight !== false) {
						size.height = styleHeight +
							// add padding and border unless it's already including it
							(isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
					}

					size.innerWidth = size.width - (paddingWidth + borderWidth);
					size.innerHeight = size.height - (paddingHeight + borderHeight);

					size.outerWidth = size.width + marginWidth;
					size.outerHeight = size.height + marginHeight;

					return size;
				}

				return getSize;

			});


			/***/
		}),

/***/ "./node_modules/imagesloaded/imagesloaded.js":
/*!***************************************************!*\
  !*** ./node_modules/imagesloaded/imagesloaded.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

			(function (window, factory) {
				'use strict';
				// universal module definition

				/*global define: false, module: false, require: false */

				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
						__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js")
					], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter) {
						return factory(window, EvEmitter);
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			})(typeof window !== 'undefined' ? window : this,

				// --------------------------  factory -------------------------- //

				function factory(window, EvEmitter) {

					'use strict';

					var $ = window.jQuery;
					var console = window.console;

					// -------------------------- helpers -------------------------- //

					// extend objects
					function extend(a, b) {
						for (var prop in b) {
							a[prop] = b[prop];
						}
						return a;
					}

					var arraySlice = Array.prototype.slice;

					// turn element or nodeList into an array
					function makeArray(obj) {
						if (Array.isArray(obj)) {
							// use object if already an array
							return obj;
						}

						var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
						if (isArrayLike) {
							// convert nodeList to array
							return arraySlice.call(obj);
						}

						// array of single index
						return [obj];
					}

					// -------------------------- imagesLoaded -------------------------- //

					/**
					 * @param {Array, Element, NodeList, String} elem
					 * @param {Object or Function} options - if function, use as callback
					 * @param {Function} onAlways - callback function
					 */
					function ImagesLoaded(elem, options, onAlways) {
						// coerce ImagesLoaded() without new, to be new ImagesLoaded()
						if (!(this instanceof ImagesLoaded)) {
							return new ImagesLoaded(elem, options, onAlways);
						}
						// use elem as selector string
						var queryElem = elem;
						if (typeof elem == 'string') {
							queryElem = document.querySelectorAll(elem);
						}
						// bail if bad element
						if (!queryElem) {
							console.error('Bad element for imagesLoaded ' + (queryElem || elem));
							return;
						}

						this.elements = makeArray(queryElem);
						this.options = extend({}, this.options);
						// shift arguments if no options set
						if (typeof options == 'function') {
							onAlways = options;
						} else {
							extend(this.options, options);
						}

						if (onAlways) {
							this.on('always', onAlways);
						}

						this.getImages();

						if ($) {
							// add jQuery Deferred object
							this.jqDeferred = new $.Deferred();
						}

						// HACK check async to allow time to bind listeners
						setTimeout(this.check.bind(this));
					}

					ImagesLoaded.prototype = Object.create(EvEmitter.prototype);

					ImagesLoaded.prototype.options = {};

					ImagesLoaded.prototype.getImages = function () {
						this.images = [];

						// filter & find items if we have an item selector
						this.elements.forEach(this.addElementImages, this);
					};

					/**
					 * @param {Node} element
					 */
					ImagesLoaded.prototype.addElementImages = function (elem) {
						// filter siblings
						if (elem.nodeName == 'IMG') {
							this.addImage(elem);
						}
						// get background image on element
						if (this.options.background === true) {
							this.addElementBackgroundImages(elem);
						}

						// find children
						// no non-element nodes, #143
						var nodeType = elem.nodeType;
						if (!nodeType || !elementNodeTypes[nodeType]) {
							return;
						}
						var childImgs = elem.querySelectorAll('img');
						// concat childElems to filterFound array
						for (var i = 0; i < childImgs.length; i++) {
							var img = childImgs[i];
							this.addImage(img);
						}

						// get child background images
						if (typeof this.options.background == 'string') {
							var children = elem.querySelectorAll(this.options.background);
							for (i = 0; i < children.length; i++) {
								var child = children[i];
								this.addElementBackgroundImages(child);
							}
						}
					};

					var elementNodeTypes = {
						1: true,
						9: true,
						11: true
					};

					ImagesLoaded.prototype.addElementBackgroundImages = function (elem) {
						var style = getComputedStyle(elem);
						if (!style) {
							// Firefox returns null if in a hidden iframe https://bugzil.la/548397
							return;
						}
						// get url inside url("...")
						var reURL = /url\((['"])?(.*?)\1\)/gi;
						var matches = reURL.exec(style.backgroundImage);
						while (matches !== null) {
							var url = matches && matches[2];
							if (url) {
								this.addBackground(url, elem);
							}
							matches = reURL.exec(style.backgroundImage);
						}
					};

					/**
					 * @param {Image} img
					 */
					ImagesLoaded.prototype.addImage = function (img) {
						var loadingImage = new LoadingImage(img);
						this.images.push(loadingImage);
					};

					ImagesLoaded.prototype.addBackground = function (url, elem) {
						var background = new Background(url, elem);
						this.images.push(background);
					};

					ImagesLoaded.prototype.check = function () {
						var _this = this;
						this.progressedCount = 0;
						this.hasAnyBroken = false;
						// complete if no images
						if (!this.images.length) {
							this.complete();
							return;
						}

						function onProgress(image, elem, message) {
							// HACK - Chrome triggers event before object properties have changed. #83
							setTimeout(function () {
								_this.progress(image, elem, message);
							});
						}

						this.images.forEach(function (loadingImage) {
							loadingImage.once('progress', onProgress);
							loadingImage.check();
						});
					};

					ImagesLoaded.prototype.progress = function (image, elem, message) {
						this.progressedCount++;
						this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
						// progress event
						this.emitEvent('progress', [this, image, elem]);
						if (this.jqDeferred && this.jqDeferred.notify) {
							this.jqDeferred.notify(this, image);
						}
						// check if completed
						if (this.progressedCount == this.images.length) {
							this.complete();
						}

						if (this.options.debug && console) {
							console.log('progress: ' + message, image, elem);
						}
					};

					ImagesLoaded.prototype.complete = function () {
						var eventName = this.hasAnyBroken ? 'fail' : 'done';
						this.isComplete = true;
						this.emitEvent(eventName, [this]);
						this.emitEvent('always', [this]);
						if (this.jqDeferred) {
							var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
							this.jqDeferred[jqMethod](this);
						}
					};

					// --------------------------  -------------------------- //

					function LoadingImage(img) {
						this.img = img;
					}

					LoadingImage.prototype = Object.create(EvEmitter.prototype);

					LoadingImage.prototype.check = function () {
						// If complete is true and browser supports natural sizes,
						// try to check for image status manually.
						var isComplete = this.getIsImageComplete();
						if (isComplete) {
							// report based on naturalWidth
							this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');
							return;
						}

						// If none of the checks above matched, simulate loading on detached element.
						this.proxyImage = new Image();
						this.proxyImage.addEventListener('load', this);
						this.proxyImage.addEventListener('error', this);
						// bind to image as well for Firefox. #191
						this.img.addEventListener('load', this);
						this.img.addEventListener('error', this);
						this.proxyImage.src = this.img.src;
					};

					LoadingImage.prototype.getIsImageComplete = function () {
						// check for non-zero, non-undefined naturalWidth
						// fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
						return this.img.complete && this.img.naturalWidth;
					};

					LoadingImage.prototype.confirm = function (isLoaded, message) {
						this.isLoaded = isLoaded;
						this.emitEvent('progress', [this, this.img, message]);
					};

					// ----- events ----- //

					// trigger specified handler for event type
					LoadingImage.prototype.handleEvent = function (event) {
						var method = 'on' + event.type;
						if (this[method]) {
							this[method](event);
						}
					};

					LoadingImage.prototype.onload = function () {
						this.confirm(true, 'onload');
						this.unbindEvents();
					};

					LoadingImage.prototype.onerror = function () {
						this.confirm(false, 'onerror');
						this.unbindEvents();
					};

					LoadingImage.prototype.unbindEvents = function () {
						this.proxyImage.removeEventListener('load', this);
						this.proxyImage.removeEventListener('error', this);
						this.img.removeEventListener('load', this);
						this.img.removeEventListener('error', this);
					};

					// -------------------------- Background -------------------------- //

					function Background(url, element) {
						this.url = url;
						this.element = element;
						this.img = new Image();
					}

					// inherit LoadingImage prototype
					Background.prototype = Object.create(LoadingImage.prototype);

					Background.prototype.check = function () {
						this.img.addEventListener('load', this);
						this.img.addEventListener('error', this);
						this.img.src = this.url;
						// check if image is already complete
						var isComplete = this.getIsImageComplete();
						if (isComplete) {
							this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');
							this.unbindEvents();
						}
					};

					Background.prototype.unbindEvents = function () {
						this.img.removeEventListener('load', this);
						this.img.removeEventListener('error', this);
					};

					Background.prototype.confirm = function (isLoaded, message) {
						this.isLoaded = isLoaded;
						this.emitEvent('progress', [this, this.element, message]);
					};

					// -------------------------- jQuery -------------------------- //

					ImagesLoaded.makeJQueryPlugin = function (jQuery) {
						jQuery = jQuery || window.jQuery;
						if (!jQuery) {
							return;
						}
						// set local variable
						$ = jQuery;
						// $().imagesLoaded()
						$.fn.imagesLoaded = function (options, callback) {
							var instance = new ImagesLoaded(this, options, callback);
							return instance.jqDeferred.promise($(this));
						};
					};
					// try making plugin
					ImagesLoaded.makeJQueryPlugin();

					// --------------------------  -------------------------- //

					return ImagesLoaded;

				});


			/***/
		}),

/***/ "./node_modules/jquery-bridget/jquery-bridget.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery-bridget/jquery-bridget.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Bridget makes jQuery widgets
 * v2.0.1
 * MIT license
 */

			/* jshint browser: true, strict: true, undef: true, unused: true */

			(function (window, factory) {
				// universal module definition
				/*jshint strict: false */ /* globals define, module, require */
				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
						return factory(window, jQuery);
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory(window, jQuery) {
				'use strict';

				// ----- utils ----- //

				var arraySlice = Array.prototype.slice;

				// helper function for logging errors
				// $.error breaks jQuery chaining
				var console = window.console;
				var logError = typeof console == 'undefined' ? function () { } :
					function (message) {
						console.error(message);
					};

				// ----- jQueryBridget ----- //

				function jQueryBridget(namespace, PluginClass, $) {
					$ = $ || jQuery || window.jQuery;
					if (!$) {
						return;
					}

					// add option method -> $().plugin('option', {...})
					if (!PluginClass.prototype.option) {
						// option setter
						PluginClass.prototype.option = function (opts) {
							// bail out if not an object
							if (!$.isPlainObject(opts)) {
								return;
							}
							this.options = $.extend(true, this.options, opts);
						};
					}

					// make jQuery plugin
					$.fn[namespace] = function (arg0 /*, arg1 */) {
						if (typeof arg0 == 'string') {
							// method call $().plugin( 'methodName', { options } )
							// shift arguments by 1
							var args = arraySlice.call(arguments, 1);
							return methodCall(this, arg0, args);
						}
						// just $().plugin({ options })
						plainCall(this, arg0);
						return this;
					};

					// $().plugin('methodName')
					function methodCall($elems, methodName, args) {
						var returnValue;
						var pluginMethodStr = '$().' + namespace + '("' + methodName + '")';

						$elems.each(function (i, elem) {
							// get instance
							var instance = $.data(elem, namespace);
							if (!instance) {
								logError(namespace + ' not initialized. Cannot call methods, i.e. ' +
									pluginMethodStr);
								return;
							}

							var method = instance[methodName];
							if (!method || methodName.charAt(0) == '_') {
								logError(pluginMethodStr + ' is not a valid method');
								return;
							}

							// apply method, get return value
							var value = method.apply(instance, args);
							// set return value if value is returned, use only first value
							returnValue = returnValue === undefined ? value : returnValue;
						});

						return returnValue !== undefined ? returnValue : $elems;
					}

					function plainCall($elems, options) {
						$elems.each(function (i, elem) {
							var instance = $.data(elem, namespace);
							if (instance) {
								// set options & init
								instance.option(options);
								instance._init();
							} else {
								// initialize new instance
								instance = new PluginClass(elem, options);
								$.data(elem, namespace, instance);
							}
						});
					}

					updateJQuery($);

				}

				// ----- updateJQuery ----- //

				// set $.bridget for v1 backwards compatibility
				function updateJQuery($) {
					if (!$ || ($ && $.bridget)) {
						return;
					}
					$.bridget = jQueryBridget;
				}

				updateJQuery(jQuery || window.jQuery);

				// -----  ----- //

				return jQueryBridget;

			}));


			/***/
		}),

/***/ "./node_modules/jquery-colorbox/jquery.colorbox.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery-colorbox/jquery.colorbox.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			/*!
				Colorbox 1.6.4
				license: MIT
				http://www.jacklmoore.com/colorbox
			*/
			(function ($, document, window) {
				var
					// Default settings object.
					// See http://jacklmoore.com/colorbox for details.
					defaults = {
						// data sources
						html: false,
						photo: false,
						iframe: false,
						inline: false,

						// behavior and appearance
						transition: "elastic",
						speed: 300,
						fadeOut: 300,
						width: false,
						initialWidth: "600",
						innerWidth: false,
						maxWidth: false,
						height: false,
						initialHeight: "450",
						innerHeight: false,
						maxHeight: false,
						scalePhotos: true,
						scrolling: true,
						opacity: 0.9,
						preloading: true,
						className: false,
						overlayClose: true,
						escKey: true,
						arrowKey: true,
						top: false,
						bottom: false,
						left: false,
						right: false,
						fixed: false,
						data: undefined,
						closeButton: true,
						fastIframe: true,
						open: false,
						reposition: true,
						loop: true,
						slideshow: false,
						slideshowAuto: true,
						slideshowSpeed: 2500,
						slideshowStart: "start slideshow",
						slideshowStop: "stop slideshow",
						photoRegex: /\.(gif|png|jp(e|g|eg)|bmp|ico|webp|jxr|svg)((#|\?).*)?$/i,

						// alternate image paths for high-res displays
						retinaImage: false,
						retinaUrl: false,
						retinaSuffix: '@2x.$1',

						// internationalization
						current: "image {current} of {total}",
						previous: "previous",
						next: "next",
						close: "close",
						xhrError: "This content failed to load.",
						imgError: "This image failed to load.",

						// accessbility
						returnFocus: true,
						trapFocus: true,

						// callbacks
						onOpen: false,
						onLoad: false,
						onComplete: false,
						onCleanup: false,
						onClosed: false,

						rel: function () {
							return this.rel;
						},
						href: function () {
							// using this.href would give the absolute url, when the href may have been inteded as a selector (e.g. '#container')
							return $(this).attr('href');
						},
						title: function () {
							return this.title;
						},
						createImg: function () {
							var img = new Image();
							var attrs = $(this).data('cbox-img-attrs');

							if (typeof attrs === 'object') {
								$.each(attrs, function (key, val) {
									img[key] = val;
								});
							}

							return img;
						},
						createIframe: function () {
							var iframe = document.createElement('iframe');
							var attrs = $(this).data('cbox-iframe-attrs');

							if (typeof attrs === 'object') {
								$.each(attrs, function (key, val) {
									iframe[key] = val;
								});
							}

							if ('frameBorder' in iframe) {
								iframe.frameBorder = 0;
							}
							if ('allowTransparency' in iframe) {
								iframe.allowTransparency = "true";
							}
							iframe.name = (new Date()).getTime(); // give the iframe a unique name to prevent caching
							iframe.allowFullscreen = true;

							return iframe;
						}
					},

					// Abstracting the HTML and event identifiers for easy rebranding
					colorbox = 'colorbox',
					prefix = 'cbox',
					boxElement = prefix + 'Element',

					// Events
					event_open = prefix + '_open',
					event_load = prefix + '_load',
					event_complete = prefix + '_complete',
					event_cleanup = prefix + '_cleanup',
					event_closed = prefix + '_closed',
					event_purge = prefix + '_purge',

					// Cached jQuery Object Variables
					$overlay,
					$box,
					$wrap,
					$content,
					$topBorder,
					$leftBorder,
					$rightBorder,
					$bottomBorder,
					$related,
					$window,
					$loaded,
					$loadingBay,
					$loadingOverlay,
					$title,
					$current,
					$slideshow,
					$next,
					$prev,
					$close,
					$groupControls,
					$events = $('<a/>'), // $({}) would be prefered, but there is an issue with jQuery 1.4.2

					// Variables for cached values or use across multiple functions
					settings,
					interfaceHeight,
					interfaceWidth,
					loadedHeight,
					loadedWidth,
					index,
					photo,
					open,
					active,
					closing,
					loadingTimer,
					publicMethod,
					div = "div",
					requests = 0,
					previousCSS = {},
					init;

				// ****************
				// HELPER FUNCTIONS
				// ****************

				// Convenience function for creating new jQuery objects
				function $tag(tag, id, css) {
					var element = document.createElement(tag);

					if (id) {
						element.id = prefix + id;
					}

					if (css) {
						element.style.cssText = css;
					}

					return $(element);
				}

				// Get the window height using innerHeight when available to avoid an issue with iOS
				// http://bugs.jquery.com/ticket/6724
				function winheight() {
					return window.innerHeight ? window.innerHeight : $(window).height();
				}

				function Settings(element, options) {
					if (options !== Object(options)) {
						options = {};
					}

					this.cache = {};
					this.el = element;

					this.value = function (key) {
						var dataAttr;

						if (this.cache[key] === undefined) {
							dataAttr = $(this.el).attr('data-cbox-' + key);

							if (dataAttr !== undefined) {
								this.cache[key] = dataAttr;
							} else if (options[key] !== undefined) {
								this.cache[key] = options[key];
							} else if (defaults[key] !== undefined) {
								this.cache[key] = defaults[key];
							}
						}

						return this.cache[key];
					};

					this.get = function (key) {
						var value = this.value(key);
						return $.isFunction(value) ? value.call(this.el, this) : value;
					};
				}

				// Determine the next and previous members in a group.
				function getIndex(increment) {
					var
						max = $related.length,
						newIndex = (index + increment) % max;

					return (newIndex < 0) ? max + newIndex : newIndex;
				}

				// Convert '%' and 'px' values to integers
				function setSize(size, dimension) {
					return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
				}

				// Checks an href to see if it is a photo.
				// There is a force photo option (photo: true) for hrefs that cannot be matched by the regex.
				function isImage(settings, url) {
					return settings.get('photo') || settings.get('photoRegex').test(url);
				}

				function retinaUrl(settings, url) {
					return settings.get('retinaUrl') && window.devicePixelRatio > 1 ? url.replace(settings.get('photoRegex'), settings.get('retinaSuffix')) : url;
				}

				function trapFocus(e) {
					if ('contains' in $box[0] && !$box[0].contains(e.target) && e.target !== $overlay[0]) {
						e.stopPropagation();
						$box.focus();
					}
				}

				function setClass(str) {
					if (setClass.str !== str) {
						$box.add($overlay).removeClass(setClass.str).addClass(str);
						setClass.str = str;
					}
				}

				function getRelated(rel) {
					index = 0;

					if (rel && rel !== false && rel !== 'nofollow') {
						$related = $('.' + boxElement).filter(function () {
							var options = $.data(this, colorbox);
							var settings = new Settings(this, options);
							return (settings.get('rel') === rel);
						});
						index = $related.index(settings.el);

						// Check direct calls to Colorbox.
						if (index === -1) {
							$related = $related.add(settings.el);
							index = $related.length - 1;
						}
					} else {
						$related = $(settings.el);
					}
				}

				function trigger(event) {
					// for external use
					$(document).trigger(event);
					// for internal use
					$events.triggerHandler(event);
				}

				var slideshow = (function () {
					var active,
						className = prefix + "Slideshow_",
						click = "click." + prefix,
						timeOut;

					function clear() {
						clearTimeout(timeOut);
					}

					function set() {
						if (settings.get('loop') || $related[index + 1]) {
							clear();
							timeOut = setTimeout(publicMethod.next, settings.get('slideshowSpeed'));
						}
					}

					function start() {
						$slideshow
							.html(settings.get('slideshowStop'))
							.unbind(click)
							.one(click, stop);

						$events
							.bind(event_complete, set)
							.bind(event_load, clear);

						$box.removeClass(className + "off").addClass(className + "on");
					}

					function stop() {
						clear();

						$events
							.unbind(event_complete, set)
							.unbind(event_load, clear);

						$slideshow
							.html(settings.get('slideshowStart'))
							.unbind(click)
							.one(click, function () {
								publicMethod.next();
								start();
							});

						$box.removeClass(className + "on").addClass(className + "off");
					}

					function reset() {
						active = false;
						$slideshow.hide();
						clear();
						$events
							.unbind(event_complete, set)
							.unbind(event_load, clear);
						$box.removeClass(className + "off " + className + "on");
					}

					return function () {
						if (active) {
							if (!settings.get('slideshow')) {
								$events.unbind(event_cleanup, reset);
								reset();
							}
						} else {
							if (settings.get('slideshow') && $related[1]) {
								active = true;
								$events.one(event_cleanup, reset);
								if (settings.get('slideshowAuto')) {
									start();
								} else {
									stop();
								}
								$slideshow.show();
							}
						}
					};

				}());


				function launch(element) {
					var options;

					if (!closing) {

						options = $(element).data(colorbox);

						settings = new Settings(element, options);

						getRelated(settings.get('rel'));

						if (!open) {
							open = active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.

							setClass(settings.get('className'));

							// Show colorbox so the sizes can be calculated in older versions of jQuery
							$box.css({ visibility: 'hidden', display: 'block', opacity: '' });

							$loaded = $tag(div, 'LoadedContent', 'width:0; height:0; overflow:hidden; visibility:hidden');
							$content.css({ width: '', height: '' }).append($loaded);

							// Cache values needed for size calculations
							interfaceHeight = $topBorder.height() + $bottomBorder.height() + $content.outerHeight(true) - $content.height();
							interfaceWidth = $leftBorder.width() + $rightBorder.width() + $content.outerWidth(true) - $content.width();
							loadedHeight = $loaded.outerHeight(true);
							loadedWidth = $loaded.outerWidth(true);

							// Opens inital empty Colorbox prior to content being loaded.
							var initialWidth = setSize(settings.get('initialWidth'), 'x');
							var initialHeight = setSize(settings.get('initialHeight'), 'y');
							var maxWidth = settings.get('maxWidth');
							var maxHeight = settings.get('maxHeight');

							settings.w = Math.max((maxWidth !== false ? Math.min(initialWidth, setSize(maxWidth, 'x')) : initialWidth) - loadedWidth - interfaceWidth, 0);
							settings.h = Math.max((maxHeight !== false ? Math.min(initialHeight, setSize(maxHeight, 'y')) : initialHeight) - loadedHeight - interfaceHeight, 0);

							$loaded.css({ width: '', height: settings.h });
							publicMethod.position();

							trigger(event_open);
							settings.get('onOpen');

							$groupControls.add($title).hide();

							$box.focus();

							if (settings.get('trapFocus')) {
								// Confine focus to the modal
								// Uses event capturing that is not supported in IE8-
								if (document.addEventListener) {

									document.addEventListener('focus', trapFocus, true);

									$events.one(event_closed, function () {
										document.removeEventListener('focus', trapFocus, true);
									});
								}
							}

							// Return focus on closing
							if (settings.get('returnFocus')) {
								$events.one(event_closed, function () {
									$(settings.el).focus();
								});
							}
						}

						var opacity = parseFloat(settings.get('opacity'));
						$overlay.css({
							opacity: opacity === opacity ? opacity : '',
							cursor: settings.get('overlayClose') ? 'pointer' : '',
							visibility: 'visible'
						}).show();

						if (settings.get('closeButton')) {
							$close.html(settings.get('close')).appendTo($content);
						} else {
							$close.appendTo('<div/>'); // replace with .detach() when dropping jQuery < 1.4
						}

						load();
					}
				}

				// Colorbox's markup needs to be added to the DOM prior to being called
				// so that the browser will go ahead and load the CSS background images.
				function appendHTML() {
					if (!$box) {
						init = false;
						$window = $(window);
						$box = $tag(div).attr({
							id: colorbox,
							'class': $.support.opacity === false ? prefix + 'IE' : '', // class for optional IE8 & lower targeted CSS.
							role: 'dialog',
							tabindex: '-1'
						}).hide();
						$overlay = $tag(div, "Overlay").hide();
						$loadingOverlay = $([$tag(div, "LoadingOverlay")[0], $tag(div, "LoadingGraphic")[0]]);
						$wrap = $tag(div, "Wrapper");
						$content = $tag(div, "Content").append(
							$title = $tag(div, "Title"),
							$current = $tag(div, "Current"),
							$prev = $('<button type="button"/>').attr({ id: prefix + 'Previous' }),
							$next = $('<button type="button"/>').attr({ id: prefix + 'Next' }),
							$slideshow = $('<button type="button"/>').attr({ id: prefix + 'Slideshow' }),
							$loadingOverlay
						);

						$close = $('<button type="button"/>').attr({ id: prefix + 'Close' });

						$wrap.append( // The 3x3 Grid that makes up Colorbox
							$tag(div).append(
								$tag(div, "TopLeft"),
								$topBorder = $tag(div, "TopCenter"),
								$tag(div, "TopRight")
							),
							$tag(div, false, 'clear:left').append(
								$leftBorder = $tag(div, "MiddleLeft"),
								$content,
								$rightBorder = $tag(div, "MiddleRight")
							),
							$tag(div, false, 'clear:left').append(
								$tag(div, "BottomLeft"),
								$bottomBorder = $tag(div, "BottomCenter"),
								$tag(div, "BottomRight")
							)
						).find('div div').css({ 'float': 'left' });

						$loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;');

						$groupControls = $next.add($prev).add($current).add($slideshow);
					}
					if (document.body && !$box.parent().length) {
						$(document.body).append($overlay, $box.append($wrap, $loadingBay));
					}
				}

				// Add Colorbox's event bindings
				function addBindings() {
					function clickHandler(e) {
						// ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
						// See: http://jacklmoore.com/notes/click-events/
						if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
							e.preventDefault();
							launch(this);
						}
					}

					if ($box) {
						if (!init) {
							init = true;

							// Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.
							$next.click(function () {
								publicMethod.next();
							});
							$prev.click(function () {
								publicMethod.prev();
							});
							$close.click(function () {
								publicMethod.close();
							});
							$overlay.click(function () {
								if (settings.get('overlayClose')) {
									publicMethod.close();
								}
							});

							// Key Bindings
							$(document).bind('keydown.' + prefix, function (e) {
								var key = e.keyCode;
								if (open && settings.get('escKey') && key === 27) {
									e.preventDefault();
									publicMethod.close();
								}
								if (open && settings.get('arrowKey') && $related[1] && !e.altKey) {
									if (key === 37) {
										e.preventDefault();
										$prev.click();
									} else if (key === 39) {
										e.preventDefault();
										$next.click();
									}
								}
							});

							if ($.isFunction($.fn.on)) {
								// For jQuery 1.7+
								$(document).on('click.' + prefix, '.' + boxElement, clickHandler);
							} else {
								// For jQuery 1.3.x -> 1.6.x
								// This code is never reached in jQuery 1.9, so do not contact me about 'live' being removed.
								// This is not here for jQuery 1.9, it's here for legacy users.
								$('.' + boxElement).live('click.' + prefix, clickHandler);
							}
						}
						return true;
					}
					return false;
				}

				// Don't do anything if Colorbox already exists.
				if ($[colorbox]) {
					return;
				}

				// Append the HTML when the DOM loads
				$(appendHTML);


				// ****************
				// PUBLIC FUNCTIONS
				// Usage format: $.colorbox.close();
				// Usage from within an iframe: parent.jQuery.colorbox.close();
				// ****************

				publicMethod = $.fn[colorbox] = $[colorbox] = function (options, callback) {
					var settings;
					var $obj = this;

					options = options || {};

					if ($.isFunction($obj)) { // assume a call to $.colorbox
						$obj = $('<a/>');
						options.open = true;
					}

					if (!$obj[0]) { // colorbox being applied to empty collection
						return $obj;
					}

					appendHTML();

					if (addBindings()) {

						if (callback) {
							options.onComplete = callback;
						}

						$obj.each(function () {
							var old = $.data(this, colorbox) || {};
							$.data(this, colorbox, $.extend(old, options));
						}).addClass(boxElement);

						settings = new Settings($obj[0], options);

						if (settings.get('open')) {
							launch($obj[0]);
						}
					}

					return $obj;
				};

				publicMethod.position = function (speed, loadedCallback) {
					var
						css,
						top = 0,
						left = 0,
						offset = $box.offset(),
						scrollTop,
						scrollLeft;

					$window.unbind('resize.' + prefix);

					// remove the modal so that it doesn't influence the document width/height
					$box.css({ top: -9e4, left: -9e4 });

					scrollTop = $window.scrollTop();
					scrollLeft = $window.scrollLeft();

					if (settings.get('fixed')) {
						offset.top -= scrollTop;
						offset.left -= scrollLeft;
						$box.css({ position: 'fixed' });
					} else {
						top = scrollTop;
						left = scrollLeft;
						$box.css({ position: 'absolute' });
					}

					// keeps the top and left positions within the browser's viewport.
					if (settings.get('right') !== false) {
						left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.get('right'), 'x'), 0);
					} else if (settings.get('left') !== false) {
						left += setSize(settings.get('left'), 'x');
					} else {
						left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);
					}

					if (settings.get('bottom') !== false) {
						top += Math.max(winheight() - settings.h - loadedHeight - interfaceHeight - setSize(settings.get('bottom'), 'y'), 0);
					} else if (settings.get('top') !== false) {
						top += setSize(settings.get('top'), 'y');
					} else {
						top += Math.round(Math.max(winheight() - settings.h - loadedHeight - interfaceHeight, 0) / 2);
					}

					$box.css({ top: offset.top, left: offset.left, visibility: 'visible' });

					// this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,
					// but it has to be shrank down around the size of div#colorbox when it's done.  If not,
					// it can invoke an obscure IE bug when using iframes.
					$wrap[0].style.width = $wrap[0].style.height = "9999px";

					function modalDimensions() {
						$topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = (parseInt($box[0].style.width, 10) - interfaceWidth) + 'px';
						$content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = (parseInt($box[0].style.height, 10) - interfaceHeight) + 'px';
					}

					css = { width: settings.w + loadedWidth + interfaceWidth, height: settings.h + loadedHeight + interfaceHeight, top: top, left: left };

					// setting the speed to 0 if the content hasn't changed size or position
					if (speed) {
						var tempSpeed = 0;
						$.each(css, function (i) {
							if (css[i] !== previousCSS[i]) {
								tempSpeed = speed;
								return;
							}
						});
						speed = tempSpeed;
					}

					previousCSS = css;

					if (!speed) {
						$box.css(css);
					}

					$box.dequeue().animate(css, {
						duration: speed || 0,
						complete: function () {
							modalDimensions();

							active = false;

							// shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.
							$wrap[0].style.width = (settings.w + loadedWidth + interfaceWidth) + "px";
							$wrap[0].style.height = (settings.h + loadedHeight + interfaceHeight) + "px";

							if (settings.get('reposition')) {
								setTimeout(function () {  // small delay before binding onresize due to an IE8 bug.
									$window.bind('resize.' + prefix, publicMethod.position);
								}, 1);
							}

							if ($.isFunction(loadedCallback)) {
								loadedCallback();
							}
						},
						step: modalDimensions
					});
				};

				publicMethod.resize = function (options) {
					var scrolltop;

					if (open) {
						options = options || {};

						if (options.width) {
							settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;
						}

						if (options.innerWidth) {
							settings.w = setSize(options.innerWidth, 'x');
						}

						$loaded.css({ width: settings.w });

						if (options.height) {
							settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;
						}

						if (options.innerHeight) {
							settings.h = setSize(options.innerHeight, 'y');
						}

						if (!options.innerHeight && !options.height) {
							scrolltop = $loaded.scrollTop();
							$loaded.css({ height: "auto" });
							settings.h = $loaded.height();
						}

						$loaded.css({ height: settings.h });

						if (scrolltop) {
							$loaded.scrollTop(scrolltop);
						}

						publicMethod.position(settings.get('transition') === "none" ? 0 : settings.get('speed'));
					}
				};

				publicMethod.prep = function (object) {
					if (!open) {
						return;
					}

					var callback, speed = settings.get('transition') === "none" ? 0 : settings.get('speed');

					$loaded.remove();

					$loaded = $tag(div, 'LoadedContent').append(object);

					function getWidth() {
						settings.w = settings.w || $loaded.width();
						settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;
						return settings.w;
					}
					function getHeight() {
						settings.h = settings.h || $loaded.height();
						settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;
						return settings.h;
					}

					$loaded.hide()
						.appendTo($loadingBay.show())// content has to be appended to the DOM for accurate size calculations.
						.css({ width: getWidth(), overflow: settings.get('scrolling') ? 'auto' : 'hidden' })
						.css({ height: getHeight() })// sets the height independently from the width in case the new width influences the value of height.
						.prependTo($content);

					$loadingBay.hide();

					// floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.

					$(photo).css({ 'float': 'none' });

					setClass(settings.get('className'));

					callback = function () {
						var total = $related.length,
							iframe,
							complete;

						if (!open) {
							return;
						}

						function removeFilter() { // Needed for IE8 in versions of jQuery prior to 1.7.2
							if ($.support.opacity === false) {
								$box[0].style.removeAttribute('filter');
							}
						}

						complete = function () {
							clearTimeout(loadingTimer);
							$loadingOverlay.hide();
							trigger(event_complete);
							settings.get('onComplete');
						};


						$title.html(settings.get('title')).show();
						$loaded.show();

						if (total > 1) { // handle grouping
							if (typeof settings.get('current') === "string") {
								$current.html(settings.get('current').replace('{current}', index + 1).replace('{total}', total)).show();
							}

							$next[(settings.get('loop') || index < total - 1) ? "show" : "hide"]().html(settings.get('next'));
							$prev[(settings.get('loop') || index) ? "show" : "hide"]().html(settings.get('previous'));

							slideshow();

							// Preloads images within a rel group
							if (settings.get('preloading')) {
								$.each([getIndex(-1), getIndex(1)], function () {
									var img,
										i = $related[this],
										settings = new Settings(i, $.data(i, colorbox)),
										src = settings.get('href');

									if (src && isImage(settings, src)) {
										src = retinaUrl(settings, src);
										img = document.createElement('img');
										img.src = src;
									}
								});
							}
						} else {
							$groupControls.hide();
						}

						if (settings.get('iframe')) {

							iframe = settings.get('createIframe');

							if (!settings.get('scrolling')) {
								iframe.scrolling = "no";
							}

							$(iframe)
								.attr({
									src: settings.get('href'),
									'class': prefix + 'Iframe'
								})
								.one('load', complete)
								.appendTo($loaded);

							$events.one(event_purge, function () {
								iframe.src = "//about:blank";
							});

							if (settings.get('fastIframe')) {
								$(iframe).trigger('load');
							}
						} else {
							complete();
						}

						if (settings.get('transition') === 'fade') {
							$box.fadeTo(speed, 1, removeFilter);
						} else {
							removeFilter();
						}
					};

					if (settings.get('transition') === 'fade') {
						$box.fadeTo(speed, 0, function () {
							publicMethod.position(0, callback);
						});
					} else {
						publicMethod.position(speed, callback);
					}
				};

				function load() {
					var href, setResize, prep = publicMethod.prep, $inline, request = ++requests;

					active = true;

					photo = false;

					trigger(event_purge);
					trigger(event_load);
					settings.get('onLoad');

					settings.h = settings.get('height') ?
						setSize(settings.get('height'), 'y') - loadedHeight - interfaceHeight :
						settings.get('innerHeight') && setSize(settings.get('innerHeight'), 'y');

					settings.w = settings.get('width') ?
						setSize(settings.get('width'), 'x') - loadedWidth - interfaceWidth :
						settings.get('innerWidth') && setSize(settings.get('innerWidth'), 'x');

					// Sets the minimum dimensions for use in image scaling
					settings.mw = settings.w;
					settings.mh = settings.h;

					// Re-evaluate the minimum width and height based on maxWidth and maxHeight values.
					// If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.
					if (settings.get('maxWidth')) {
						settings.mw = setSize(settings.get('maxWidth'), 'x') - loadedWidth - interfaceWidth;
						settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;
					}
					if (settings.get('maxHeight')) {
						settings.mh = setSize(settings.get('maxHeight'), 'y') - loadedHeight - interfaceHeight;
						settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;
					}

					href = settings.get('href');

					loadingTimer = setTimeout(function () {
						$loadingOverlay.show();
					}, 100);

					if (settings.get('inline')) {
						var $target = $(href).eq(0);
						// Inserts an empty placeholder where inline content is being pulled from.
						// An event is bound to put inline content back when Colorbox closes or loads new content.
						$inline = $('<div>').hide().insertBefore($target);

						$events.one(event_purge, function () {
							$inline.replaceWith($target);
						});

						prep($target);
					} else if (settings.get('iframe')) {
						// IFrame element won't be added to the DOM until it is ready to be displayed,
						// to avoid problems with DOM-ready JS that might be trying to run in that iframe.
						prep(" ");
					} else if (settings.get('html')) {
						prep(settings.get('html'));
					} else if (isImage(settings, href)) {

						href = retinaUrl(settings, href);

						photo = settings.get('createImg');

						$(photo)
							.addClass(prefix + 'Photo')
							.bind('error.' + prefix, function () {
								prep($tag(div, 'Error').html(settings.get('imgError')));
							})
							.one('load', function () {
								if (request !== requests) {
									return;
								}

								// A small pause because some browsers will occassionaly report a
								// img.width and img.height of zero immediately after the img.onload fires
								setTimeout(function () {
									var percent;

									if (settings.get('retinaImage') && window.devicePixelRatio > 1) {
										photo.height = photo.height / window.devicePixelRatio;
										photo.width = photo.width / window.devicePixelRatio;
									}

									if (settings.get('scalePhotos')) {
										setResize = function () {
											photo.height -= photo.height * percent;
											photo.width -= photo.width * percent;
										};
										if (settings.mw && photo.width > settings.mw) {
											percent = (photo.width - settings.mw) / photo.width;
											setResize();
										}
										if (settings.mh && photo.height > settings.mh) {
											percent = (photo.height - settings.mh) / photo.height;
											setResize();
										}
									}

									if (settings.h) {
										photo.style.marginTop = Math.max(settings.mh - photo.height, 0) / 2 + 'px';
									}

									if ($related[1] && (settings.get('loop') || $related[index + 1])) {
										photo.style.cursor = 'pointer';

										$(photo).bind('click.' + prefix, function () {
											publicMethod.next();
										});
									}

									photo.style.width = photo.width + 'px';
									photo.style.height = photo.height + 'px';
									prep(photo);
								}, 1);
							});

						photo.src = href;

					} else if (href) {
						$loadingBay.load(href, settings.get('data'), function (data, status) {
							if (request === requests) {
								prep(status === 'error' ? $tag(div, 'Error').html(settings.get('xhrError')) : $(this).contents());
							}
						});
					}
				}

				// Navigates to the next page/image in a set.
				publicMethod.next = function () {
					if (!active && $related[1] && (settings.get('loop') || $related[index + 1])) {
						index = getIndex(1);
						launch($related[index]);
					}
				};

				publicMethod.prev = function () {
					if (!active && $related[1] && (settings.get('loop') || index)) {
						index = getIndex(-1);
						launch($related[index]);
					}
				};

				// Note: to use this within an iframe use the following format: parent.jQuery.colorbox.close();
				publicMethod.close = function () {
					if (open && !closing) {

						closing = true;
						open = false;
						trigger(event_cleanup);
						settings.get('onCleanup');
						$window.unbind('.' + prefix);
						$overlay.fadeTo(settings.get('fadeOut') || 0, 0);

						$box.stop().fadeTo(settings.get('fadeOut') || 0, 0, function () {
							$box.hide();
							$overlay.hide();
							trigger(event_purge);
							$loaded.remove();

							setTimeout(function () {
								closing = false;
								trigger(event_closed);
								settings.get('onClosed');
							}, 1);
						});
					}
				};

				// Removes changes Colorbox made to the document, but does not remove the plugin.
				publicMethod.remove = function () {
					if (!$box) { return; }

					$box.stop();
					$[colorbox].close();
					$box.stop(false, true).remove();
					$overlay.remove();
					closing = false;
					$box = null;
					$('.' + boxElement)
						.removeData(colorbox)
						.removeClass(boxElement);

					$(document).unbind('click.' + prefix).unbind('keydown.' + prefix);
				};

				// A method for fetching the current element Colorbox is referencing.
				// returns a jQuery object.
				publicMethod.element = function () {
					return $(settings.el);
				};

				publicMethod.settings = defaults;

			}(jQuery, document, window));


			/***/
		}),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v1.12.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:17Z
 */

			(function (global, factory) {

				if (true && typeof module.exports === "object") {
					// For CommonJS and CommonJS-like environments where a proper `window`
					// is present, execute the factory and get jQuery.
					// For environments that do not have a `window` with a `document`
					// (such as Node.js), expose a factory as module.exports.
					// This accentuates the need for the creation of a real `window`.
					// e.g. var jQuery = require("jquery")(window);
					// See ticket #14549 for more info.
					module.exports = global.document ?
						factory(global, true) :
						function (w) {
							if (!w.document) {
								throw new Error("jQuery requires a window with a document");
							}
							return factory(w);
						};
				} else {
					factory(global);
				}

				// Pass this if window is not defined yet
			}(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

				// Support: Firefox 18+
				// Can't be in strict mode, several libs including ASP.NET trace
				// the stack via arguments.caller.callee and Firefox dies if
				// you try to trace through "use strict" call chains. (#13335)
				//"use strict";
				var deletedIds = [];

				var document = window.document;

				var slice = deletedIds.slice;

				var concat = deletedIds.concat;

				var push = deletedIds.push;

				var indexOf = deletedIds.indexOf;

				var class2type = {};

				var toString = class2type.toString;

				var hasOwn = class2type.hasOwnProperty;

				var support = {};



				var
					version = "1.12.4",

					// Define a local copy of jQuery
					jQuery = function (selector, context) {

						// The jQuery object is actually just the init constructor 'enhanced'
						// Need init if jQuery is called (just allow error to be thrown if not included)
						return new jQuery.fn.init(selector, context);
					},

					// Support: Android<4.1, IE<9
					// Make sure we trim BOM and NBSP
					rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

					// Matches dashed string for camelizing
					rmsPrefix = /^-ms-/,
					rdashAlpha = /-([\da-z])/gi,

					// Used by jQuery.camelCase as callback to replace()
					fcamelCase = function (all, letter) {
						return letter.toUpperCase();
					};

				jQuery.fn = jQuery.prototype = {

					// The current version of jQuery being used
					jquery: version,

					constructor: jQuery,

					// Start with an empty selector
					selector: "",

					// The default length of a jQuery object is 0
					length: 0,

					toArray: function () {
						return slice.call(this);
					},

					// Get the Nth element in the matched element set OR
					// Get the whole matched element set as a clean array
					get: function (num) {
						return num != null ?

							// Return just the one element from the set
							(num < 0 ? this[num + this.length] : this[num]) :

							// Return all the elements in a clean array
							slice.call(this);
					},

					// Take an array of elements and push it onto the stack
					// (returning the new matched element set)
					pushStack: function (elems) {

						// Build a new jQuery matched element set
						var ret = jQuery.merge(this.constructor(), elems);

						// Add the old object onto the stack (as a reference)
						ret.prevObject = this;
						ret.context = this.context;

						// Return the newly-formed element set
						return ret;
					},

					// Execute a callback for every element in the matched set.
					each: function (callback) {
						return jQuery.each(this, callback);
					},

					map: function (callback) {
						return this.pushStack(jQuery.map(this, function (elem, i) {
							return callback.call(elem, i, elem);
						}));
					},

					slice: function () {
						return this.pushStack(slice.apply(this, arguments));
					},

					first: function () {
						return this.eq(0);
					},

					last: function () {
						return this.eq(-1);
					},

					eq: function (i) {
						var len = this.length,
							j = +i + (i < 0 ? len : 0);
						return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
					},

					end: function () {
						return this.prevObject || this.constructor();
					},

					// For internal use only.
					// Behaves like an Array's method, not like a jQuery method.
					push: push,
					sort: deletedIds.sort,
					splice: deletedIds.splice
				};

				jQuery.extend = jQuery.fn.extend = function () {
					var src, copyIsArray, copy, name, options, clone,
						target = arguments[0] || {},
						i = 1,
						length = arguments.length,
						deep = false;

					// Handle a deep copy situation
					if (typeof target === "boolean") {
						deep = target;

						// skip the boolean and the target
						target = arguments[i] || {};
						i++;
					}

					// Handle case when target is a string or something (possible in deep copy)
					if (typeof target !== "object" && !jQuery.isFunction(target)) {
						target = {};
					}

					// extend jQuery itself if only one argument is passed
					if (i === length) {
						target = this;
						i--;
					}

					for (; i < length; i++) {

						// Only deal with non-null/undefined values
						if ((options = arguments[i]) != null) {

							// Extend the base object
							for (name in options) {
								src = target[name];
								copy = options[name];

								// Prevent never-ending loop
								if (target === copy) {
									continue;
								}

								// Recurse if we're merging plain objects or arrays
								if (deep && copy && (jQuery.isPlainObject(copy) ||
									(copyIsArray = jQuery.isArray(copy)))) {

									if (copyIsArray) {
										copyIsArray = false;
										clone = src && jQuery.isArray(src) ? src : [];

									} else {
										clone = src && jQuery.isPlainObject(src) ? src : {};
									}

									// Never move original objects, clone them
									target[name] = jQuery.extend(deep, clone, copy);

									// Don't bring in undefined values
								} else if (copy !== undefined) {
									target[name] = copy;
								}
							}
						}
					}

					// Return the modified object
					return target;
				};

				jQuery.extend({

					// Unique for each copy of jQuery on the page
					expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

					// Assume jQuery is ready without the ready module
					isReady: true,

					error: function (msg) {
						throw new Error(msg);
					},

					noop: function () { },

					// See test/unit/core.js for details concerning isFunction.
					// Since version 1.3, DOM methods and functions like alert
					// aren't supported. They return false on IE (#2968).
					isFunction: function (obj) {
						return jQuery.type(obj) === "function";
					},

					isArray: Array.isArray || function (obj) {
						return jQuery.type(obj) === "array";
					},

					isWindow: function (obj) {
						/* jshint eqeqeq: false */
						return obj != null && obj == obj.window;
					},

					isNumeric: function (obj) {

						// parseFloat NaNs numeric-cast false positives (null|true|false|"")
						// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
						// subtraction forces infinities to NaN
						// adding 1 corrects loss of precision from parseFloat (#15100)
						var realStringObj = obj && obj.toString();
						return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
					},

					isEmptyObject: function (obj) {
						var name;
						for (name in obj) {
							return false;
						}
						return true;
					},

					isPlainObject: function (obj) {
						var key;

						// Must be an Object.
						// Because of IE, we also have to check the presence of the constructor property.
						// Make sure that DOM nodes and window objects don't pass through, as well
						if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
							return false;
						}

						try {

							// Not own constructor property must be Object
							if (obj.constructor &&
								!hasOwn.call(obj, "constructor") &&
								!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
								return false;
							}
						} catch (e) {

							// IE8,9 Will throw exceptions on certain host objects #9897
							return false;
						}

						// Support: IE<9
						// Handle iteration over inherited properties before own properties.
						if (!support.ownFirst) {
							for (key in obj) {
								return hasOwn.call(obj, key);
							}
						}

						// Own properties are enumerated firstly, so to speed up,
						// if last one is own, then all properties are own.
						for (key in obj) { }

						return key === undefined || hasOwn.call(obj, key);
					},

					type: function (obj) {
						if (obj == null) {
							return obj + "";
						}
						return typeof obj === "object" || typeof obj === "function" ?
							class2type[toString.call(obj)] || "object" :
							typeof obj;
					},

					// Workarounds based on findings by Jim Driscoll
					// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
					globalEval: function (data) {
						if (data && jQuery.trim(data)) {

							// We use execScript on Internet Explorer
							// We use an anonymous function so that context is window
							// rather than jQuery in Firefox
							(window.execScript || function (data) {
								window["eval"].call(window, data); // jscs:ignore requireDotNotation
							})(data);
						}
					},

					// Convert dashed to camelCase; used by the css and data modules
					// Microsoft forgot to hump their vendor prefix (#9572)
					camelCase: function (string) {
						return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
					},

					nodeName: function (elem, name) {
						return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
					},

					each: function (obj, callback) {
						var length, i = 0;

						if (isArrayLike(obj)) {
							length = obj.length;
							for (; i < length; i++) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						} else {
							for (i in obj) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						}

						return obj;
					},

					// Support: Android<4.1, IE<9
					trim: function (text) {
						return text == null ?
							"" :
							(text + "").replace(rtrim, "");
					},

					// results is for internal usage only
					makeArray: function (arr, results) {
						var ret = results || [];

						if (arr != null) {
							if (isArrayLike(Object(arr))) {
								jQuery.merge(ret,
									typeof arr === "string" ?
										[arr] : arr
								);
							} else {
								push.call(ret, arr);
							}
						}

						return ret;
					},

					inArray: function (elem, arr, i) {
						var len;

						if (arr) {
							if (indexOf) {
								return indexOf.call(arr, elem, i);
							}

							len = arr.length;
							i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

							for (; i < len; i++) {

								// Skip accessing in sparse arrays
								if (i in arr && arr[i] === elem) {
									return i;
								}
							}
						}

						return -1;
					},

					merge: function (first, second) {
						var len = +second.length,
							j = 0,
							i = first.length;

						while (j < len) {
							first[i++] = second[j++];
						}

						// Support: IE<9
						// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
						if (len !== len) {
							while (second[j] !== undefined) {
								first[i++] = second[j++];
							}
						}

						first.length = i;

						return first;
					},

					grep: function (elems, callback, invert) {
						var callbackInverse,
							matches = [],
							i = 0,
							length = elems.length,
							callbackExpect = !invert;

						// Go through the array, only saving the items
						// that pass the validator function
						for (; i < length; i++) {
							callbackInverse = !callback(elems[i], i);
							if (callbackInverse !== callbackExpect) {
								matches.push(elems[i]);
							}
						}

						return matches;
					},

					// arg is for internal usage only
					map: function (elems, callback, arg) {
						var length, value,
							i = 0,
							ret = [];

						// Go through the array, translating each of the items to their new values
						if (isArrayLike(elems)) {
							length = elems.length;
							for (; i < length; i++) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret.push(value);
								}
							}

							// Go through every key on the object,
						} else {
							for (i in elems) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret.push(value);
								}
							}
						}

						// Flatten any nested arrays
						return concat.apply([], ret);
					},

					// A global GUID counter for objects
					guid: 1,

					// Bind a function to a context, optionally partially applying any
					// arguments.
					proxy: function (fn, context) {
						var args, proxy, tmp;

						if (typeof context === "string") {
							tmp = fn[context];
							context = fn;
							fn = tmp;
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if (!jQuery.isFunction(fn)) {
							return undefined;
						}

						// Simulated bind
						args = slice.call(arguments, 2);
						proxy = function () {
							return fn.apply(context || this, args.concat(slice.call(arguments)));
						};

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++;

						return proxy;
					},

					now: function () {
						return +(new Date());
					},

					// jQuery.support is not used in Core but other projects attach their
					// properties to it so it needs to exist.
					support: support
				});

				// JSHint would error on this code due to the Symbol not being defined in ES5.
				// Defining this global in .jshintrc would create a danger of using the global
				// unguarded in another place, it seems safer to just disable JSHint for these
				// three lines.
				/* jshint ignore: start */
				if (typeof Symbol === "function") {
					jQuery.fn[Symbol.iterator] = deletedIds[Symbol.iterator];
				}
				/* jshint ignore: end */

				// Populate the class2type map
				jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
					function (i, name) {
						class2type["[object " + name + "]"] = name.toLowerCase();
					});

				function isArrayLike(obj) {

					// Support: iOS 8.2 (not reproducible in simulator)
					// `in` check used to prevent JIT error (gh-2145)
					// hasOwn isn't used here due to false negatives
					// regarding Nodelist length in IE
					var length = !!obj && "length" in obj && obj.length,
						type = jQuery.type(obj);

					if (type === "function" || jQuery.isWindow(obj)) {
						return false;
					}

					return type === "array" || length === 0 ||
						typeof length === "number" && length > 0 && (length - 1) in obj;
				}
				var Sizzle =
					/*!
					 * Sizzle CSS Selector Engine v2.2.1
					 * http://sizzlejs.com/
					 *
					 * Copyright jQuery Foundation and other contributors
					 * Released under the MIT license
					 * http://jquery.org/license
					 *
					 * Date: 2015-10-17
					 */
					(function (window) {

						var i,
							support,
							Expr,
							getText,
							isXML,
							tokenize,
							compile,
							select,
							outermostContext,
							sortInput,
							hasDuplicate,

							// Local document vars
							setDocument,
							document,
							docElem,
							documentIsHTML,
							rbuggyQSA,
							rbuggyMatches,
							matches,
							contains,

							// Instance-specific data
							expando = "sizzle" + 1 * new Date(),
							preferredDoc = window.document,
							dirruns = 0,
							done = 0,
							classCache = createCache(),
							tokenCache = createCache(),
							compilerCache = createCache(),
							sortOrder = function (a, b) {
								if (a === b) {
									hasDuplicate = true;
								}
								return 0;
							},

							// General-purpose constants
							MAX_NEGATIVE = 1 << 31,

							// Instance methods
							hasOwn = ({}).hasOwnProperty,
							arr = [],
							pop = arr.pop,
							push_native = arr.push,
							push = arr.push,
							slice = arr.slice,
							// Use a stripped-down indexOf as it's faster than native
							// http://jsperf.com/thor-indexof-vs-for/5
							indexOf = function (list, elem) {
								var i = 0,
									len = list.length;
								for (; i < len; i++) {
									if (list[i] === elem) {
										return i;
									}
								}
								return -1;
							},

							booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

							// Regular expressions

							// http://www.w3.org/TR/css3-selectors/#whitespace
							whitespace = "[\\x20\\t\\r\\n\\f]",

							// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
							identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

							// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
							attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
								// Operator (capture 2)
								"*([*^$|!~]?=)" + whitespace +
								// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
								"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
								"*\\]",

							pseudos = ":(" + identifier + ")(?:\\((" +
								// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
								// 1. quoted (capture 3; capture 4 or capture 5)
								"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
								// 2. simple (capture 6)
								"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
								// 3. anything else (capture 2)
								".*" +
								")\\)|)",

							// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
							rwhitespace = new RegExp(whitespace + "+", "g"),
							rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

							rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
							rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

							rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

							rpseudo = new RegExp(pseudos),
							ridentifier = new RegExp("^" + identifier + "$"),

							matchExpr = {
								"ID": new RegExp("^#(" + identifier + ")"),
								"CLASS": new RegExp("^\\.(" + identifier + ")"),
								"TAG": new RegExp("^(" + identifier + "|[*])"),
								"ATTR": new RegExp("^" + attributes),
								"PSEUDO": new RegExp("^" + pseudos),
								"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
									"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
									"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
								"bool": new RegExp("^(?:" + booleans + ")$", "i"),
								// For use in libraries implementing .is()
								// We use this for POS matching in `select`
								"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
									whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
							},

							rinputs = /^(?:input|select|textarea|button)$/i,
							rheader = /^h\d$/i,

							rnative = /^[^{]+\{\s*\[native \w/,

							// Easily-parseable/retrievable ID or TAG or CLASS selectors
							rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

							rsibling = /[+~]/,
							rescape = /'|\\/g,

							// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
							runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
							funescape = function (_, escaped, escapedWhitespace) {
								var high = "0x" + escaped - 0x10000;
								// NaN means non-codepoint
								// Support: Firefox<24
								// Workaround erroneous numeric interpretation of +"0x"
								return high !== high || escapedWhitespace ?
									escaped :
									high < 0 ?
										// BMP codepoint
										String.fromCharCode(high + 0x10000) :
										// Supplemental Plane codepoint (surrogate pair)
										String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
							},

							// Used for iframes
							// See setDocument()
							// Removing the function wrapper causes a "Permission Denied"
							// error in IE
							unloadHandler = function () {
								setDocument();
							};

						// Optimize for push.apply( _, NodeList )
						try {
							push.apply(
								(arr = slice.call(preferredDoc.childNodes)),
								preferredDoc.childNodes
							);
							// Support: Android<4.0
							// Detect silently failing push.apply
							arr[preferredDoc.childNodes.length].nodeType;
						} catch (e) {
							push = {
								apply: arr.length ?

									// Leverage slice if possible
									function (target, els) {
										push_native.apply(target, slice.call(els));
									} :

									// Support: IE<9
									// Otherwise append directly
									function (target, els) {
										var j = target.length,
											i = 0;
										// Can't trust NodeList.length
										while ((target[j++] = els[i++])) { }
										target.length = j - 1;
									}
							};
						}

						function Sizzle(selector, context, results, seed) {
							var m, i, elem, nid, nidselect, match, groups, newSelector,
								newContext = context && context.ownerDocument,

								// nodeType defaults to 9, since context defaults to document
								nodeType = context ? context.nodeType : 9;

							results = results || [];

							// Return early from calls with invalid selector or context
							if (typeof selector !== "string" || !selector ||
								nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

								return results;
							}

							// Try to shortcut find operations (as opposed to filters) in HTML documents
							if (!seed) {

								if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
									setDocument(context);
								}
								context = context || document;

								if (documentIsHTML) {

									// If the selector is sufficiently simple, try using a "get*By*" DOM method
									// (excepting DocumentFragment context, where the methods don't exist)
									if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

										// ID selector
										if ((m = match[1])) {

											// Document context
											if (nodeType === 9) {
												if ((elem = context.getElementById(m))) {

													// Support: IE, Opera, Webkit
													// TODO: identify versions
													// getElementById can match elements by name instead of ID
													if (elem.id === m) {
														results.push(elem);
														return results;
													}
												} else {
													return results;
												}

												// Element context
											} else {

												// Support: IE, Opera, Webkit
												// TODO: identify versions
												// getElementById can match elements by name instead of ID
												if (newContext && (elem = newContext.getElementById(m)) &&
													contains(context, elem) &&
													elem.id === m) {

													results.push(elem);
													return results;
												}
											}

											// Type selector
										} else if (match[2]) {
											push.apply(results, context.getElementsByTagName(selector));
											return results;

											// Class selector
										} else if ((m = match[3]) && support.getElementsByClassName &&
											context.getElementsByClassName) {

											push.apply(results, context.getElementsByClassName(m));
											return results;
										}
									}

									// Take advantage of querySelectorAll
									if (support.qsa &&
										!compilerCache[selector + " "] &&
										(!rbuggyQSA || !rbuggyQSA.test(selector))) {

										if (nodeType !== 1) {
											newContext = context;
											newSelector = selector;

											// qSA looks outside Element context, which is not what we want
											// Thanks to Andrew Dupont for this workaround technique
											// Support: IE <=8
											// Exclude object elements
										} else if (context.nodeName.toLowerCase() !== "object") {

											// Capture the context ID, setting it first if necessary
											if ((nid = context.getAttribute("id"))) {
												nid = nid.replace(rescape, "\\$&");
											} else {
												context.setAttribute("id", (nid = expando));
											}

											// Prefix every selector in the list
											groups = tokenize(selector);
											i = groups.length;
											nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
											while (i--) {
												groups[i] = nidselect + " " + toSelector(groups[i]);
											}
											newSelector = groups.join(",");

											// Expand context for sibling selectors
											newContext = rsibling.test(selector) && testContext(context.parentNode) ||
												context;
										}

										if (newSelector) {
											try {
												push.apply(results,
													newContext.querySelectorAll(newSelector)
												);
												return results;
											} catch (qsaError) {
											} finally {
												if (nid === expando) {
													context.removeAttribute("id");
												}
											}
										}
									}
								}
							}

							// All others
							return select(selector.replace(rtrim, "$1"), context, results, seed);
						}

						/**
						 * Create key-value caches of limited size
						 * @returns {function(string, object)} Returns the Object data after storing it on itself with
						 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
						 *	deleting the oldest entry
						 */
						function createCache() {
							var keys = [];

							function cache(key, value) {
								// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
								if (keys.push(key + " ") > Expr.cacheLength) {
									// Only keep the most recent entries
									delete cache[keys.shift()];
								}
								return (cache[key + " "] = value);
							}
							return cache;
						}

						/**
						 * Mark a function for special use by Sizzle
						 * @param {Function} fn The function to mark
						 */
						function markFunction(fn) {
							fn[expando] = true;
							return fn;
						}

						/**
						 * Support testing using an element
						 * @param {Function} fn Passed the created div and expects a boolean result
						 */
						function assert(fn) {
							var div = document.createElement("div");

							try {
								return !!fn(div);
							} catch (e) {
								return false;
							} finally {
								// Remove from its parent by default
								if (div.parentNode) {
									div.parentNode.removeChild(div);
								}
								// release memory in IE
								div = null;
							}
						}

						/**
						 * Adds the same handler for all of the specified attrs
						 * @param {String} attrs Pipe-separated list of attributes
						 * @param {Function} handler The method that will be applied
						 */
						function addHandle(attrs, handler) {
							var arr = attrs.split("|"),
								i = arr.length;

							while (i--) {
								Expr.attrHandle[arr[i]] = handler;
							}
						}

						/**
						 * Checks document order of two siblings
						 * @param {Element} a
						 * @param {Element} b
						 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
						 */
						function siblingCheck(a, b) {
							var cur = b && a,
								diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
									(~b.sourceIndex || MAX_NEGATIVE) -
									(~a.sourceIndex || MAX_NEGATIVE);

							// Use IE sourceIndex if available on both nodes
							if (diff) {
								return diff;
							}

							// Check if b follows a
							if (cur) {
								while ((cur = cur.nextSibling)) {
									if (cur === b) {
										return -1;
									}
								}
							}

							return a ? 1 : -1;
						}

						/**
						 * Returns a function to use in pseudos for input types
						 * @param {String} type
						 */
						function createInputPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && elem.type === type;
							};
						}

						/**
						 * Returns a function to use in pseudos for buttons
						 * @param {String} type
						 */
						function createButtonPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return (name === "input" || name === "button") && elem.type === type;
							};
						}

						/**
						 * Returns a function to use in pseudos for positionals
						 * @param {Function} fn
						 */
						function createPositionalPseudo(fn) {
							return markFunction(function (argument) {
								argument = +argument;
								return markFunction(function (seed, matches) {
									var j,
										matchIndexes = fn([], seed.length, argument),
										i = matchIndexes.length;

									// Match elements found at the specified indexes
									while (i--) {
										if (seed[(j = matchIndexes[i])]) {
											seed[j] = !(matches[j] = seed[j]);
										}
									}
								});
							});
						}

						/**
						 * Checks a node for validity as a Sizzle context
						 * @param {Element|Object=} context
						 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
						 */
						function testContext(context) {
							return context && typeof context.getElementsByTagName !== "undefined" && context;
						}

						// Expose support vars for convenience
						support = Sizzle.support = {};

						/**
						 * Detects XML nodes
						 * @param {Element|Object} elem An element or a document
						 * @returns {Boolean} True iff elem is a non-HTML XML node
						 */
						isXML = Sizzle.isXML = function (elem) {
							// documentElement is verified for cases where it doesn't yet exist
							// (such as loading iframes in IE - #4833)
							var documentElement = elem && (elem.ownerDocument || elem).documentElement;
							return documentElement ? documentElement.nodeName !== "HTML" : false;
						};

						/**
						 * Sets document-related variables once based on the current document
						 * @param {Element|Object} [doc] An element or document object to use to set the document
						 * @returns {Object} Returns the current document
						 */
						setDocument = Sizzle.setDocument = function (node) {
							var hasCompare, parent,
								doc = node ? node.ownerDocument || node : preferredDoc;

							// Return early if doc is invalid or already selected
							if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
								return document;
							}

							// Update global variables
							document = doc;
							docElem = document.documentElement;
							documentIsHTML = !isXML(document);

							// Support: IE 9-11, Edge
							// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
							if ((parent = document.defaultView) && parent.top !== parent) {
								// Support: IE 11
								if (parent.addEventListener) {
									parent.addEventListener("unload", unloadHandler, false);

									// Support: IE 9 - 10 only
								} else if (parent.attachEvent) {
									parent.attachEvent("onunload", unloadHandler);
								}
							}

							/* Attributes
							---------------------------------------------------------------------- */

							// Support: IE<8
							// Verify that getAttribute really returns attributes and not properties
							// (excepting IE8 booleans)
							support.attributes = assert(function (div) {
								div.className = "i";
								return !div.getAttribute("className");
							});

							/* getElement(s)By*
							---------------------------------------------------------------------- */

							// Check if getElementsByTagName("*") returns only elements
							support.getElementsByTagName = assert(function (div) {
								div.appendChild(document.createComment(""));
								return !div.getElementsByTagName("*").length;
							});

							// Support: IE<9
							support.getElementsByClassName = rnative.test(document.getElementsByClassName);

							// Support: IE<10
							// Check if getElementById returns elements by name
							// The broken getElementById methods don't pick up programatically-set names,
							// so use a roundabout getElementsByName test
							support.getById = assert(function (div) {
								docElem.appendChild(div).id = expando;
								return !document.getElementsByName || !document.getElementsByName(expando).length;
							});

							// ID find and filter
							if (support.getById) {
								Expr.find["ID"] = function (id, context) {
									if (typeof context.getElementById !== "undefined" && documentIsHTML) {
										var m = context.getElementById(id);
										return m ? [m] : [];
									}
								};
								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										return elem.getAttribute("id") === attrId;
									};
								};
							} else {
								// Support: IE6/7
								// getElementById is not reliable as a find shortcut
								delete Expr.find["ID"];

								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										var node = typeof elem.getAttributeNode !== "undefined" &&
											elem.getAttributeNode("id");
										return node && node.value === attrId;
									};
								};
							}

							// Tag
							Expr.find["TAG"] = support.getElementsByTagName ?
								function (tag, context) {
									if (typeof context.getElementsByTagName !== "undefined") {
										return context.getElementsByTagName(tag);

										// DocumentFragment nodes don't have gEBTN
									} else if (support.qsa) {
										return context.querySelectorAll(tag);
									}
								} :

								function (tag, context) {
									var elem,
										tmp = [],
										i = 0,
										// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
										results = context.getElementsByTagName(tag);

									// Filter out possible comments
									if (tag === "*") {
										while ((elem = results[i++])) {
											if (elem.nodeType === 1) {
												tmp.push(elem);
											}
										}

										return tmp;
									}
									return results;
								};

							// Class
							Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
								if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
									return context.getElementsByClassName(className);
								}
							};

							/* QSA/matchesSelector
							---------------------------------------------------------------------- */

							// QSA and matchesSelector support

							// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
							rbuggyMatches = [];

							// qSa(:focus) reports false when true (Chrome 21)
							// We allow this because of a bug in IE8/9 that throws an error
							// whenever `document.activeElement` is accessed on an iframe
							// So, we allow :focus to pass through QSA all the time to avoid the IE error
							// See http://bugs.jquery.com/ticket/13378
							rbuggyQSA = [];

							if ((support.qsa = rnative.test(document.querySelectorAll))) {
								// Build QSA regex
								// Regex strategy adopted from Diego Perini
								assert(function (div) {
									// Select is set to empty string on purpose
									// This is to test IE's treatment of not explicitly
									// setting a boolean content attribute,
									// since its presence should be enough
									// http://bugs.jquery.com/ticket/12359
									docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
										"<select id='" + expando + "-\r\\' msallowcapture=''>" +
										"<option selected=''></option></select>";

									// Support: IE8, Opera 11-12.16
									// Nothing should be selected when empty strings follow ^= or $= or *=
									// The test attribute must be unknown in Opera but "safe" for WinRT
									// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
									if (div.querySelectorAll("[msallowcapture^='']").length) {
										rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
									}

									// Support: IE8
									// Boolean attributes and "value" are not treated correctly
									if (!div.querySelectorAll("[selected]").length) {
										rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
									}

									// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
									if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
										rbuggyQSA.push("~=");
									}

									// Webkit/Opera - :checked should return selected option elements
									// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
									// IE8 throws error here and will not see later tests
									if (!div.querySelectorAll(":checked").length) {
										rbuggyQSA.push(":checked");
									}

									// Support: Safari 8+, iOS 8+
									// https://bugs.webkit.org/show_bug.cgi?id=136851
									// In-page `selector#id sibing-combinator selector` fails
									if (!div.querySelectorAll("a#" + expando + "+*").length) {
										rbuggyQSA.push(".#.+[+~]");
									}
								});

								assert(function (div) {
									// Support: Windows 8 Native Apps
									// The type and name attributes are restricted during .innerHTML assignment
									var input = document.createElement("input");
									input.setAttribute("type", "hidden");
									div.appendChild(input).setAttribute("name", "D");

									// Support: IE8
									// Enforce case-sensitivity of name attribute
									if (div.querySelectorAll("[name=d]").length) {
										rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
									}

									// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
									// IE8 throws error here and will not see later tests
									if (!div.querySelectorAll(":enabled").length) {
										rbuggyQSA.push(":enabled", ":disabled");
									}

									// Opera 10-11 does not throw on post-comma invalid pseudos
									div.querySelectorAll("*,:x");
									rbuggyQSA.push(",.*:");
								});
							}

							if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
								docElem.webkitMatchesSelector ||
								docElem.mozMatchesSelector ||
								docElem.oMatchesSelector ||
								docElem.msMatchesSelector)))) {

								assert(function (div) {
									// Check to see if it's possible to do matchesSelector
									// on a disconnected node (IE 9)
									support.disconnectedMatch = matches.call(div, "div");

									// This should fail with an exception
									// Gecko does not error, returns false instead
									matches.call(div, "[s!='']:x");
									rbuggyMatches.push("!=", pseudos);
								});
							}

							rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
							rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

							/* Contains
							---------------------------------------------------------------------- */
							hasCompare = rnative.test(docElem.compareDocumentPosition);

							// Element contains another
							// Purposefully self-exclusive
							// As in, an element does not contain itself
							contains = hasCompare || rnative.test(docElem.contains) ?
								function (a, b) {
									var adown = a.nodeType === 9 ? a.documentElement : a,
										bup = b && b.parentNode;
									return a === bup || !!(bup && bup.nodeType === 1 && (
										adown.contains ?
											adown.contains(bup) :
											a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
									));
								} :
								function (a, b) {
									if (b) {
										while ((b = b.parentNode)) {
											if (b === a) {
												return true;
											}
										}
									}
									return false;
								};

							/* Sorting
							---------------------------------------------------------------------- */

							// Document order sorting
							sortOrder = hasCompare ?
								function (a, b) {

									// Flag for duplicate removal
									if (a === b) {
										hasDuplicate = true;
										return 0;
									}

									// Sort on method existence if only one input has compareDocumentPosition
									var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
									if (compare) {
										return compare;
									}

									// Calculate position if both inputs belong to the same document
									compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
										a.compareDocumentPosition(b) :

										// Otherwise we know they are disconnected
										1;

									// Disconnected nodes
									if (compare & 1 ||
										(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

										// Choose the first element that is related to our preferred document
										if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
											return -1;
										}
										if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
											return 1;
										}

										// Maintain original order
										return sortInput ?
											(indexOf(sortInput, a) - indexOf(sortInput, b)) :
											0;
									}

									return compare & 4 ? -1 : 1;
								} :
								function (a, b) {
									// Exit early if the nodes are identical
									if (a === b) {
										hasDuplicate = true;
										return 0;
									}

									var cur,
										i = 0,
										aup = a.parentNode,
										bup = b.parentNode,
										ap = [a],
										bp = [b];

									// Parentless nodes are either documents or disconnected
									if (!aup || !bup) {
										return a === document ? -1 :
											b === document ? 1 :
												aup ? -1 :
													bup ? 1 :
														sortInput ?
															(indexOf(sortInput, a) - indexOf(sortInput, b)) :
															0;

										// If the nodes are siblings, we can do a quick check
									} else if (aup === bup) {
										return siblingCheck(a, b);
									}

									// Otherwise we need full lists of their ancestors for comparison
									cur = a;
									while ((cur = cur.parentNode)) {
										ap.unshift(cur);
									}
									cur = b;
									while ((cur = cur.parentNode)) {
										bp.unshift(cur);
									}

									// Walk down the tree looking for a discrepancy
									while (ap[i] === bp[i]) {
										i++;
									}

									return i ?
										// Do a sibling check if the nodes have a common ancestor
										siblingCheck(ap[i], bp[i]) :

										// Otherwise nodes in our document sort first
										ap[i] === preferredDoc ? -1 :
											bp[i] === preferredDoc ? 1 :
												0;
								};

							return document;
						};

						Sizzle.matches = function (expr, elements) {
							return Sizzle(expr, null, null, elements);
						};

						Sizzle.matchesSelector = function (elem, expr) {
							// Set document vars if needed
							if ((elem.ownerDocument || elem) !== document) {
								setDocument(elem);
							}

							// Make sure that attribute selectors are quoted
							expr = expr.replace(rattributeQuotes, "='$1']");

							if (support.matchesSelector && documentIsHTML &&
								!compilerCache[expr + " "] &&
								(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
								(!rbuggyQSA || !rbuggyQSA.test(expr))) {

								try {
									var ret = matches.call(elem, expr);

									// IE 9's matchesSelector returns false on disconnected nodes
									if (ret || support.disconnectedMatch ||
										// As well, disconnected nodes are said to be in a document
										// fragment in IE 9
										elem.document && elem.document.nodeType !== 11) {
										return ret;
									}
								} catch (e) { }
							}

							return Sizzle(expr, document, null, [elem]).length > 0;
						};

						Sizzle.contains = function (context, elem) {
							// Set document vars if needed
							if ((context.ownerDocument || context) !== document) {
								setDocument(context);
							}
							return contains(context, elem);
						};

						Sizzle.attr = function (elem, name) {
							// Set document vars if needed
							if ((elem.ownerDocument || elem) !== document) {
								setDocument(elem);
							}

							var fn = Expr.attrHandle[name.toLowerCase()],
								// Don't get fooled by Object.prototype properties (jQuery #13807)
								val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
									fn(elem, name, !documentIsHTML) :
									undefined;

							return val !== undefined ?
								val :
								support.attributes || !documentIsHTML ?
									elem.getAttribute(name) :
									(val = elem.getAttributeNode(name)) && val.specified ?
										val.value :
										null;
						};

						Sizzle.error = function (msg) {
							throw new Error("Syntax error, unrecognized expression: " + msg);
						};

						/**
						 * Document sorting and removing duplicates
						 * @param {ArrayLike} results
						 */
						Sizzle.uniqueSort = function (results) {
							var elem,
								duplicates = [],
								j = 0,
								i = 0;

							// Unless we *know* we can detect duplicates, assume their presence
							hasDuplicate = !support.detectDuplicates;
							sortInput = !support.sortStable && results.slice(0);
							results.sort(sortOrder);

							if (hasDuplicate) {
								while ((elem = results[i++])) {
									if (elem === results[i]) {
										j = duplicates.push(i);
									}
								}
								while (j--) {
									results.splice(duplicates[j], 1);
								}
							}

							// Clear input after sorting to release objects
							// See https://github.com/jquery/sizzle/pull/225
							sortInput = null;

							return results;
						};

						/**
						 * Utility function for retrieving the text value of an array of DOM nodes
						 * @param {Array|Element} elem
						 */
						getText = Sizzle.getText = function (elem) {
							var node,
								ret = "",
								i = 0,
								nodeType = elem.nodeType;

							if (!nodeType) {
								// If no nodeType, this is expected to be an array
								while ((node = elem[i++])) {
									// Do not traverse comment nodes
									ret += getText(node);
								}
							} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
								// Use textContent for elements
								// innerText usage removed for consistency of new lines (jQuery #11153)
								if (typeof elem.textContent === "string") {
									return elem.textContent;
								} else {
									// Traverse its children
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										ret += getText(elem);
									}
								}
							} else if (nodeType === 3 || nodeType === 4) {
								return elem.nodeValue;
							}
							// Do not include comment or processing instruction nodes

							return ret;
						};

						Expr = Sizzle.selectors = {

							// Can be adjusted by the user
							cacheLength: 50,

							createPseudo: markFunction,

							match: matchExpr,

							attrHandle: {},

							find: {},

							relative: {
								">": { dir: "parentNode", first: true },
								" ": { dir: "parentNode" },
								"+": { dir: "previousSibling", first: true },
								"~": { dir: "previousSibling" }
							},

							preFilter: {
								"ATTR": function (match) {
									match[1] = match[1].replace(runescape, funescape);

									// Move the given value to match[3] whether quoted or unquoted
									match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

									if (match[2] === "~=") {
										match[3] = " " + match[3] + " ";
									}

									return match.slice(0, 4);
								},

								"CHILD": function (match) {
									/* matches from matchExpr["CHILD"]
										1 type (only|nth|...)
										2 what (child|of-type)
										3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
										4 xn-component of xn+y argument ([+-]?\d*n|)
										5 sign of xn-component
										6 x of xn-component
										7 sign of y-component
										8 y of y-component
									*/
									match[1] = match[1].toLowerCase();

									if (match[1].slice(0, 3) === "nth") {
										// nth-* requires argument
										if (!match[3]) {
											Sizzle.error(match[0]);
										}

										// numeric x and y parameters for Expr.filter.CHILD
										// remember that false/true cast respectively to 0/1
										match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
										match[5] = +((match[7] + match[8]) || match[3] === "odd");

										// other types prohibit arguments
									} else if (match[3]) {
										Sizzle.error(match[0]);
									}

									return match;
								},

								"PSEUDO": function (match) {
									var excess,
										unquoted = !match[6] && match[2];

									if (matchExpr["CHILD"].test(match[0])) {
										return null;
									}

									// Accept quoted arguments as-is
									if (match[3]) {
										match[2] = match[4] || match[5] || "";

										// Strip excess characters from unquoted arguments
									} else if (unquoted && rpseudo.test(unquoted) &&
										// Get excess from tokenize (recursively)
										(excess = tokenize(unquoted, true)) &&
										// advance to the next closing parenthesis
										(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

										// excess is a negative index
										match[0] = match[0].slice(0, excess);
										match[2] = unquoted.slice(0, excess);
									}

									// Return only captures needed by the pseudo filter method (type and argument)
									return match.slice(0, 3);
								}
							},

							filter: {

								"TAG": function (nodeNameSelector) {
									var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
									return nodeNameSelector === "*" ?
										function () { return true; } :
										function (elem) {
											return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
										};
								},

								"CLASS": function (className) {
									var pattern = classCache[className + " "];

									return pattern ||
										(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
										classCache(className, function (elem) {
											return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
										});
								},

								"ATTR": function (name, operator, check) {
									return function (elem) {
										var result = Sizzle.attr(elem, name);

										if (result == null) {
											return operator === "!=";
										}
										if (!operator) {
											return true;
										}

										result += "";

										return operator === "=" ? result === check :
											operator === "!=" ? result !== check :
												operator === "^=" ? check && result.indexOf(check) === 0 :
													operator === "*=" ? check && result.indexOf(check) > -1 :
														operator === "$=" ? check && result.slice(-check.length) === check :
															operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
																operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
																	false;
									};
								},

								"CHILD": function (type, what, argument, first, last) {
									var simple = type.slice(0, 3) !== "nth",
										forward = type.slice(-4) !== "last",
										ofType = what === "of-type";

									return first === 1 && last === 0 ?

										// Shortcut for :nth-*(n)
										function (elem) {
											return !!elem.parentNode;
										} :

										function (elem, context, xml) {
											var cache, uniqueCache, outerCache, node, nodeIndex, start,
												dir = simple !== forward ? "nextSibling" : "previousSibling",
												parent = elem.parentNode,
												name = ofType && elem.nodeName.toLowerCase(),
												useCache = !xml && !ofType,
												diff = false;

											if (parent) {

												// :(first|last|only)-(child|of-type)
												if (simple) {
													while (dir) {
														node = elem;
														while ((node = node[dir])) {
															if (ofType ?
																node.nodeName.toLowerCase() === name :
																node.nodeType === 1) {

																return false;
															}
														}
														// Reverse direction for :only-* (if we haven't yet done so)
														start = dir = type === "only" && !start && "nextSibling";
													}
													return true;
												}

												start = [forward ? parent.firstChild : parent.lastChild];

												// non-xml :nth-child(...) stores cache data on `parent`
												if (forward && useCache) {

													// Seek `elem` from a previously-cached index

													// ...in a gzip-friendly way
													node = parent;
													outerCache = node[expando] || (node[expando] = {});

													// Support: IE <9 only
													// Defend against cloned attroperties (jQuery gh-1709)
													uniqueCache = outerCache[node.uniqueID] ||
														(outerCache[node.uniqueID] = {});

													cache = uniqueCache[type] || [];
													nodeIndex = cache[0] === dirruns && cache[1];
													diff = nodeIndex && cache[2];
													node = nodeIndex && parent.childNodes[nodeIndex];

													while ((node = ++nodeIndex && node && node[dir] ||

														// Fallback to seeking `elem` from the start
														(diff = nodeIndex = 0) || start.pop())) {

														// When found, cache indexes on `parent` and break
														if (node.nodeType === 1 && ++diff && node === elem) {
															uniqueCache[type] = [dirruns, nodeIndex, diff];
															break;
														}
													}

												} else {
													// Use previously-cached element index if available
													if (useCache) {
														// ...in a gzip-friendly way
														node = elem;
														outerCache = node[expando] || (node[expando] = {});

														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache = outerCache[node.uniqueID] ||
															(outerCache[node.uniqueID] = {});

														cache = uniqueCache[type] || [];
														nodeIndex = cache[0] === dirruns && cache[1];
														diff = nodeIndex;
													}

													// xml :nth-child(...)
													// or :nth-last-child(...) or :nth(-last)?-of-type(...)
													if (diff === false) {
														// Use the same loop as above to seek `elem` from the start
														while ((node = ++nodeIndex && node && node[dir] ||
															(diff = nodeIndex = 0) || start.pop())) {

															if ((ofType ?
																node.nodeName.toLowerCase() === name :
																node.nodeType === 1) &&
																++diff) {

																// Cache the index of each encountered element
																if (useCache) {
																	outerCache = node[expando] || (node[expando] = {});

																	// Support: IE <9 only
																	// Defend against cloned attroperties (jQuery gh-1709)
																	uniqueCache = outerCache[node.uniqueID] ||
																		(outerCache[node.uniqueID] = {});

																	uniqueCache[type] = [dirruns, diff];
																}

																if (node === elem) {
																	break;
																}
															}
														}
													}
												}

												// Incorporate the offset, then check against cycle size
												diff -= last;
												return diff === first || (diff % first === 0 && diff / first >= 0);
											}
										};
								},

								"PSEUDO": function (pseudo, argument) {
									// pseudo-class names are case-insensitive
									// http://www.w3.org/TR/selectors/#pseudo-classes
									// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
									// Remember that setFilters inherits from pseudos
									var args,
										fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
											Sizzle.error("unsupported pseudo: " + pseudo);

									// The user may use createPseudo to indicate that
									// arguments are needed to create the filter function
									// just as Sizzle does
									if (fn[expando]) {
										return fn(argument);
									}

									// But maintain support for old signatures
									if (fn.length > 1) {
										args = [pseudo, pseudo, "", argument];
										return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
											markFunction(function (seed, matches) {
												var idx,
													matched = fn(seed, argument),
													i = matched.length;
												while (i--) {
													idx = indexOf(seed, matched[i]);
													seed[idx] = !(matches[idx] = matched[i]);
												}
											}) :
											function (elem) {
												return fn(elem, 0, args);
											};
									}

									return fn;
								}
							},

							pseudos: {
								// Potentially complex pseudos
								"not": markFunction(function (selector) {
									// Trim the selector passed to compile
									// to avoid treating leading and trailing
									// spaces as combinators
									var input = [],
										results = [],
										matcher = compile(selector.replace(rtrim, "$1"));

									return matcher[expando] ?
										markFunction(function (seed, matches, context, xml) {
											var elem,
												unmatched = matcher(seed, null, xml, []),
												i = seed.length;

											// Match elements unmatched by `matcher`
											while (i--) {
												if ((elem = unmatched[i])) {
													seed[i] = !(matches[i] = elem);
												}
											}
										}) :
										function (elem, context, xml) {
											input[0] = elem;
											matcher(input, null, xml, results);
											// Don't keep the element (issue #299)
											input[0] = null;
											return !results.pop();
										};
								}),

								"has": markFunction(function (selector) {
									return function (elem) {
										return Sizzle(selector, elem).length > 0;
									};
								}),

								"contains": markFunction(function (text) {
									text = text.replace(runescape, funescape);
									return function (elem) {
										return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
									};
								}),

								// "Whether an element is represented by a :lang() selector
								// is based solely on the element's language value
								// being equal to the identifier C,
								// or beginning with the identifier C immediately followed by "-".
								// The matching of C against the element's language value is performed case-insensitively.
								// The identifier C does not have to be a valid language name."
								// http://www.w3.org/TR/selectors/#lang-pseudo
								"lang": markFunction(function (lang) {
									// lang value must be a valid identifier
									if (!ridentifier.test(lang || "")) {
										Sizzle.error("unsupported lang: " + lang);
									}
									lang = lang.replace(runescape, funescape).toLowerCase();
									return function (elem) {
										var elemLang;
										do {
											if ((elemLang = documentIsHTML ?
												elem.lang :
												elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

												elemLang = elemLang.toLowerCase();
												return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
											}
										} while ((elem = elem.parentNode) && elem.nodeType === 1);
										return false;
									};
								}),

								// Miscellaneous
								"target": function (elem) {
									var hash = window.location && window.location.hash;
									return hash && hash.slice(1) === elem.id;
								},

								"root": function (elem) {
									return elem === docElem;
								},

								"focus": function (elem) {
									return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
								},

								// Boolean properties
								"enabled": function (elem) {
									return elem.disabled === false;
								},

								"disabled": function (elem) {
									return elem.disabled === true;
								},

								"checked": function (elem) {
									// In CSS3, :checked should return both checked and selected elements
									// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
									var nodeName = elem.nodeName.toLowerCase();
									return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
								},

								"selected": function (elem) {
									// Accessing this property makes selected-by-default
									// options in Safari work properly
									if (elem.parentNode) {
										elem.parentNode.selectedIndex;
									}

									return elem.selected === true;
								},

								// Contents
								"empty": function (elem) {
									// http://www.w3.org/TR/selectors/#empty-pseudo
									// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
									//   but not by others (comment: 8; processing instruction: 7; etc.)
									// nodeType < 6 works because attributes (2) do not appear as children
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										if (elem.nodeType < 6) {
											return false;
										}
									}
									return true;
								},

								"parent": function (elem) {
									return !Expr.pseudos["empty"](elem);
								},

								// Element/input types
								"header": function (elem) {
									return rheader.test(elem.nodeName);
								},

								"input": function (elem) {
									return rinputs.test(elem.nodeName);
								},

								"button": function (elem) {
									var name = elem.nodeName.toLowerCase();
									return name === "input" && elem.type === "button" || name === "button";
								},

								"text": function (elem) {
									var attr;
									return elem.nodeName.toLowerCase() === "input" &&
										elem.type === "text" &&

										// Support: IE<8
										// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
										((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
								},

								// Position-in-collection
								"first": createPositionalPseudo(function () {
									return [0];
								}),

								"last": createPositionalPseudo(function (matchIndexes, length) {
									return [length - 1];
								}),

								"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
									return [argument < 0 ? argument + length : argument];
								}),

								"even": createPositionalPseudo(function (matchIndexes, length) {
									var i = 0;
									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),

								"odd": createPositionalPseudo(function (matchIndexes, length) {
									var i = 1;
									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),

								"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument;
									for (; --i >= 0;) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),

								"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument;
									for (; ++i < length;) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								})
							}
						};

						Expr.pseudos["nth"] = Expr.pseudos["eq"];

						// Add button/input type pseudos
						for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
							Expr.pseudos[i] = createInputPseudo(i);
						}
						for (i in { submit: true, reset: true }) {
							Expr.pseudos[i] = createButtonPseudo(i);
						}

						// Easy API for creating new setFilters
						function setFilters() { }
						setFilters.prototype = Expr.filters = Expr.pseudos;
						Expr.setFilters = new setFilters();

						tokenize = Sizzle.tokenize = function (selector, parseOnly) {
							var matched, match, tokens, type,
								soFar, groups, preFilters,
								cached = tokenCache[selector + " "];

							if (cached) {
								return parseOnly ? 0 : cached.slice(0);
							}

							soFar = selector;
							groups = [];
							preFilters = Expr.preFilter;

							while (soFar) {

								// Comma and first run
								if (!matched || (match = rcomma.exec(soFar))) {
									if (match) {
										// Don't consume trailing commas as valid
										soFar = soFar.slice(match[0].length) || soFar;
									}
									groups.push((tokens = []));
								}

								matched = false;

								// Combinators
								if ((match = rcombinators.exec(soFar))) {
									matched = match.shift();
									tokens.push({
										value: matched,
										// Cast descendant combinators to space
										type: match[0].replace(rtrim, " ")
									});
									soFar = soFar.slice(matched.length);
								}

								// Filters
								for (type in Expr.filter) {
									if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
										(match = preFilters[type](match)))) {
										matched = match.shift();
										tokens.push({
											value: matched,
											type: type,
											matches: match
										});
										soFar = soFar.slice(matched.length);
									}
								}

								if (!matched) {
									break;
								}
							}

							// Return the length of the invalid excess
							// if we're just parsing
							// Otherwise, throw an error or return tokens
							return parseOnly ?
								soFar.length :
								soFar ?
									Sizzle.error(selector) :
									// Cache the tokens
									tokenCache(selector, groups).slice(0);
						};

						function toSelector(tokens) {
							var i = 0,
								len = tokens.length,
								selector = "";
							for (; i < len; i++) {
								selector += tokens[i].value;
							}
							return selector;
						}

						function addCombinator(matcher, combinator, base) {
							var dir = combinator.dir,
								checkNonElements = base && dir === "parentNode",
								doneName = done++;

							return combinator.first ?
								// Check against closest ancestor/preceding element
								function (elem, context, xml) {
									while ((elem = elem[dir])) {
										if (elem.nodeType === 1 || checkNonElements) {
											return matcher(elem, context, xml);
										}
									}
								} :

								// Check against all ancestor/preceding elements
								function (elem, context, xml) {
									var oldCache, uniqueCache, outerCache,
										newCache = [dirruns, doneName];

									// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
									if (xml) {
										while ((elem = elem[dir])) {
											if (elem.nodeType === 1 || checkNonElements) {
												if (matcher(elem, context, xml)) {
													return true;
												}
											}
										}
									} else {
										while ((elem = elem[dir])) {
											if (elem.nodeType === 1 || checkNonElements) {
												outerCache = elem[expando] || (elem[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

												if ((oldCache = uniqueCache[dir]) &&
													oldCache[0] === dirruns && oldCache[1] === doneName) {

													// Assign to newCache so results back-propagate to previous elements
													return (newCache[2] = oldCache[2]);
												} else {
													// Reuse newcache so results back-propagate to previous elements
													uniqueCache[dir] = newCache;

													// A match means we're done; a fail means we have to keep checking
													if ((newCache[2] = matcher(elem, context, xml))) {
														return true;
													}
												}
											}
										}
									}
								};
						}

						function elementMatcher(matchers) {
							return matchers.length > 1 ?
								function (elem, context, xml) {
									var i = matchers.length;
									while (i--) {
										if (!matchers[i](elem, context, xml)) {
											return false;
										}
									}
									return true;
								} :
								matchers[0];
						}

						function multipleContexts(selector, contexts, results) {
							var i = 0,
								len = contexts.length;
							for (; i < len; i++) {
								Sizzle(selector, contexts[i], results);
							}
							return results;
						}

						function condense(unmatched, map, filter, context, xml) {
							var elem,
								newUnmatched = [],
								i = 0,
								len = unmatched.length,
								mapped = map != null;

							for (; i < len; i++) {
								if ((elem = unmatched[i])) {
									if (!filter || filter(elem, context, xml)) {
										newUnmatched.push(elem);
										if (mapped) {
											map.push(i);
										}
									}
								}
							}

							return newUnmatched;
						}

						function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
							if (postFilter && !postFilter[expando]) {
								postFilter = setMatcher(postFilter);
							}
							if (postFinder && !postFinder[expando]) {
								postFinder = setMatcher(postFinder, postSelector);
							}
							return markFunction(function (seed, results, context, xml) {
								var temp, i, elem,
									preMap = [],
									postMap = [],
									preexisting = results.length,

									// Get initial elements from seed or context
									elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

									// Prefilter to get matcher input, preserving a map for seed-results synchronization
									matcherIn = preFilter && (seed || !selector) ?
										condense(elems, preMap, preFilter, context, xml) :
										elems,

									matcherOut = matcher ?
										// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
										postFinder || (seed ? preFilter : preexisting || postFilter) ?

											// ...intermediate processing is necessary
											[] :

											// ...otherwise use results directly
											results :
										matcherIn;

								// Find primary matches
								if (matcher) {
									matcher(matcherIn, matcherOut, context, xml);
								}

								// Apply postFilter
								if (postFilter) {
									temp = condense(matcherOut, postMap);
									postFilter(temp, [], context, xml);

									// Un-match failing elements by moving them back to matcherIn
									i = temp.length;
									while (i--) {
										if ((elem = temp[i])) {
											matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
										}
									}
								}

								if (seed) {
									if (postFinder || preFilter) {
										if (postFinder) {
											// Get the final matcherOut by condensing this intermediate into postFinder contexts
											temp = [];
											i = matcherOut.length;
											while (i--) {
												if ((elem = matcherOut[i])) {
													// Restore matcherIn since elem is not yet a final match
													temp.push((matcherIn[i] = elem));
												}
											}
											postFinder(null, (matcherOut = []), temp, xml);
										}

										// Move matched elements from seed to results to keep them synchronized
										i = matcherOut.length;
										while (i--) {
											if ((elem = matcherOut[i]) &&
												(temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

												seed[temp] = !(results[temp] = elem);
											}
										}
									}

									// Add elements to results, through postFinder if defined
								} else {
									matcherOut = condense(
										matcherOut === results ?
											matcherOut.splice(preexisting, matcherOut.length) :
											matcherOut
									);
									if (postFinder) {
										postFinder(null, results, matcherOut, xml);
									} else {
										push.apply(results, matcherOut);
									}
								}
							});
						}

						function matcherFromTokens(tokens) {
							var checkContext, matcher, j,
								len = tokens.length,
								leadingRelative = Expr.relative[tokens[0].type],
								implicitRelative = leadingRelative || Expr.relative[" "],
								i = leadingRelative ? 1 : 0,

								// The foundational matcher ensures that elements are reachable from top-level context(s)
								matchContext = addCombinator(function (elem) {
									return elem === checkContext;
								}, implicitRelative, true),
								matchAnyContext = addCombinator(function (elem) {
									return indexOf(checkContext, elem) > -1;
								}, implicitRelative, true),
								matchers = [function (elem, context, xml) {
									var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
										(checkContext = context).nodeType ?
											matchContext(elem, context, xml) :
											matchAnyContext(elem, context, xml));
									// Avoid hanging onto element (issue #299)
									checkContext = null;
									return ret;
								}];

							for (; i < len; i++) {
								if ((matcher = Expr.relative[tokens[i].type])) {
									matchers = [addCombinator(elementMatcher(matchers), matcher)];
								} else {
									matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

									// Return special upon seeing a positional matcher
									if (matcher[expando]) {
										// Find the next relative operator (if any) for proper handling
										j = ++i;
										for (; j < len; j++) {
											if (Expr.relative[tokens[j].type]) {
												break;
											}
										}
										return setMatcher(
											i > 1 && elementMatcher(matchers),
											i > 1 && toSelector(
												// If the preceding token was a descendant combinator, insert an implicit any-element `*`
												tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })
											).replace(rtrim, "$1"),
											matcher,
											i < j && matcherFromTokens(tokens.slice(i, j)),
											j < len && matcherFromTokens((tokens = tokens.slice(j))),
											j < len && toSelector(tokens)
										);
									}
									matchers.push(matcher);
								}
							}

							return elementMatcher(matchers);
						}

						function matcherFromGroupMatchers(elementMatchers, setMatchers) {
							var bySet = setMatchers.length > 0,
								byElement = elementMatchers.length > 0,
								superMatcher = function (seed, context, xml, results, outermost) {
									var elem, j, matcher,
										matchedCount = 0,
										i = "0",
										unmatched = seed && [],
										setMatched = [],
										contextBackup = outermostContext,
										// We must always have either seed elements or outermost context
										elems = seed || byElement && Expr.find["TAG"]("*", outermost),
										// Use integer dirruns iff this is the outermost matcher
										dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
										len = elems.length;

									if (outermost) {
										outermostContext = context === document || context || outermost;
									}

									// Add elements passing elementMatchers directly to results
									// Support: IE<9, Safari
									// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
									for (; i !== len && (elem = elems[i]) != null; i++) {
										if (byElement && elem) {
											j = 0;
											if (!context && elem.ownerDocument !== document) {
												setDocument(elem);
												xml = !documentIsHTML;
											}
											while ((matcher = elementMatchers[j++])) {
												if (matcher(elem, context || document, xml)) {
													results.push(elem);
													break;
												}
											}
											if (outermost) {
												dirruns = dirrunsUnique;
											}
										}

										// Track unmatched elements for set filters
										if (bySet) {
											// They will have gone through all possible matchers
											if ((elem = !matcher && elem)) {
												matchedCount--;
											}

											// Lengthen the array for every element, matched or not
											if (seed) {
												unmatched.push(elem);
											}
										}
									}

									// `i` is now the count of elements visited above, and adding it to `matchedCount`
									// makes the latter nonnegative.
									matchedCount += i;

									// Apply set filters to unmatched elements
									// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
									// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
									// no element matchers and no seed.
									// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
									// case, which will result in a "00" `matchedCount` that differs from `i` but is also
									// numerically zero.
									if (bySet && i !== matchedCount) {
										j = 0;
										while ((matcher = setMatchers[j++])) {
											matcher(unmatched, setMatched, context, xml);
										}

										if (seed) {
											// Reintegrate element matches to eliminate the need for sorting
											if (matchedCount > 0) {
												while (i--) {
													if (!(unmatched[i] || setMatched[i])) {
														setMatched[i] = pop.call(results);
													}
												}
											}

											// Discard index placeholder values to get only actual matches
											setMatched = condense(setMatched);
										}

										// Add matches to results
										push.apply(results, setMatched);

										// Seedless set matches succeeding multiple successful matchers stipulate sorting
										if (outermost && !seed && setMatched.length > 0 &&
											(matchedCount + setMatchers.length) > 1) {

											Sizzle.uniqueSort(results);
										}
									}

									// Override manipulation of globals by nested matchers
									if (outermost) {
										dirruns = dirrunsUnique;
										outermostContext = contextBackup;
									}

									return unmatched;
								};

							return bySet ?
								markFunction(superMatcher) :
								superMatcher;
						}

						compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
							var i,
								setMatchers = [],
								elementMatchers = [],
								cached = compilerCache[selector + " "];

							if (!cached) {
								// Generate a function of recursive functions that can be used to check each element
								if (!match) {
									match = tokenize(selector);
								}
								i = match.length;
								while (i--) {
									cached = matcherFromTokens(match[i]);
									if (cached[expando]) {
										setMatchers.push(cached);
									} else {
										elementMatchers.push(cached);
									}
								}

								// Cache the compiled function
								cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

								// Save selector and tokenization
								cached.selector = selector;
							}
							return cached;
						};

						/**
						 * A low-level selection function that works with Sizzle's compiled
						 *  selector functions
						 * @param {String|Function} selector A selector or a pre-compiled
						 *  selector function built with Sizzle.compile
						 * @param {Element} context
						 * @param {Array} [results]
						 * @param {Array} [seed] A set of elements to match against
						 */
						select = Sizzle.select = function (selector, context, results, seed) {
							var i, tokens, token, type, find,
								compiled = typeof selector === "function" && selector,
								match = !seed && tokenize((selector = compiled.selector || selector));

							results = results || [];

							// Try to minimize operations if there is only one selector in the list and no seed
							// (the latter of which guarantees us context)
							if (match.length === 1) {

								// Reduce context if the leading compound selector is an ID
								tokens = match[0] = match[0].slice(0);
								if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
									support.getById && context.nodeType === 9 && documentIsHTML &&
									Expr.relative[tokens[1].type]) {

									context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
									if (!context) {
										return results;

										// Precompiled matchers will still verify ancestry, so step up a level
									} else if (compiled) {
										context = context.parentNode;
									}

									selector = selector.slice(tokens.shift().value.length);
								}

								// Fetch a seed set for right-to-left matching
								i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
								while (i--) {
									token = tokens[i];

									// Abort if we hit a combinator
									if (Expr.relative[(type = token.type)]) {
										break;
									}
									if ((find = Expr.find[type])) {
										// Search, expanding context for leading sibling combinators
										if ((seed = find(
											token.matches[0].replace(runescape, funescape),
											rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
										))) {

											// If seed is empty or no tokens remain, we can return early
											tokens.splice(i, 1);
											selector = seed.length && toSelector(tokens);
											if (!selector) {
												push.apply(results, seed);
												return results;
											}

											break;
										}
									}
								}
							}

							// Compile and execute a filtering function if one is not provided
							// Provide `match` to avoid retokenization if we modified the selector above
							(compiled || compile(selector, match))(
								seed,
								context,
								!documentIsHTML,
								results,
								!context || rsibling.test(selector) && testContext(context.parentNode) || context
							);
							return results;
						};

						// One-time assignments

						// Sort stability
						support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

						// Support: Chrome 14-35+
						// Always assume duplicates if they aren't passed to the comparison function
						support.detectDuplicates = !!hasDuplicate;

						// Initialize against the default document
						setDocument();

						// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
						// Detached nodes confoundingly follow *each other*
						support.sortDetached = assert(function (div1) {
							// Should return 1, but returns 4 (following)
							return div1.compareDocumentPosition(document.createElement("div")) & 1;
						});

						// Support: IE<8
						// Prevent attribute/property "interpolation"
						// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
						if (!assert(function (div) {
							div.innerHTML = "<a href='#'></a>";
							return div.firstChild.getAttribute("href") === "#";
						})) {
							addHandle("type|href|height|width", function (elem, name, isXML) {
								if (!isXML) {
									return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
								}
							});
						}

						// Support: IE<9
						// Use defaultValue in place of getAttribute("value")
						if (!support.attributes || !assert(function (div) {
							div.innerHTML = "<input/>";
							div.firstChild.setAttribute("value", "");
							return div.firstChild.getAttribute("value") === "";
						})) {
							addHandle("value", function (elem, name, isXML) {
								if (!isXML && elem.nodeName.toLowerCase() === "input") {
									return elem.defaultValue;
								}
							});
						}

						// Support: IE<9
						// Use getAttributeNode to fetch booleans when getAttribute lies
						if (!assert(function (div) {
							return div.getAttribute("disabled") == null;
						})) {
							addHandle(booleans, function (elem, name, isXML) {
								var val;
								if (!isXML) {
									return elem[name] === true ? name.toLowerCase() :
										(val = elem.getAttributeNode(name)) && val.specified ?
											val.value :
											null;
								}
							});
						}

						return Sizzle;

					})(window);



				jQuery.find = Sizzle;
				jQuery.expr = Sizzle.selectors;
				jQuery.expr[":"] = jQuery.expr.pseudos;
				jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
				jQuery.text = Sizzle.getText;
				jQuery.isXMLDoc = Sizzle.isXML;
				jQuery.contains = Sizzle.contains;



				var dir = function (elem, dir, until) {
					var matched = [],
						truncate = until !== undefined;

					while ((elem = elem[dir]) && elem.nodeType !== 9) {
						if (elem.nodeType === 1) {
							if (truncate && jQuery(elem).is(until)) {
								break;
							}
							matched.push(elem);
						}
					}
					return matched;
				};


				var siblings = function (n, elem) {
					var matched = [];

					for (; n; n = n.nextSibling) {
						if (n.nodeType === 1 && n !== elem) {
							matched.push(n);
						}
					}

					return matched;
				};


				var rneedsContext = jQuery.expr.match.needsContext;

				var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);



				var risSimple = /^.[^:#\[\.,]*$/;

				// Implement the identical functionality for filter and not
				function winnow(elements, qualifier, not) {
					if (jQuery.isFunction(qualifier)) {
						return jQuery.grep(elements, function (elem, i) {
							/* jshint -W018 */
							return !!qualifier.call(elem, i, elem) !== not;
						});

					}

					if (qualifier.nodeType) {
						return jQuery.grep(elements, function (elem) {
							return (elem === qualifier) !== not;
						});

					}

					if (typeof qualifier === "string") {
						if (risSimple.test(qualifier)) {
							return jQuery.filter(qualifier, elements, not);
						}

						qualifier = jQuery.filter(qualifier, elements);
					}

					return jQuery.grep(elements, function (elem) {
						return (jQuery.inArray(elem, qualifier) > -1) !== not;
					});
				}

				jQuery.filter = function (expr, elems, not) {
					var elem = elems[0];

					if (not) {
						expr = ":not(" + expr + ")";
					}

					return elems.length === 1 && elem.nodeType === 1 ?
						jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
						jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
							return elem.nodeType === 1;
						}));
				};

				jQuery.fn.extend({
					find: function (selector) {
						var i,
							ret = [],
							self = this,
							len = self.length;

						if (typeof selector !== "string") {
							return this.pushStack(jQuery(selector).filter(function () {
								for (i = 0; i < len; i++) {
									if (jQuery.contains(self[i], this)) {
										return true;
									}
								}
							}));
						}

						for (i = 0; i < len; i++) {
							jQuery.find(selector, self[i], ret);
						}

						// Needed because $( selector, context ) becomes $( context ).find( selector )
						ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
						ret.selector = this.selector ? this.selector + " " + selector : selector;
						return ret;
					},
					filter: function (selector) {
						return this.pushStack(winnow(this, selector || [], false));
					},
					not: function (selector) {
						return this.pushStack(winnow(this, selector || [], true));
					},
					is: function (selector) {
						return !!winnow(
							this,

							// If this is a positional/relative selector, check membership in the returned set
							// so $("p:first").is("p:last") won't return true for a doc with two "p".
							typeof selector === "string" && rneedsContext.test(selector) ?
								jQuery(selector) :
								selector || [],
							false
						).length;
					}
				});


				// Initialize a jQuery object


				// A central reference to the root jQuery(document)
				var rootjQuery,

					// A simple way to check for HTML strings
					// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
					// Strict HTML recognition (#11290: must start with <)
					rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

					init = jQuery.fn.init = function (selector, context, root) {
						var match, elem;

						// HANDLE: $(""), $(null), $(undefined), $(false)
						if (!selector) {
							return this;
						}

						// init accepts an alternate rootjQuery
						// so migrate can support jQuery.sub (gh-2101)
						root = root || rootjQuery;

						// Handle HTML strings
						if (typeof selector === "string") {
							if (selector.charAt(0) === "<" &&
								selector.charAt(selector.length - 1) === ">" &&
								selector.length >= 3) {

								// Assume that strings that start and end with <> are HTML and skip the regex check
								match = [null, selector, null];

							} else {
								match = rquickExpr.exec(selector);
							}

							// Match html or make sure no context is specified for #id
							if (match && (match[1] || !context)) {

								// HANDLE: $(html) -> $(array)
								if (match[1]) {
									context = context instanceof jQuery ? context[0] : context;

									// scripts is true for back-compat
									// Intentionally let the error be thrown if parseHTML is not present
									jQuery.merge(this, jQuery.parseHTML(
										match[1],
										context && context.nodeType ? context.ownerDocument || context : document,
										true
									));

									// HANDLE: $(html, props)
									if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
										for (match in context) {

											// Properties of context are called as methods if possible
											if (jQuery.isFunction(this[match])) {
												this[match](context[match]);

												// ...and otherwise set as attributes
											} else {
												this.attr(match, context[match]);
											}
										}
									}

									return this;

									// HANDLE: $(#id)
								} else {
									elem = document.getElementById(match[2]);

									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									if (elem && elem.parentNode) {

										// Handle the case where IE and Opera return items
										// by name instead of ID
										if (elem.id !== match[2]) {
											return rootjQuery.find(selector);
										}

										// Otherwise, we inject the element directly into the jQuery object
										this.length = 1;
										this[0] = elem;
									}

									this.context = document;
									this.selector = selector;
									return this;
								}

								// HANDLE: $(expr, $(...))
							} else if (!context || context.jquery) {
								return (context || root).find(selector);

								// HANDLE: $(expr, context)
								// (which is just equivalent to: $(context).find(expr)
							} else {
								return this.constructor(context).find(selector);
							}

							// HANDLE: $(DOMElement)
						} else if (selector.nodeType) {
							this.context = this[0] = selector;
							this.length = 1;
							return this;

							// HANDLE: $(function)
							// Shortcut for document ready
						} else if (jQuery.isFunction(selector)) {
							return typeof root.ready !== "undefined" ?
								root.ready(selector) :

								// Execute immediately if ready is not present
								selector(jQuery);
						}

						if (selector.selector !== undefined) {
							this.selector = selector.selector;
							this.context = selector.context;
						}

						return jQuery.makeArray(selector, this);
					};

				// Give the init function the jQuery prototype for later instantiation
				init.prototype = jQuery.fn;

				// Initialize central reference
				rootjQuery = jQuery(document);


				var rparentsprev = /^(?:parents|prev(?:Until|All))/,

					// methods guaranteed to produce a unique set when starting from a unique set
					guaranteedUnique = {
						children: true,
						contents: true,
						next: true,
						prev: true
					};

				jQuery.fn.extend({
					has: function (target) {
						var i,
							targets = jQuery(target, this),
							len = targets.length;

						return this.filter(function () {
							for (i = 0; i < len; i++) {
								if (jQuery.contains(this, targets[i])) {
									return true;
								}
							}
						});
					},

					closest: function (selectors, context) {
						var cur,
							i = 0,
							l = this.length,
							matched = [],
							pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
								jQuery(selectors, context || this.context) :
								0;

						for (; i < l; i++) {
							for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

								// Always skip document fragments
								if (cur.nodeType < 11 && (pos ?
									pos.index(cur) > -1 :

									// Don't pass non-elements to Sizzle
									cur.nodeType === 1 &&
									jQuery.find.matchesSelector(cur, selectors))) {

									matched.push(cur);
									break;
								}
							}
						}

						return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
					},

					// Determine the position of an element within
					// the matched set of elements
					index: function (elem) {

						// No argument, return index in parent
						if (!elem) {
							return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
						}

						// index in selector
						if (typeof elem === "string") {
							return jQuery.inArray(this[0], jQuery(elem));
						}

						// Locate the position of the desired element
						return jQuery.inArray(

							// If it receives a jQuery object, the first element is used
							elem.jquery ? elem[0] : elem, this);
					},

					add: function (selector, context) {
						return this.pushStack(
							jQuery.uniqueSort(
								jQuery.merge(this.get(), jQuery(selector, context))
							)
						);
					},

					addBack: function (selector) {
						return this.add(selector == null ?
							this.prevObject : this.prevObject.filter(selector)
						);
					}
				});

				function sibling(cur, dir) {
					do {
						cur = cur[dir];
					} while (cur && cur.nodeType !== 1);

					return cur;
				}

				jQuery.each({
					parent: function (elem) {
						var parent = elem.parentNode;
						return parent && parent.nodeType !== 11 ? parent : null;
					},
					parents: function (elem) {
						return dir(elem, "parentNode");
					},
					parentsUntil: function (elem, i, until) {
						return dir(elem, "parentNode", until);
					},
					next: function (elem) {
						return sibling(elem, "nextSibling");
					},
					prev: function (elem) {
						return sibling(elem, "previousSibling");
					},
					nextAll: function (elem) {
						return dir(elem, "nextSibling");
					},
					prevAll: function (elem) {
						return dir(elem, "previousSibling");
					},
					nextUntil: function (elem, i, until) {
						return dir(elem, "nextSibling", until);
					},
					prevUntil: function (elem, i, until) {
						return dir(elem, "previousSibling", until);
					},
					siblings: function (elem) {
						return siblings((elem.parentNode || {}).firstChild, elem);
					},
					children: function (elem) {
						return siblings(elem.firstChild);
					},
					contents: function (elem) {
						return jQuery.nodeName(elem, "iframe") ?
							elem.contentDocument || elem.contentWindow.document :
							jQuery.merge([], elem.childNodes);
					}
				}, function (name, fn) {
					jQuery.fn[name] = function (until, selector) {
						var ret = jQuery.map(this, fn, until);

						if (name.slice(-5) !== "Until") {
							selector = until;
						}

						if (selector && typeof selector === "string") {
							ret = jQuery.filter(selector, ret);
						}

						if (this.length > 1) {

							// Remove duplicates
							if (!guaranteedUnique[name]) {
								ret = jQuery.uniqueSort(ret);
							}

							// Reverse order for parents* and prev-derivatives
							if (rparentsprev.test(name)) {
								ret = ret.reverse();
							}
						}

						return this.pushStack(ret);
					};
				});
				var rnotwhite = (/\S+/g);



				// Convert String-formatted options into Object-formatted ones
				function createOptions(options) {
					var object = {};
					jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
						object[flag] = true;
					});
					return object;
				}

				/*
				 * Create a callback list using the following parameters:
				 *
				 *	options: an optional list of space-separated options that will change how
				 *			the callback list behaves or a more traditional option object
				 *
				 * By default a callback list will act like an event callback list and can be
				 * "fired" multiple times.
				 *
				 * Possible options:
				 *
				 *	once:			will ensure the callback list can only be fired once (like a Deferred)
				 *
				 *	memory:			will keep track of previous values and will call any callback added
				 *					after the list has been fired right away with the latest "memorized"
				 *					values (like a Deferred)
				 *
				 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
				 *
				 *	stopOnFalse:	interrupt callings when a callback returns false
				 *
				 */
				jQuery.Callbacks = function (options) {

					// Convert options from String-formatted to Object-formatted if needed
					// (we check in cache first)
					options = typeof options === "string" ?
						createOptions(options) :
						jQuery.extend({}, options);

					var // Flag to know if list is currently firing
						firing,

						// Last fire value for non-forgettable lists
						memory,

						// Flag to know if list was already fired
						fired,

						// Flag to prevent firing
						locked,

						// Actual callback list
						list = [],

						// Queue of execution data for repeatable lists
						queue = [],

						// Index of currently firing callback (modified by add/remove as needed)
						firingIndex = -1,

						// Fire callbacks
						fire = function () {

							// Enforce single-firing
							locked = options.once;

							// Execute callbacks for all pending executions,
							// respecting firingIndex overrides and runtime changes
							fired = firing = true;
							for (; queue.length; firingIndex = -1) {
								memory = queue.shift();
								while (++firingIndex < list.length) {

									// Run callback and check for early termination
									if (list[firingIndex].apply(memory[0], memory[1]) === false &&
										options.stopOnFalse) {

										// Jump to end and forget the data so .add doesn't re-fire
										firingIndex = list.length;
										memory = false;
									}
								}
							}

							// Forget the data if we're done with it
							if (!options.memory) {
								memory = false;
							}

							firing = false;

							// Clean up if we're done firing for good
							if (locked) {

								// Keep an empty list if we have data for future add calls
								if (memory) {
									list = [];

									// Otherwise, this object is spent
								} else {
									list = "";
								}
							}
						},

						// Actual Callbacks object
						self = {

							// Add a callback or a collection of callbacks to the list
							add: function () {
								if (list) {

									// If we have memory from a past run, we should fire after adding
									if (memory && !firing) {
										firingIndex = list.length - 1;
										queue.push(memory);
									}

									(function add(args) {
										jQuery.each(args, function (_, arg) {
											if (jQuery.isFunction(arg)) {
												if (!options.unique || !self.has(arg)) {
													list.push(arg);
												}
											} else if (arg && arg.length && jQuery.type(arg) !== "string") {

												// Inspect recursively
												add(arg);
											}
										});
									})(arguments);

									if (memory && !firing) {
										fire();
									}
								}
								return this;
							},

							// Remove a callback from the list
							remove: function () {
								jQuery.each(arguments, function (_, arg) {
									var index;
									while ((index = jQuery.inArray(arg, list, index)) > -1) {
										list.splice(index, 1);

										// Handle firing indexes
										if (index <= firingIndex) {
											firingIndex--;
										}
									}
								});
								return this;
							},

							// Check if a given callback is in the list.
							// If no argument is given, return whether or not list has callbacks attached.
							has: function (fn) {
								return fn ?
									jQuery.inArray(fn, list) > -1 :
									list.length > 0;
							},

							// Remove all callbacks from the list
							empty: function () {
								if (list) {
									list = [];
								}
								return this;
							},

							// Disable .fire and .add
							// Abort any current/pending executions
							// Clear all callbacks and values
							disable: function () {
								locked = queue = [];
								list = memory = "";
								return this;
							},
							disabled: function () {
								return !list;
							},

							// Disable .fire
							// Also disable .add unless we have memory (since it would have no effect)
							// Abort any pending executions
							lock: function () {
								locked = true;
								if (!memory) {
									self.disable();
								}
								return this;
							},
							locked: function () {
								return !!locked;
							},

							// Call all callbacks with the given context and arguments
							fireWith: function (context, args) {
								if (!locked) {
									args = args || [];
									args = [context, args.slice ? args.slice() : args];
									queue.push(args);
									if (!firing) {
										fire();
									}
								}
								return this;
							},

							// Call all the callbacks with the given arguments
							fire: function () {
								self.fireWith(this, arguments);
								return this;
							},

							// To know if the callbacks have already been called at least once
							fired: function () {
								return !!fired;
							}
						};

					return self;
				};


				jQuery.extend({

					Deferred: function (func) {
						var tuples = [

							// action, add listener, listener list, final state
							["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
							["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
							["notify", "progress", jQuery.Callbacks("memory")]
						],
							state = "pending",
							promise = {
								state: function () {
									return state;
								},
								always: function () {
									deferred.done(arguments).fail(arguments);
									return this;
								},
								then: function ( /* fnDone, fnFail, fnProgress */) {
									var fns = arguments;
									return jQuery.Deferred(function (newDefer) {
										jQuery.each(tuples, function (i, tuple) {
											var fn = jQuery.isFunction(fns[i]) && fns[i];

											// deferred[ done | fail | progress ] for forwarding actions to newDefer
											deferred[tuple[1]](function () {
												var returned = fn && fn.apply(this, arguments);
												if (returned && jQuery.isFunction(returned.promise)) {
													returned.promise()
														.progress(newDefer.notify)
														.done(newDefer.resolve)
														.fail(newDefer.reject);
												} else {
													newDefer[tuple[0] + "With"](
														this === promise ? newDefer.promise() : this,
														fn ? [returned] : arguments
													);
												}
											});
										});
										fns = null;
									}).promise();
								},

								// Get a promise for this deferred
								// If obj is provided, the promise aspect is added to the object
								promise: function (obj) {
									return obj != null ? jQuery.extend(obj, promise) : promise;
								}
							},
							deferred = {};

						// Keep pipe for back-compat
						promise.pipe = promise.then;

						// Add list-specific methods
						jQuery.each(tuples, function (i, tuple) {
							var list = tuple[2],
								stateString = tuple[3];

							// promise[ done | fail | progress ] = list.add
							promise[tuple[1]] = list.add;

							// Handle state
							if (stateString) {
								list.add(function () {

									// state = [ resolved | rejected ]
									state = stateString;

									// [ reject_list | resolve_list ].disable; progress_list.lock
								}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
							}

							// deferred[ resolve | reject | notify ]
							deferred[tuple[0]] = function () {
								deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
								return this;
							};
							deferred[tuple[0] + "With"] = list.fireWith;
						});

						// Make the deferred a promise
						promise.promise(deferred);

						// Call given func if any
						if (func) {
							func.call(deferred, deferred);
						}

						// All done!
						return deferred;
					},

					// Deferred helper
					when: function (subordinate /* , ..., subordinateN */) {
						var i = 0,
							resolveValues = slice.call(arguments),
							length = resolveValues.length,

							// the count of uncompleted subordinates
							remaining = length !== 1 ||
								(subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

							// the master Deferred.
							// If resolveValues consist of only a single Deferred, just use that.
							deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

							// Update function for both resolve and progress values
							updateFunc = function (i, contexts, values) {
								return function (value) {
									contexts[i] = this;
									values[i] = arguments.length > 1 ? slice.call(arguments) : value;
									if (values === progressValues) {
										deferred.notifyWith(contexts, values);

									} else if (!(--remaining)) {
										deferred.resolveWith(contexts, values);
									}
								};
							},

							progressValues, progressContexts, resolveContexts;

						// add listeners to Deferred subordinates; treat others as resolved
						if (length > 1) {
							progressValues = new Array(length);
							progressContexts = new Array(length);
							resolveContexts = new Array(length);
							for (; i < length; i++) {
								if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
									resolveValues[i].promise()
										.progress(updateFunc(i, progressContexts, progressValues))
										.done(updateFunc(i, resolveContexts, resolveValues))
										.fail(deferred.reject);
								} else {
									--remaining;
								}
							}
						}

						// if we're not waiting on anything, resolve the master
						if (!remaining) {
							deferred.resolveWith(resolveContexts, resolveValues);
						}

						return deferred.promise();
					}
				});


				// The deferred used on DOM ready
				var readyList;

				jQuery.fn.ready = function (fn) {

					// Add the callback
					jQuery.ready.promise().done(fn);

					return this;
				};

				jQuery.extend({

					// Is the DOM ready to be used? Set to true once it occurs.
					isReady: false,

					// A counter to track how many items to wait for before
					// the ready event fires. See #6781
					readyWait: 1,

					// Hold (or release) the ready event
					holdReady: function (hold) {
						if (hold) {
							jQuery.readyWait++;
						} else {
							jQuery.ready(true);
						}
					},

					// Handle when the DOM is ready
					ready: function (wait) {

						// Abort if there are pending holds or we're already ready
						if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
							return;
						}

						// Remember that the DOM is ready
						jQuery.isReady = true;

						// If a normal DOM Ready event fired, decrement, and wait if need be
						if (wait !== true && --jQuery.readyWait > 0) {
							return;
						}

						// If there are functions bound, to execute
						readyList.resolveWith(document, [jQuery]);

						// Trigger any bound ready events
						if (jQuery.fn.triggerHandler) {
							jQuery(document).triggerHandler("ready");
							jQuery(document).off("ready");
						}
					}
				});

				/**
				 * Clean-up method for dom ready events
				 */
				function detach() {
					if (document.addEventListener) {
						document.removeEventListener("DOMContentLoaded", completed);
						window.removeEventListener("load", completed);

					} else {
						document.detachEvent("onreadystatechange", completed);
						window.detachEvent("onload", completed);
					}
				}

				/**
				 * The ready event handler and self cleanup method
				 */
				function completed() {

					// readyState === "complete" is good enough for us to call the dom ready in oldIE
					if (document.addEventListener ||
						window.event.type === "load" ||
						document.readyState === "complete") {

						detach();
						jQuery.ready();
					}
				}

				jQuery.ready.promise = function (obj) {
					if (!readyList) {

						readyList = jQuery.Deferred();

						// Catch cases where $(document).ready() is called
						// after the browser event has already occurred.
						// Support: IE6-10
						// Older IE sometimes signals "interactive" too soon
						if (document.readyState === "complete" ||
							(document.readyState !== "loading" && !document.documentElement.doScroll)) {

							// Handle it asynchronously to allow scripts the opportunity to delay ready
							window.setTimeout(jQuery.ready);

							// Standards-based browsers support DOMContentLoaded
						} else if (document.addEventListener) {

							// Use the handy event callback
							document.addEventListener("DOMContentLoaded", completed);

							// A fallback to window.onload, that will always work
							window.addEventListener("load", completed);

							// If IE event model is used
						} else {

							// Ensure firing before onload, maybe late but safe also for iframes
							document.attachEvent("onreadystatechange", completed);

							// A fallback to window.onload, that will always work
							window.attachEvent("onload", completed);

							// If IE and not a frame
							// continually check to see if the document is ready
							var top = false;

							try {
								top = window.frameElement == null && document.documentElement;
							} catch (e) { }

							if (top && top.doScroll) {
								(function doScrollCheck() {
									if (!jQuery.isReady) {

										try {

											// Use the trick by Diego Perini
											// http://javascript.nwbox.com/IEContentLoaded/
											top.doScroll("left");
										} catch (e) {
											return window.setTimeout(doScrollCheck, 50);
										}

										// detach all dom ready events
										detach();

										// and execute any waiting functions
										jQuery.ready();
									}
								})();
							}
						}
					}
					return readyList.promise(obj);
				};

				// Kick off the DOM ready check even if the user does not
				jQuery.ready.promise();




				// Support: IE<9
				// Iteration over object's inherited properties before its own
				var i;
				for (i in jQuery(support)) {
					break;
				}
				support.ownFirst = i === "0";

				// Note: most support tests are defined in their respective modules.
				// false until the test is run
				support.inlineBlockNeedsLayout = false;

				// Execute ASAP in case we need to set body.style.zoom
				jQuery(function () {

					// Minified: var a,b,c,d
					var val, div, body, container;

					body = document.getElementsByTagName("body")[0];
					if (!body || !body.style) {

						// Return for frameset docs that don't have a body
						return;
					}

					// Setup
					div = document.createElement("div");
					container = document.createElement("div");
					container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
					body.appendChild(container).appendChild(div);

					if (typeof div.style.zoom !== "undefined") {

						// Support: IE<8
						// Check if natively block-level elements act like inline-block
						// elements when setting their display to 'inline' and giving
						// them layout
						div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

						support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
						if (val) {

							// Prevent IE 6 from affecting layout for positioned elements #11048
							// Prevent IE from shrinking the body in IE 7 mode #12869
							// Support: IE<8
							body.style.zoom = 1;
						}
					}

					body.removeChild(container);
				});


				(function () {
					var div = document.createElement("div");

					// Support: IE<9
					support.deleteExpando = true;
					try {
						delete div.test;
					} catch (e) {
						support.deleteExpando = false;
					}

					// Null elements to avoid leaks in IE.
					div = null;
				})();
				var acceptData = function (elem) {
					var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()],
						nodeType = +elem.nodeType || 1;

					// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
					return nodeType !== 1 && nodeType !== 9 ?
						false :

						// Nodes accept data unless otherwise specified; rejection can be conditional
						!noData || noData !== true && elem.getAttribute("classid") === noData;
				};




				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
					rmultiDash = /([A-Z])/g;

				function dataAttr(elem, key, data) {

					// If nothing was found internally, try to fetch any
					// data from the HTML5 data-* attribute
					if (data === undefined && elem.nodeType === 1) {

						var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

						data = elem.getAttribute(name);

						if (typeof data === "string") {
							try {
								data = data === "true" ? true :
									data === "false" ? false :
										data === "null" ? null :

											// Only convert to a number if it doesn't change the string
											+data + "" === data ? +data :
												rbrace.test(data) ? jQuery.parseJSON(data) :
													data;
							} catch (e) { }

							// Make sure we set the data so it isn't changed later
							jQuery.data(elem, key, data);

						} else {
							data = undefined;
						}
					}

					return data;
				}

				// checks a cache object for emptiness
				function isEmptyDataObject(obj) {
					var name;
					for (name in obj) {

						// if the public data object is empty, the private is still empty
						if (name === "data" && jQuery.isEmptyObject(obj[name])) {
							continue;
						}
						if (name !== "toJSON") {
							return false;
						}
					}

					return true;
				}

				function internalData(elem, name, data, pvt /* Internal Use Only */) {
					if (!acceptData(elem)) {
						return;
					}

					var ret, thisCache,
						internalKey = jQuery.expando,

						// We have to handle DOM nodes and JS objects differently because IE6-7
						// can't GC object references properly across the DOM-JS boundary
						isNode = elem.nodeType,

						// Only DOM nodes need the global jQuery cache; JS object data is
						// attached directly to the object so GC can occur automatically
						cache = isNode ? jQuery.cache : elem,

						// Only defining an ID for JS objects if its cache already exists allows
						// the code to shortcut on the same path as a DOM node with no cache
						id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

					// Avoid doing any more work than we need to when trying to get data on an
					// object that has no data at all
					if ((!id || !cache[id] || (!pvt && !cache[id].data)) &&
						data === undefined && typeof name === "string") {
						return;
					}

					if (!id) {

						// Only DOM nodes need a new unique ID for each element since their data
						// ends up in the global cache
						if (isNode) {
							id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
						} else {
							id = internalKey;
						}
					}

					if (!cache[id]) {

						// Avoid exposing jQuery metadata on plain JS objects when the object
						// is serialized using JSON.stringify
						cache[id] = isNode ? {} : { toJSON: jQuery.noop };
					}

					// An object can be passed to jQuery.data instead of a key/value pair; this gets
					// shallow copied over onto the existing cache
					if (typeof name === "object" || typeof name === "function") {
						if (pvt) {
							cache[id] = jQuery.extend(cache[id], name);
						} else {
							cache[id].data = jQuery.extend(cache[id].data, name);
						}
					}

					thisCache = cache[id];

					// jQuery data() is stored in a separate object inside the object's internal data
					// cache in order to avoid key collisions between internal data and user-defined
					// data.
					if (!pvt) {
						if (!thisCache.data) {
							thisCache.data = {};
						}

						thisCache = thisCache.data;
					}

					if (data !== undefined) {
						thisCache[jQuery.camelCase(name)] = data;
					}

					// Check for both converted-to-camel and non-converted data property names
					// If a data property was specified
					if (typeof name === "string") {

						// First Try to find as-is property data
						ret = thisCache[name];

						// Test for null|undefined property data
						if (ret == null) {

							// Try to find the camelCased property
							ret = thisCache[jQuery.camelCase(name)];
						}
					} else {
						ret = thisCache;
					}

					return ret;
				}

				function internalRemoveData(elem, name, pvt) {
					if (!acceptData(elem)) {
						return;
					}

					var thisCache, i,
						isNode = elem.nodeType,

						// See jQuery.data for more information
						cache = isNode ? jQuery.cache : elem,
						id = isNode ? elem[jQuery.expando] : jQuery.expando;

					// If there is already no cache entry for this object, there is no
					// purpose in continuing
					if (!cache[id]) {
						return;
					}

					if (name) {

						thisCache = pvt ? cache[id] : cache[id].data;

						if (thisCache) {

							// Support array or space separated string names for data keys
							if (!jQuery.isArray(name)) {

								// try the string as a key before any manipulation
								if (name in thisCache) {
									name = [name];
								} else {

									// split the camel cased version by spaces unless a key with the spaces exists
									name = jQuery.camelCase(name);
									if (name in thisCache) {
										name = [name];
									} else {
										name = name.split(" ");
									}
								}
							} else {

								// If "name" is an array of keys...
								// When data is initially created, via ("key", "val") signature,
								// keys will be converted to camelCase.
								// Since there is no way to tell _how_ a key was added, remove
								// both plain key and camelCase key. #12786
								// This will only penalize the array argument path.
								name = name.concat(jQuery.map(name, jQuery.camelCase));
							}

							i = name.length;
							while (i--) {
								delete thisCache[name[i]];
							}

							// If there is no data left in the cache, we want to continue
							// and let the cache object itself get destroyed
							if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
								return;
							}
						}
					}

					// See jQuery.data for more information
					if (!pvt) {
						delete cache[id].data;

						// Don't destroy the parent cache unless the internal data object
						// had been the only thing left in it
						if (!isEmptyDataObject(cache[id])) {
							return;
						}
					}

					// Destroy the cache
					if (isNode) {
						jQuery.cleanData([elem], true);

						// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
						/* jshint eqeqeq: false */
					} else if (support.deleteExpando || cache != cache.window) {
						/* jshint eqeqeq: true */
						delete cache[id];

						// When all else fails, undefined
					} else {
						cache[id] = undefined;
					}
				}

				jQuery.extend({
					cache: {},

					// The following elements (space-suffixed to avoid Object.prototype collisions)
					// throw uncatchable exceptions if you attempt to set expando properties
					noData: {
						"applet ": true,
						"embed ": true,

						// ...but Flash objects (which have this classid) *can* handle expandos
						"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
					},

					hasData: function (elem) {
						elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
						return !!elem && !isEmptyDataObject(elem);
					},

					data: function (elem, name, data) {
						return internalData(elem, name, data);
					},

					removeData: function (elem, name) {
						return internalRemoveData(elem, name);
					},

					// For internal use only.
					_data: function (elem, name, data) {
						return internalData(elem, name, data, true);
					},

					_removeData: function (elem, name) {
						return internalRemoveData(elem, name, true);
					}
				});

				jQuery.fn.extend({
					data: function (key, value) {
						var i, name, data,
							elem = this[0],
							attrs = elem && elem.attributes;

						// Special expections of .data basically thwart jQuery.access,
						// so implement the relevant behavior ourselves

						// Gets all values
						if (key === undefined) {
							if (this.length) {
								data = jQuery.data(elem);

								if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
									i = attrs.length;
									while (i--) {

										// Support: IE11+
										// The attrs elements can be null (#14894)
										if (attrs[i]) {
											name = attrs[i].name;
											if (name.indexOf("data-") === 0) {
												name = jQuery.camelCase(name.slice(5));
												dataAttr(elem, name, data[name]);
											}
										}
									}
									jQuery._data(elem, "parsedAttrs", true);
								}
							}

							return data;
						}

						// Sets multiple values
						if (typeof key === "object") {
							return this.each(function () {
								jQuery.data(this, key);
							});
						}

						return arguments.length > 1 ?

							// Sets one value
							this.each(function () {
								jQuery.data(this, key, value);
							}) :

							// Gets one value
							// Try to fetch any internally stored data first
							elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
					},

					removeData: function (key) {
						return this.each(function () {
							jQuery.removeData(this, key);
						});
					}
				});


				jQuery.extend({
					queue: function (elem, type, data) {
						var queue;

						if (elem) {
							type = (type || "fx") + "queue";
							queue = jQuery._data(elem, type);

							// Speed up dequeue by getting out quickly if this is just a lookup
							if (data) {
								if (!queue || jQuery.isArray(data)) {
									queue = jQuery._data(elem, type, jQuery.makeArray(data));
								} else {
									queue.push(data);
								}
							}
							return queue || [];
						}
					},

					dequeue: function (elem, type) {
						type = type || "fx";

						var queue = jQuery.queue(elem, type),
							startLength = queue.length,
							fn = queue.shift(),
							hooks = jQuery._queueHooks(elem, type),
							next = function () {
								jQuery.dequeue(elem, type);
							};

						// If the fx queue is dequeued, always remove the progress sentinel
						if (fn === "inprogress") {
							fn = queue.shift();
							startLength--;
						}

						if (fn) {

							// Add a progress sentinel to prevent the fx queue from being
							// automatically dequeued
							if (type === "fx") {
								queue.unshift("inprogress");
							}

							// clear up the last queue stop function
							delete hooks.stop;
							fn.call(elem, next, hooks);
						}

						if (!startLength && hooks) {
							hooks.empty.fire();
						}
					},

					// not intended for public consumption - generates a queueHooks object,
					// or returns the current one
					_queueHooks: function (elem, type) {
						var key = type + "queueHooks";
						return jQuery._data(elem, key) || jQuery._data(elem, key, {
							empty: jQuery.Callbacks("once memory").add(function () {
								jQuery._removeData(elem, type + "queue");
								jQuery._removeData(elem, key);
							})
						});
					}
				});

				jQuery.fn.extend({
					queue: function (type, data) {
						var setter = 2;

						if (typeof type !== "string") {
							data = type;
							type = "fx";
							setter--;
						}

						if (arguments.length < setter) {
							return jQuery.queue(this[0], type);
						}

						return data === undefined ?
							this :
							this.each(function () {
								var queue = jQuery.queue(this, type, data);

								// ensure a hooks for this queue
								jQuery._queueHooks(this, type);

								if (type === "fx" && queue[0] !== "inprogress") {
									jQuery.dequeue(this, type);
								}
							});
					},
					dequeue: function (type) {
						return this.each(function () {
							jQuery.dequeue(this, type);
						});
					},
					clearQueue: function (type) {
						return this.queue(type || "fx", []);
					},

					// Get a promise resolved when queues of a certain type
					// are emptied (fx is the type by default)
					promise: function (type, obj) {
						var tmp,
							count = 1,
							defer = jQuery.Deferred(),
							elements = this,
							i = this.length,
							resolve = function () {
								if (!(--count)) {
									defer.resolveWith(elements, [elements]);
								}
							};

						if (typeof type !== "string") {
							obj = type;
							type = undefined;
						}
						type = type || "fx";

						while (i--) {
							tmp = jQuery._data(elements[i], type + "queueHooks");
							if (tmp && tmp.empty) {
								count++;
								tmp.empty.add(resolve);
							}
						}
						resolve();
						return defer.promise(obj);
					}
				});


				(function () {
					var shrinkWrapBlocksVal;

					support.shrinkWrapBlocks = function () {
						if (shrinkWrapBlocksVal != null) {
							return shrinkWrapBlocksVal;
						}

						// Will be changed later if needed.
						shrinkWrapBlocksVal = false;

						// Minified: var b,c,d
						var div, body, container;

						body = document.getElementsByTagName("body")[0];
						if (!body || !body.style) {

							// Test fired too early or in an unsupported environment, exit.
							return;
						}

						// Setup
						div = document.createElement("div");
						container = document.createElement("div");
						container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
						body.appendChild(container).appendChild(div);

						// Support: IE6
						// Check if elements with layout shrink-wrap their children
						if (typeof div.style.zoom !== "undefined") {

							// Reset CSS: box-sizing; display; margin; border
							div.style.cssText =

								// Support: Firefox<29, Android 2.3
								// Vendor-prefix box-sizing
								"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
								"box-sizing:content-box;display:block;margin:0;border:0;" +
								"padding:1px;width:1px;zoom:1";
							div.appendChild(document.createElement("div")).style.width = "5px";
							shrinkWrapBlocksVal = div.offsetWidth !== 3;
						}

						body.removeChild(container);

						return shrinkWrapBlocksVal;
					};

				})();
				var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

				var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


				var cssExpand = ["Top", "Right", "Bottom", "Left"];

				var isHidden = function (elem, el) {

					// isHidden might be called from jQuery#filter function;
					// in that case, element will be second argument
					elem = el || elem;
					return jQuery.css(elem, "display") === "none" ||
						!jQuery.contains(elem.ownerDocument, elem);
				};



				function adjustCSS(elem, prop, valueParts, tween) {
					var adjusted,
						scale = 1,
						maxIterations = 20,
						currentValue = tween ?
							function () { return tween.cur(); } :
							function () { return jQuery.css(elem, prop, ""); },
						initial = currentValue(),
						unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

						// Starting value computation is required for potential unit mismatches
						initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
							rcssNum.exec(jQuery.css(elem, prop));

					if (initialInUnit && initialInUnit[3] !== unit) {

						// Trust units reported by jQuery.css
						unit = unit || initialInUnit[3];

						// Make sure we update the tween properties later on
						valueParts = valueParts || [];

						// Iteratively approximate from a nonzero starting point
						initialInUnit = +initial || 1;

						do {

							// If previous iteration zeroed out, double until we get *something*.
							// Use string for doubling so we don't accidentally see scale as unchanged below
							scale = scale || ".5";

							// Adjust and apply
							initialInUnit = initialInUnit / scale;
							jQuery.style(elem, prop, initialInUnit + unit);

							// Update scale, tolerating zero or NaN from tween.cur()
							// Break the loop if scale is unchanged or perfect, or if we've just had enough.
						} while (
							scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations
						);
					}

					if (valueParts) {
						initialInUnit = +initialInUnit || +initial || 0;

						// Apply relative offset (+=/-=) if specified
						adjusted = valueParts[1] ?
							initialInUnit + (valueParts[1] + 1) * valueParts[2] :
							+valueParts[2];
						if (tween) {
							tween.unit = unit;
							tween.start = initialInUnit;
							tween.end = adjusted;
						}
					}
					return adjusted;
				}


				// Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function
				var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
					var i = 0,
						length = elems.length,
						bulk = key == null;

					// Sets many values
					if (jQuery.type(key) === "object") {
						chainable = true;
						for (i in key) {
							access(elems, fn, i, key[i], true, emptyGet, raw);
						}

						// Sets one value
					} else if (value !== undefined) {
						chainable = true;

						if (!jQuery.isFunction(value)) {
							raw = true;
						}

						if (bulk) {

							// Bulk operations run against the entire set
							if (raw) {
								fn.call(elems, value);
								fn = null;

								// ...except when executing function values
							} else {
								bulk = fn;
								fn = function (elem, key, value) {
									return bulk.call(jQuery(elem), value);
								};
							}
						}

						if (fn) {
							for (; i < length; i++) {
								fn(
									elems[i],
									key,
									raw ? value : value.call(elems[i], i, fn(elems[i], key))
								);
							}
						}
					}

					return chainable ?
						elems :

						// Gets
						bulk ?
							fn.call(elems) :
							length ? fn(elems[0], key) : emptyGet;
				};
				var rcheckableType = (/^(?:checkbox|radio)$/i);

				var rtagName = (/<([\w:-]+)/);

				var rscriptType = (/^$|\/(?:java|ecma)script/i);

				var rleadingWhitespace = (/^\s+/);

				var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
					"details|dialog|figcaption|figure|footer|header|hgroup|main|" +
					"mark|meter|nav|output|picture|progress|section|summary|template|time|video";



				function createSafeFragment(document) {
					var list = nodeNames.split("|"),
						safeFrag = document.createDocumentFragment();

					if (safeFrag.createElement) {
						while (list.length) {
							safeFrag.createElement(
								list.pop()
							);
						}
					}
					return safeFrag;
				}


				(function () {
					var div = document.createElement("div"),
						fragment = document.createDocumentFragment(),
						input = document.createElement("input");

					// Setup
					div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

					// IE strips leading whitespace when .innerHTML is used
					support.leadingWhitespace = div.firstChild.nodeType === 3;

					// Make sure that tbody elements aren't automatically inserted
					// IE will insert them into empty tables
					support.tbody = !div.getElementsByTagName("tbody").length;

					// Make sure that link elements get serialized correctly by innerHTML
					// This requires a wrapper element in IE
					support.htmlSerialize = !!div.getElementsByTagName("link").length;

					// Makes sure cloning an html5 element does not cause problems
					// Where outerHTML is undefined, this still works
					support.html5Clone =
						document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>";

					// Check if a disconnected checkbox will retain its checked
					// value of true after appended to the DOM (IE6/7)
					input.type = "checkbox";
					input.checked = true;
					fragment.appendChild(input);
					support.appendChecked = input.checked;

					// Make sure textarea (and checkbox) defaultValue is properly cloned
					// Support: IE6-IE11+
					div.innerHTML = "<textarea>x</textarea>";
					support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

					// #11217 - WebKit loses check when the name is after the checked attribute
					fragment.appendChild(div);

					// Support: Windows Web Apps (WWA)
					// `name` and `type` must use .setAttribute for WWA (#14901)
					input = document.createElement("input");
					input.setAttribute("type", "radio");
					input.setAttribute("checked", "checked");
					input.setAttribute("name", "t");

					div.appendChild(input);

					// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
					// old WebKit doesn't clone checked state correctly in fragments
					support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

					// Support: IE<9
					// Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
					support.noCloneEvent = !!div.addEventListener;

					// Support: IE<9
					// Since attributes and properties are the same in IE,
					// cleanData must set properties to undefined rather than use removeAttribute
					div[jQuery.expando] = 1;
					support.attributes = !div.getAttribute(jQuery.expando);
				})();


				// We have to close these tags to support XHTML (#13200)
				var wrapMap = {
					option: [1, "<select multiple='multiple'>", "</select>"],
					legend: [1, "<fieldset>", "</fieldset>"],
					area: [1, "<map>", "</map>"],

					// Support: IE8
					param: [1, "<object>", "</object>"],
					thead: [1, "<table>", "</table>"],
					tr: [2, "<table><tbody>", "</tbody></table>"],
					col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
					td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

					// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
					// unless wrapped in a div with non-breaking characters in front of it.
					_default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
				};

				// Support: IE8-IE9
				wrapMap.optgroup = wrapMap.option;

				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;


				function getAll(context, tag) {
					var elems, elem,
						i = 0,
						found = typeof context.getElementsByTagName !== "undefined" ?
							context.getElementsByTagName(tag || "*") :
							typeof context.querySelectorAll !== "undefined" ?
								context.querySelectorAll(tag || "*") :
								undefined;

					if (!found) {
						for (found = [], elems = context.childNodes || context;
							(elem = elems[i]) != null;
							i++
						) {
							if (!tag || jQuery.nodeName(elem, tag)) {
								found.push(elem);
							} else {
								jQuery.merge(found, getAll(elem, tag));
							}
						}
					}

					return tag === undefined || tag && jQuery.nodeName(context, tag) ?
						jQuery.merge([context], found) :
						found;
				}


				// Mark scripts as having already been evaluated
				function setGlobalEval(elems, refElements) {
					var elem,
						i = 0;
					for (; (elem = elems[i]) != null; i++) {
						jQuery._data(
							elem,
							"globalEval",
							!refElements || jQuery._data(refElements[i], "globalEval")
						);
					}
				}


				var rhtml = /<|&#?\w+;/,
					rtbody = /<tbody/i;

				function fixDefaultChecked(elem) {
					if (rcheckableType.test(elem.type)) {
						elem.defaultChecked = elem.checked;
					}
				}

				function buildFragment(elems, context, scripts, selection, ignored) {
					var j, elem, contains,
						tmp, tag, tbody, wrap,
						l = elems.length,

						// Ensure a safe fragment
						safe = createSafeFragment(context),

						nodes = [],
						i = 0;

					for (; i < l; i++) {
						elem = elems[i];

						if (elem || elem === 0) {

							// Add nodes directly
							if (jQuery.type(elem) === "object") {
								jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

								// Convert non-html into a text node
							} else if (!rhtml.test(elem)) {
								nodes.push(context.createTextNode(elem));

								// Convert html into DOM nodes
							} else {
								tmp = tmp || safe.appendChild(context.createElement("div"));

								// Deserialize a standard representation
								tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
								wrap = wrapMap[tag] || wrapMap._default;

								tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

								// Descend through wrappers to the right content
								j = wrap[0];
								while (j--) {
									tmp = tmp.lastChild;
								}

								// Manually add leading whitespace removed by IE
								if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
									nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
								}

								// Remove IE's autoinserted <tbody> from table fragments
								if (!support.tbody) {

									// String was a <table>, *may* have spurious <tbody>
									elem = tag === "table" && !rtbody.test(elem) ?
										tmp.firstChild :

										// String was a bare <thead> or <tfoot>
										wrap[1] === "<table>" && !rtbody.test(elem) ?
											tmp :
											0;

									j = elem && elem.childNodes.length;
									while (j--) {
										if (jQuery.nodeName((tbody = elem.childNodes[j]), "tbody") &&
											!tbody.childNodes.length) {

											elem.removeChild(tbody);
										}
									}
								}

								jQuery.merge(nodes, tmp.childNodes);

								// Fix #12392 for WebKit and IE > 9
								tmp.textContent = "";

								// Fix #12392 for oldIE
								while (tmp.firstChild) {
									tmp.removeChild(tmp.firstChild);
								}

								// Remember the top-level container for proper cleanup
								tmp = safe.lastChild;
							}
						}
					}

					// Fix #11356: Clear elements from fragment
					if (tmp) {
						safe.removeChild(tmp);
					}

					// Reset defaultChecked for any radios and checkboxes
					// about to be appended to the DOM in IE 6/7 (#8060)
					if (!support.appendChecked) {
						jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
					}

					i = 0;
					while ((elem = nodes[i++])) {

						// Skip elements already in the context collection (trac-4087)
						if (selection && jQuery.inArray(elem, selection) > -1) {
							if (ignored) {
								ignored.push(elem);
							}

							continue;
						}

						contains = jQuery.contains(elem.ownerDocument, elem);

						// Append to fragment
						tmp = getAll(safe.appendChild(elem), "script");

						// Preserve script evaluation history
						if (contains) {
							setGlobalEval(tmp);
						}

						// Capture executables
						if (scripts) {
							j = 0;
							while ((elem = tmp[j++])) {
								if (rscriptType.test(elem.type || "")) {
									scripts.push(elem);
								}
							}
						}
					}

					tmp = null;

					return safe;
				}


				(function () {
					var i, eventName,
						div = document.createElement("div");

					// Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
					for (i in { submit: true, change: true, focusin: true }) {
						eventName = "on" + i;

						if (!(support[i] = eventName in window)) {

							// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
							div.setAttribute(eventName, "t");
							support[i] = div.attributes[eventName].expando === false;
						}
					}

					// Null elements to avoid leaks in IE.
					div = null;
				})();


				var rformElems = /^(?:input|select|textarea)$/i,
					rkeyEvent = /^key/,
					rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
					rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
					rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

				function returnTrue() {
					return true;
				}

				function returnFalse() {
					return false;
				}

				// Support: IE9
				// See #13393 for more info
				function safeActiveElement() {
					try {
						return document.activeElement;
					} catch (err) { }
				}

				function on(elem, types, selector, data, fn, one) {
					var origFn, type;

					// Types can be a map of types/handlers
					if (typeof types === "object") {

						// ( types-Object, selector, data )
						if (typeof selector !== "string") {

							// ( types-Object, data )
							data = data || selector;
							selector = undefined;
						}
						for (type in types) {
							on(elem, type, selector, data, types[type], one);
						}
						return elem;
					}

					if (data == null && fn == null) {

						// ( types, fn )
						fn = selector;
						data = selector = undefined;
					} else if (fn == null) {
						if (typeof selector === "string") {

							// ( types, selector, fn )
							fn = data;
							data = undefined;
						} else {

							// ( types, data, fn )
							fn = data;
							data = selector;
							selector = undefined;
						}
					}
					if (fn === false) {
						fn = returnFalse;
					} else if (!fn) {
						return elem;
					}

					if (one === 1) {
						origFn = fn;
						fn = function (event) {

							// Can use an empty set, since event contains the info
							jQuery().off(event);
							return origFn.apply(this, arguments);
						};

						// Use same guid so caller can remove using origFn
						fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
					}
					return elem.each(function () {
						jQuery.event.add(this, types, fn, data, selector);
					});
				}

				/*
				 * Helper functions for managing events -- not part of the public interface.
				 * Props to Dean Edwards' addEvent library for many of the ideas.
				 */
				jQuery.event = {

					global: {},

					add: function (elem, types, handler, data, selector) {
						var tmp, events, t, handleObjIn,
							special, eventHandle, handleObj,
							handlers, type, namespaces, origType,
							elemData = jQuery._data(elem);

						// Don't attach events to noData or text/comment nodes (but allow plain objects)
						if (!elemData) {
							return;
						}

						// Caller can pass in an object of custom data in lieu of the handler
						if (handler.handler) {
							handleObjIn = handler;
							handler = handleObjIn.handler;
							selector = handleObjIn.selector;
						}

						// Make sure that the handler has a unique ID, used to find/remove it later
						if (!handler.guid) {
							handler.guid = jQuery.guid++;
						}

						// Init the element's event structure and main handler, if this is the first
						if (!(events = elemData.events)) {
							events = elemData.events = {};
						}
						if (!(eventHandle = elemData.handle)) {
							eventHandle = elemData.handle = function (e) {

								// Discard the second event of a jQuery.event.trigger() and
								// when an event is called after a page has unloaded
								return typeof jQuery !== "undefined" &&
									(!e || jQuery.event.triggered !== e.type) ?
									jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
									undefined;
							};

							// Add elem as a property of the handle fn to prevent a memory leak
							// with IE non-native events
							eventHandle.elem = elem;
						}

						// Handle multiple events separated by a space
						types = (types || "").match(rnotwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort();

							// There *must* be a type, no attaching namespace-only handlers
							if (!type) {
								continue;
							}

							// If event changes its type, use the special event handlers for the changed type
							special = jQuery.event.special[type] || {};

							// If selector defined, determine special event api type, otherwise given type
							type = (selector ? special.delegateType : special.bindType) || type;

							// Update special based on newly reset type
							special = jQuery.event.special[type] || {};

							// handleObj is passed to all event handlers
							handleObj = jQuery.extend({
								type: type,
								origType: origType,
								data: data,
								handler: handler,
								guid: handler.guid,
								selector: selector,
								needsContext: selector && jQuery.expr.match.needsContext.test(selector),
								namespace: namespaces.join(".")
							}, handleObjIn);

							// Init the event handler queue if we're the first
							if (!(handlers = events[type])) {
								handlers = events[type] = [];
								handlers.delegateCount = 0;

								// Only use addEventListener/attachEvent if the special events handler returns false
								if (!special.setup ||
									special.setup.call(elem, data, namespaces, eventHandle) === false) {

									// Bind the global event handler to the element
									if (elem.addEventListener) {
										elem.addEventListener(type, eventHandle, false);

									} else if (elem.attachEvent) {
										elem.attachEvent("on" + type, eventHandle);
									}
								}
							}

							if (special.add) {
								special.add.call(elem, handleObj);

								if (!handleObj.handler.guid) {
									handleObj.handler.guid = handler.guid;
								}
							}

							// Add to the element's handler list, delegates in front
							if (selector) {
								handlers.splice(handlers.delegateCount++, 0, handleObj);
							} else {
								handlers.push(handleObj);
							}

							// Keep track of which events have ever been used, for event optimization
							jQuery.event.global[type] = true;
						}

						// Nullify elem to prevent memory leaks in IE
						elem = null;
					},

					// Detach an event or set of events from an element
					remove: function (elem, types, handler, selector, mappedTypes) {
						var j, handleObj, tmp,
							origCount, t, events,
							special, handlers, type,
							namespaces, origType,
							elemData = jQuery.hasData(elem) && jQuery._data(elem);

						if (!elemData || !(events = elemData.events)) {
							return;
						}

						// Once for each type.namespace in types; type may be omitted
						types = (types || "").match(rnotwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort();

							// Unbind all events (on this namespace, if provided) for the element
							if (!type) {
								for (type in events) {
									jQuery.event.remove(elem, type + types[t], handler, selector, true);
								}
								continue;
							}

							special = jQuery.event.special[type] || {};
							type = (selector ? special.delegateType : special.bindType) || type;
							handlers = events[type] || [];
							tmp = tmp[2] &&
								new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

							// Remove matching events
							origCount = j = handlers.length;
							while (j--) {
								handleObj = handlers[j];

								if ((mappedTypes || origType === handleObj.origType) &&
									(!handler || handler.guid === handleObj.guid) &&
									(!tmp || tmp.test(handleObj.namespace)) &&
									(!selector || selector === handleObj.selector ||
										selector === "**" && handleObj.selector)) {
									handlers.splice(j, 1);

									if (handleObj.selector) {
										handlers.delegateCount--;
									}
									if (special.remove) {
										special.remove.call(elem, handleObj);
									}
								}
							}

							// Remove generic event handler if we removed something and no more handlers exist
							// (avoids potential for endless recursion during removal of special event handlers)
							if (origCount && !handlers.length) {
								if (!special.teardown ||
									special.teardown.call(elem, namespaces, elemData.handle) === false) {

									jQuery.removeEvent(elem, type, elemData.handle);
								}

								delete events[type];
							}
						}

						// Remove the expando if it's no longer used
						if (jQuery.isEmptyObject(events)) {
							delete elemData.handle;

							// removeData also checks for emptiness and clears the expando if empty
							// so use it instead of delete
							jQuery._removeData(elem, "events");
						}
					},

					trigger: function (event, data, elem, onlyHandlers) {
						var handle, ontype, cur,
							bubbleType, special, tmp, i,
							eventPath = [elem || document],
							type = hasOwn.call(event, "type") ? event.type : event,
							namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

						cur = tmp = elem = elem || document;

						// Don't do events on text and comment nodes
						if (elem.nodeType === 3 || elem.nodeType === 8) {
							return;
						}

						// focus/blur morphs to focusin/out; ensure we're not firing them right now
						if (rfocusMorph.test(type + jQuery.event.triggered)) {
							return;
						}

						if (type.indexOf(".") > -1) {

							// Namespaced trigger; create a regexp to match event type in handle()
							namespaces = type.split(".");
							type = namespaces.shift();
							namespaces.sort();
						}
						ontype = type.indexOf(":") < 0 && "on" + type;

						// Caller can pass in a jQuery.Event object, Object, or just an event type string
						event = event[jQuery.expando] ?
							event :
							new jQuery.Event(type, typeof event === "object" && event);

						// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
						event.isTrigger = onlyHandlers ? 2 : 3;
						event.namespace = namespaces.join(".");
						event.rnamespace = event.namespace ?
							new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
							null;

						// Clean up the event in case it is being reused
						event.result = undefined;
						if (!event.target) {
							event.target = elem;
						}

						// Clone any incoming data and prepend the event, creating the handler arg list
						data = data == null ?
							[event] :
							jQuery.makeArray(data, [event]);

						// Allow special events to draw outside the lines
						special = jQuery.event.special[type] || {};
						if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
							return;
						}

						// Determine event propagation path in advance, per W3C events spec (#9951)
						// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
						if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

							bubbleType = special.delegateType || type;
							if (!rfocusMorph.test(bubbleType + type)) {
								cur = cur.parentNode;
							}
							for (; cur; cur = cur.parentNode) {
								eventPath.push(cur);
								tmp = cur;
							}

							// Only add window if we got to document (e.g., not plain obj or detached DOM)
							if (tmp === (elem.ownerDocument || document)) {
								eventPath.push(tmp.defaultView || tmp.parentWindow || window);
							}
						}

						// Fire handlers on the event path
						i = 0;
						while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

							event.type = i > 1 ?
								bubbleType :
								special.bindType || type;

							// jQuery handler
							handle = (jQuery._data(cur, "events") || {})[event.type] &&
								jQuery._data(cur, "handle");

							if (handle) {
								handle.apply(cur, data);
							}

							// Native handler
							handle = ontype && cur[ontype];
							if (handle && handle.apply && acceptData(cur)) {
								event.result = handle.apply(cur, data);
								if (event.result === false) {
									event.preventDefault();
								}
							}
						}
						event.type = type;

						// If nobody prevented the default action, do it now
						if (!onlyHandlers && !event.isDefaultPrevented()) {

							if (
								(!special._default ||
									special._default.apply(eventPath.pop(), data) === false
								) && acceptData(elem)
							) {

								// Call a native DOM method on the target with the same name name as the event.
								// Can't use an .isFunction() check here because IE6/7 fails that test.
								// Don't do default actions on window, that's where global variables be (#6170)
								if (ontype && elem[type] && !jQuery.isWindow(elem)) {

									// Don't re-trigger an onFOO event when we call its FOO() method
									tmp = elem[ontype];

									if (tmp) {
										elem[ontype] = null;
									}

									// Prevent re-triggering of the same event, since we already bubbled it above
									jQuery.event.triggered = type;
									try {
										elem[type]();
									} catch (e) {

										// IE<9 dies on focus/blur to hidden element (#1486,#12518)
										// only reproducible on winXP IE8 native, not IE9 in IE8 mode
									}
									jQuery.event.triggered = undefined;

									if (tmp) {
										elem[ontype] = tmp;
									}
								}
							}
						}

						return event.result;
					},

					dispatch: function (event) {

						// Make a writable jQuery.Event from the native event object
						event = jQuery.event.fix(event);

						var i, j, ret, matched, handleObj,
							handlerQueue = [],
							args = slice.call(arguments),
							handlers = (jQuery._data(this, "events") || {})[event.type] || [],
							special = jQuery.event.special[event.type] || {};

						// Use the fix-ed jQuery.Event rather than the (read-only) native event
						args[0] = event;
						event.delegateTarget = this;

						// Call the preDispatch hook for the mapped type, and let it bail if desired
						if (special.preDispatch && special.preDispatch.call(this, event) === false) {
							return;
						}

						// Determine handlers
						handlerQueue = jQuery.event.handlers.call(this, event, handlers);

						// Run delegates first; they may want to stop propagation beneath us
						i = 0;
						while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
							event.currentTarget = matched.elem;

							j = 0;
							while ((handleObj = matched.handlers[j++]) &&
								!event.isImmediatePropagationStopped()) {

								// Triggered event must either 1) have no namespace, or 2) have namespace(s)
								// a subset or equal to those in the bound event (both can have no namespace).
								if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

									event.handleObj = handleObj;
									event.data = handleObj.data;

									ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
										handleObj.handler).apply(matched.elem, args);

									if (ret !== undefined) {
										if ((event.result = ret) === false) {
											event.preventDefault();
											event.stopPropagation();
										}
									}
								}
							}
						}

						// Call the postDispatch hook for the mapped type
						if (special.postDispatch) {
							special.postDispatch.call(this, event);
						}

						return event.result;
					},

					handlers: function (event, handlers) {
						var i, matches, sel, handleObj,
							handlerQueue = [],
							delegateCount = handlers.delegateCount,
							cur = event.target;

						// Support (at least): Chrome, IE9
						// Find delegate handlers
						// Black-hole SVG <use> instance trees (#13180)
						//
						// Support: Firefox<=42+
						// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
						if (delegateCount && cur.nodeType &&
							(event.type !== "click" || isNaN(event.button) || event.button < 1)) {

							/* jshint eqeqeq: false */
							for (; cur != this; cur = cur.parentNode || this) {
								/* jshint eqeqeq: true */

								// Don't check non-elements (#13208)
								// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
								if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
									matches = [];
									for (i = 0; i < delegateCount; i++) {
										handleObj = handlers[i];

										// Don't conflict with Object.prototype properties (#13203)
										sel = handleObj.selector + " ";

										if (matches[sel] === undefined) {
											matches[sel] = handleObj.needsContext ?
												jQuery(sel, this).index(cur) > -1 :
												jQuery.find(sel, this, null, [cur]).length;
										}
										if (matches[sel]) {
											matches.push(handleObj);
										}
									}
									if (matches.length) {
										handlerQueue.push({ elem: cur, handlers: matches });
									}
								}
							}
						}

						// Add the remaining (directly-bound) handlers
						if (delegateCount < handlers.length) {
							handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
						}

						return handlerQueue;
					},

					fix: function (event) {
						if (event[jQuery.expando]) {
							return event;
						}

						// Create a writable copy of the event object and normalize some properties
						var i, prop, copy,
							type = event.type,
							originalEvent = event,
							fixHook = this.fixHooks[type];

						if (!fixHook) {
							this.fixHooks[type] = fixHook =
								rmouseEvent.test(type) ? this.mouseHooks :
									rkeyEvent.test(type) ? this.keyHooks :
										{};
						}
						copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

						event = new jQuery.Event(originalEvent);

						i = copy.length;
						while (i--) {
							prop = copy[i];
							event[prop] = originalEvent[prop];
						}

						// Support: IE<9
						// Fix target property (#1925)
						if (!event.target) {
							event.target = originalEvent.srcElement || document;
						}

						// Support: Safari 6-8+
						// Target should not be a text node (#504, #13143)
						if (event.target.nodeType === 3) {
							event.target = event.target.parentNode;
						}

						// Support: IE<9
						// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
						event.metaKey = !!event.metaKey;

						return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
					},

					// Includes some event props shared by KeyEvent and MouseEvent
					props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
						"metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

					fixHooks: {},

					keyHooks: {
						props: "char charCode key keyCode".split(" "),
						filter: function (event, original) {

							// Add which for key events
							if (event.which == null) {
								event.which = original.charCode != null ? original.charCode : original.keyCode;
							}

							return event;
						}
					},

					mouseHooks: {
						props: ("button buttons clientX clientY fromElement offsetX offsetY " +
							"pageX pageY screenX screenY toElement").split(" "),
						filter: function (event, original) {
							var body, eventDoc, doc,
								button = original.button,
								fromElement = original.fromElement;

							// Calculate pageX/Y if missing and clientX/Y available
							if (event.pageX == null && original.clientX != null) {
								eventDoc = event.target.ownerDocument || document;
								doc = eventDoc.documentElement;
								body = eventDoc.body;

								event.pageX = original.clientX +
									(doc && doc.scrollLeft || body && body.scrollLeft || 0) -
									(doc && doc.clientLeft || body && body.clientLeft || 0);
								event.pageY = original.clientY +
									(doc && doc.scrollTop || body && body.scrollTop || 0) -
									(doc && doc.clientTop || body && body.clientTop || 0);
							}

							// Add relatedTarget, if necessary
							if (!event.relatedTarget && fromElement) {
								event.relatedTarget = fromElement === event.target ?
									original.toElement :
									fromElement;
							}

							// Add which for click: 1 === left; 2 === middle; 3 === right
							// Note: button is not normalized, so don't use it
							if (!event.which && button !== undefined) {
								event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
							}

							return event;
						}
					},

					special: {
						load: {

							// Prevent triggered image.load events from bubbling to window.load
							noBubble: true
						},
						focus: {

							// Fire native event if possible so blur/focus sequence is correct
							trigger: function () {
								if (this !== safeActiveElement() && this.focus) {
									try {
										this.focus();
										return false;
									} catch (e) {

										// Support: IE<9
										// If we error on focus to hidden element (#1486, #12518),
										// let .trigger() run the handlers
									}
								}
							},
							delegateType: "focusin"
						},
						blur: {
							trigger: function () {
								if (this === safeActiveElement() && this.blur) {
									this.blur();
									return false;
								}
							},
							delegateType: "focusout"
						},
						click: {

							// For checkbox, fire native event so checked state will be right
							trigger: function () {
								if (jQuery.nodeName(this, "input") && this.type === "checkbox" && this.click) {
									this.click();
									return false;
								}
							},

							// For cross-browser consistency, don't fire native .click() on links
							_default: function (event) {
								return jQuery.nodeName(event.target, "a");
							}
						},

						beforeunload: {
							postDispatch: function (event) {

								// Support: Firefox 20+
								// Firefox doesn't alert if the returnValue field is not set.
								if (event.result !== undefined && event.originalEvent) {
									event.originalEvent.returnValue = event.result;
								}
							}
						}
					},

					// Piggyback on a donor event to simulate a different one
					simulate: function (type, elem, event) {
						var e = jQuery.extend(
							new jQuery.Event(),
							event,
							{
								type: type,
								isSimulated: true

								// Previously, `originalEvent: {}` was set here, so stopPropagation call
								// would not be triggered on donor event, since in our own
								// jQuery.event.stopPropagation function we had a check for existence of
								// originalEvent.stopPropagation method, so, consequently it would be a noop.
								//
								// Guard for simulated events was moved to jQuery.event.stopPropagation function
								// since `originalEvent` should point to the original event for the
								// constancy with other events and for more focused logic
							}
						);

						jQuery.event.trigger(e, null, elem);

						if (e.isDefaultPrevented()) {
							event.preventDefault();
						}
					}
				};

				jQuery.removeEvent = document.removeEventListener ?
					function (elem, type, handle) {

						// This "if" is needed for plain objects
						if (elem.removeEventListener) {
							elem.removeEventListener(type, handle);
						}
					} :
					function (elem, type, handle) {
						var name = "on" + type;

						if (elem.detachEvent) {

							// #8545, #7054, preventing memory leaks for custom events in IE6-8
							// detachEvent needed property on element, by name of that event,
							// to properly expose it to GC
							if (typeof elem[name] === "undefined") {
								elem[name] = null;
							}

							elem.detachEvent(name, handle);
						}
					};

				jQuery.Event = function (src, props) {

					// Allow instantiation without the 'new' keyword
					if (!(this instanceof jQuery.Event)) {
						return new jQuery.Event(src, props);
					}

					// Event object
					if (src && src.type) {
						this.originalEvent = src;
						this.type = src.type;

						// Events bubbling up the document may have been marked as prevented
						// by a handler lower down the tree; reflect the correct value.
						this.isDefaultPrevented = src.defaultPrevented ||
							src.defaultPrevented === undefined &&

							// Support: IE < 9, Android < 4.0
							src.returnValue === false ?
							returnTrue :
							returnFalse;

						// Event type
					} else {
						this.type = src;
					}

					// Put explicitly provided properties onto the event object
					if (props) {
						jQuery.extend(this, props);
					}

					// Create a timestamp if incoming event doesn't have one
					this.timeStamp = src && src.timeStamp || jQuery.now();

					// Mark it as fixed
					this[jQuery.expando] = true;
				};

				// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
				// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
				jQuery.Event.prototype = {
					constructor: jQuery.Event,
					isDefaultPrevented: returnFalse,
					isPropagationStopped: returnFalse,
					isImmediatePropagationStopped: returnFalse,

					preventDefault: function () {
						var e = this.originalEvent;

						this.isDefaultPrevented = returnTrue;
						if (!e) {
							return;
						}

						// If preventDefault exists, run it on the original event
						if (e.preventDefault) {
							e.preventDefault();

							// Support: IE
							// Otherwise set the returnValue property of the original event to false
						} else {
							e.returnValue = false;
						}
					},
					stopPropagation: function () {
						var e = this.originalEvent;

						this.isPropagationStopped = returnTrue;

						if (!e || this.isSimulated) {
							return;
						}

						// If stopPropagation exists, run it on the original event
						if (e.stopPropagation) {
							e.stopPropagation();
						}

						// Support: IE
						// Set the cancelBubble property of the original event to true
						e.cancelBubble = true;
					},
					stopImmediatePropagation: function () {
						var e = this.originalEvent;

						this.isImmediatePropagationStopped = returnTrue;

						if (e && e.stopImmediatePropagation) {
							e.stopImmediatePropagation();
						}

						this.stopPropagation();
					}
				};

				// Create mouseenter/leave events using mouseover/out and event-time checks
				// so that event delegation works in jQuery.
				// Do the same for pointerenter/pointerleave and pointerover/pointerout
				//
				// Support: Safari 7 only
				// Safari sends mouseenter too often; see:
				// https://code.google.com/p/chromium/issues/detail?id=470258
				// for the description of the bug (it existed in older Chrome versions as well).
				jQuery.each({
					mouseenter: "mouseover",
					mouseleave: "mouseout",
					pointerenter: "pointerover",
					pointerleave: "pointerout"
				}, function (orig, fix) {
					jQuery.event.special[orig] = {
						delegateType: fix,
						bindType: fix,

						handle: function (event) {
							var ret,
								target = this,
								related = event.relatedTarget,
								handleObj = event.handleObj;

							// For mouseenter/leave call the handler if related is outside the target.
							// NB: No relatedTarget if the mouse left/entered the browser window
							if (!related || (related !== target && !jQuery.contains(target, related))) {
								event.type = handleObj.origType;
								ret = handleObj.handler.apply(this, arguments);
								event.type = fix;
							}
							return ret;
						}
					};
				});

				// IE submit delegation
				if (!support.submit) {

					jQuery.event.special.submit = {
						setup: function () {

							// Only need this for delegated form submit events
							if (jQuery.nodeName(this, "form")) {
								return false;
							}

							// Lazy-add a submit handler when a descendant form may potentially be submitted
							jQuery.event.add(this, "click._submit keypress._submit", function (e) {

								// Node name check avoids a VML-related crash in IE (#9807)
								var elem = e.target,
									form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ?

										// Support: IE <=8
										// We use jQuery.prop instead of elem.form
										// to allow fixing the IE8 delegated submit issue (gh-2332)
										// by 3rd party polyfills/workarounds.
										jQuery.prop(elem, "form") :
										undefined;

								if (form && !jQuery._data(form, "submit")) {
									jQuery.event.add(form, "submit._submit", function (event) {
										event._submitBubble = true;
									});
									jQuery._data(form, "submit", true);
								}
							});

							// return undefined since we don't need an event listener
						},

						postDispatch: function (event) {

							// If form was submitted by the user, bubble the event up the tree
							if (event._submitBubble) {
								delete event._submitBubble;
								if (this.parentNode && !event.isTrigger) {
									jQuery.event.simulate("submit", this.parentNode, event);
								}
							}
						},

						teardown: function () {

							// Only need this for delegated form submit events
							if (jQuery.nodeName(this, "form")) {
								return false;
							}

							// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
							jQuery.event.remove(this, "._submit");
						}
					};
				}

				// IE change delegation and checkbox/radio fix
				if (!support.change) {

					jQuery.event.special.change = {

						setup: function () {

							if (rformElems.test(this.nodeName)) {

								// IE doesn't fire change on a check/radio until blur; trigger it on click
								// after a propertychange. Eat the blur-change in special.change.handle.
								// This still fires onchange a second time for check/radio after blur.
								if (this.type === "checkbox" || this.type === "radio") {
									jQuery.event.add(this, "propertychange._change", function (event) {
										if (event.originalEvent.propertyName === "checked") {
											this._justChanged = true;
										}
									});
									jQuery.event.add(this, "click._change", function (event) {
										if (this._justChanged && !event.isTrigger) {
											this._justChanged = false;
										}

										// Allow triggered, simulated change events (#11500)
										jQuery.event.simulate("change", this, event);
									});
								}
								return false;
							}

							// Delegated event; lazy-add a change handler on descendant inputs
							jQuery.event.add(this, "beforeactivate._change", function (e) {
								var elem = e.target;

								if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "change")) {
									jQuery.event.add(elem, "change._change", function (event) {
										if (this.parentNode && !event.isSimulated && !event.isTrigger) {
											jQuery.event.simulate("change", this.parentNode, event);
										}
									});
									jQuery._data(elem, "change", true);
								}
							});
						},

						handle: function (event) {
							var elem = event.target;

							// Swallow native change events from checkbox/radio, we already triggered them above
							if (this !== elem || event.isSimulated || event.isTrigger ||
								(elem.type !== "radio" && elem.type !== "checkbox")) {

								return event.handleObj.handler.apply(this, arguments);
							}
						},

						teardown: function () {
							jQuery.event.remove(this, "._change");

							return !rformElems.test(this.nodeName);
						}
					};
				}

				// Support: Firefox
				// Firefox doesn't have focus(in | out) events
				// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
				//
				// Support: Chrome, Safari
				// focus(in | out) events fire after focus & blur events,
				// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
				// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
				if (!support.focusin) {
					jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

						// Attach a single capturing handler on the document while someone wants focusin/focusout
						var handler = function (event) {
							jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
						};

						jQuery.event.special[fix] = {
							setup: function () {
								var doc = this.ownerDocument || this,
									attaches = jQuery._data(doc, fix);

								if (!attaches) {
									doc.addEventListener(orig, handler, true);
								}
								jQuery._data(doc, fix, (attaches || 0) + 1);
							},
							teardown: function () {
								var doc = this.ownerDocument || this,
									attaches = jQuery._data(doc, fix) - 1;

								if (!attaches) {
									doc.removeEventListener(orig, handler, true);
									jQuery._removeData(doc, fix);
								} else {
									jQuery._data(doc, fix, attaches);
								}
							}
						};
					});
				}

				jQuery.fn.extend({

					on: function (types, selector, data, fn) {
						return on(this, types, selector, data, fn);
					},
					one: function (types, selector, data, fn) {
						return on(this, types, selector, data, fn, 1);
					},
					off: function (types, selector, fn) {
						var handleObj, type;
						if (types && types.preventDefault && types.handleObj) {

							// ( event )  dispatched jQuery.Event
							handleObj = types.handleObj;
							jQuery(types.delegateTarget).off(
								handleObj.namespace ?
									handleObj.origType + "." + handleObj.namespace :
									handleObj.origType,
								handleObj.selector,
								handleObj.handler
							);
							return this;
						}
						if (typeof types === "object") {

							// ( types-object [, selector] )
							for (type in types) {
								this.off(type, selector, types[type]);
							}
							return this;
						}
						if (selector === false || typeof selector === "function") {

							// ( types [, fn] )
							fn = selector;
							selector = undefined;
						}
						if (fn === false) {
							fn = returnFalse;
						}
						return this.each(function () {
							jQuery.event.remove(this, types, fn, selector);
						});
					},

					trigger: function (type, data) {
						return this.each(function () {
							jQuery.event.trigger(type, data, this);
						});
					},
					triggerHandler: function (type, data) {
						var elem = this[0];
						if (elem) {
							return jQuery.event.trigger(type, data, elem, true);
						}
					}
				});


				var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
					rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
					rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

					// Support: IE 10-11, Edge 10240+
					// In IE/Edge using regex groups here causes severe slowdowns.
					// See https://connect.microsoft.com/IE/feedback/details/1736512/
					rnoInnerhtml = /<script|<style|<link/i,

					// checked="checked" or checked
					rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
					rscriptTypeMasked = /^true\/(.*)/,
					rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
					safeFragment = createSafeFragment(document),
					fragmentDiv = safeFragment.appendChild(document.createElement("div"));

				// Support: IE<8
				// Manipulating tables requires a tbody
				function manipulationTarget(elem, content) {
					return jQuery.nodeName(elem, "table") &&
						jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

						elem.getElementsByTagName("tbody")[0] ||
						elem.appendChild(elem.ownerDocument.createElement("tbody")) :
						elem;
				}

				// Replace/restore the type attribute of script elements for safe DOM manipulation
				function disableScript(elem) {
					elem.type = (jQuery.find.attr(elem, "type") !== null) + "/" + elem.type;
					return elem;
				}
				function restoreScript(elem) {
					var match = rscriptTypeMasked.exec(elem.type);
					if (match) {
						elem.type = match[1];
					} else {
						elem.removeAttribute("type");
					}
					return elem;
				}

				function cloneCopyEvent(src, dest) {
					if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
						return;
					}

					var type, i, l,
						oldData = jQuery._data(src),
						curData = jQuery._data(dest, oldData),
						events = oldData.events;

					if (events) {
						delete curData.handle;
						curData.events = {};

						for (type in events) {
							for (i = 0, l = events[type].length; i < l; i++) {
								jQuery.event.add(dest, type, events[type][i]);
							}
						}
					}

					// make the cloned public data object a copy from the original
					if (curData.data) {
						curData.data = jQuery.extend({}, curData.data);
					}
				}

				function fixCloneNodeIssues(src, dest) {
					var nodeName, e, data;

					// We do not need to do anything for non-Elements
					if (dest.nodeType !== 1) {
						return;
					}

					nodeName = dest.nodeName.toLowerCase();

					// IE6-8 copies events bound via attachEvent when using cloneNode.
					if (!support.noCloneEvent && dest[jQuery.expando]) {
						data = jQuery._data(dest);

						for (e in data.events) {
							jQuery.removeEvent(dest, e, data.handle);
						}

						// Event data gets referenced instead of copied if the expando gets copied too
						dest.removeAttribute(jQuery.expando);
					}

					// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
					if (nodeName === "script" && dest.text !== src.text) {
						disableScript(dest).text = src.text;
						restoreScript(dest);

						// IE6-10 improperly clones children of object elements using classid.
						// IE10 throws NoModificationAllowedError if parent is null, #12132.
					} else if (nodeName === "object") {
						if (dest.parentNode) {
							dest.outerHTML = src.outerHTML;
						}

						// This path appears unavoidable for IE9. When cloning an object
						// element in IE9, the outerHTML strategy above is not sufficient.
						// If the src has innerHTML and the destination does not,
						// copy the src.innerHTML into the dest.innerHTML. #10324
						if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
							dest.innerHTML = src.innerHTML;
						}

					} else if (nodeName === "input" && rcheckableType.test(src.type)) {

						// IE6-8 fails to persist the checked state of a cloned checkbox
						// or radio button. Worse, IE6-7 fail to give the cloned element
						// a checked appearance if the defaultChecked value isn't also set

						dest.defaultChecked = dest.checked = src.checked;

						// IE6-7 get confused and end up setting the value of a cloned
						// checkbox/radio button to an empty string instead of "on"
						if (dest.value !== src.value) {
							dest.value = src.value;
						}

						// IE6-8 fails to return the selected option to the default selected
						// state when cloning options
					} else if (nodeName === "option") {
						dest.defaultSelected = dest.selected = src.defaultSelected;

						// IE6-8 fails to set the defaultValue to the correct value when
						// cloning other types of input fields
					} else if (nodeName === "input" || nodeName === "textarea") {
						dest.defaultValue = src.defaultValue;
					}
				}

				function domManip(collection, args, callback, ignored) {

					// Flatten any nested arrays
					args = concat.apply([], args);

					var first, node, hasScripts,
						scripts, doc, fragment,
						i = 0,
						l = collection.length,
						iNoClone = l - 1,
						value = args[0],
						isFunction = jQuery.isFunction(value);

					// We can't cloneNode fragments that contain checked, in WebKit
					if (isFunction ||
						(l > 1 && typeof value === "string" &&
							!support.checkClone && rchecked.test(value))) {
						return collection.each(function (index) {
							var self = collection.eq(index);
							if (isFunction) {
								args[0] = value.call(this, index, self.html());
							}
							domManip(self, args, callback, ignored);
						});
					}

					if (l) {
						fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
						first = fragment.firstChild;

						if (fragment.childNodes.length === 1) {
							fragment = first;
						}

						// Require either new content or an interest in ignored elements to invoke the callback
						if (first || ignored) {
							scripts = jQuery.map(getAll(fragment, "script"), disableScript);
							hasScripts = scripts.length;

							// Use the original fragment for the last item
							// instead of the first because it can end up
							// being emptied incorrectly in certain situations (#8070).
							for (; i < l; i++) {
								node = fragment;

								if (i !== iNoClone) {
									node = jQuery.clone(node, true, true);

									// Keep references to cloned scripts for later restoration
									if (hasScripts) {

										// Support: Android<4.1, PhantomJS<2
										// push.apply(_, arraylike) throws on ancient WebKit
										jQuery.merge(scripts, getAll(node, "script"));
									}
								}

								callback.call(collection[i], node, i);
							}

							if (hasScripts) {
								doc = scripts[scripts.length - 1].ownerDocument;

								// Reenable scripts
								jQuery.map(scripts, restoreScript);

								// Evaluate executable scripts on first document insertion
								for (i = 0; i < hasScripts; i++) {
									node = scripts[i];
									if (rscriptType.test(node.type || "") &&
										!jQuery._data(node, "globalEval") &&
										jQuery.contains(doc, node)) {

										if (node.src) {

											// Optional AJAX dependency, but won't run scripts if not present
											if (jQuery._evalUrl) {
												jQuery._evalUrl(node.src);
											}
										} else {
											jQuery.globalEval(
												(node.text || node.textContent || node.innerHTML || "")
													.replace(rcleanScript, "")
											);
										}
									}
								}
							}

							// Fix #11809: Avoid leaking memory
							fragment = first = null;
						}
					}

					return collection;
				}

				function remove(elem, selector, keepData) {
					var node,
						elems = selector ? jQuery.filter(selector, elem) : elem,
						i = 0;

					for (; (node = elems[i]) != null; i++) {

						if (!keepData && node.nodeType === 1) {
							jQuery.cleanData(getAll(node));
						}

						if (node.parentNode) {
							if (keepData && jQuery.contains(node.ownerDocument, node)) {
								setGlobalEval(getAll(node, "script"));
							}
							node.parentNode.removeChild(node);
						}
					}

					return elem;
				}

				jQuery.extend({
					htmlPrefilter: function (html) {
						return html.replace(rxhtmlTag, "<$1></$2>");
					},

					clone: function (elem, dataAndEvents, deepDataAndEvents) {
						var destElements, node, clone, i, srcElements,
							inPage = jQuery.contains(elem.ownerDocument, elem);

						if (support.html5Clone || jQuery.isXMLDoc(elem) ||
							!rnoshimcache.test("<" + elem.nodeName + ">")) {

							clone = elem.cloneNode(true);

							// IE<=8 does not properly clone detached, unknown element nodes
						} else {
							fragmentDiv.innerHTML = elem.outerHTML;
							fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
						}

						if ((!support.noCloneEvent || !support.noCloneChecked) &&
							(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

							// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
							destElements = getAll(clone);
							srcElements = getAll(elem);

							// Fix all IE cloning issues
							for (i = 0; (node = srcElements[i]) != null; ++i) {

								// Ensure that the destination node is not null; Fixes #9587
								if (destElements[i]) {
									fixCloneNodeIssues(node, destElements[i]);
								}
							}
						}

						// Copy the events from the original to the clone
						if (dataAndEvents) {
							if (deepDataAndEvents) {
								srcElements = srcElements || getAll(elem);
								destElements = destElements || getAll(clone);

								for (i = 0; (node = srcElements[i]) != null; i++) {
									cloneCopyEvent(node, destElements[i]);
								}
							} else {
								cloneCopyEvent(elem, clone);
							}
						}

						// Preserve script evaluation history
						destElements = getAll(clone, "script");
						if (destElements.length > 0) {
							setGlobalEval(destElements, !inPage && getAll(elem, "script"));
						}

						destElements = srcElements = node = null;

						// Return the cloned set
						return clone;
					},

					cleanData: function (elems, /* internal */ forceAcceptData) {
						var elem, type, id, data,
							i = 0,
							internalKey = jQuery.expando,
							cache = jQuery.cache,
							attributes = support.attributes,
							special = jQuery.event.special;

						for (; (elem = elems[i]) != null; i++) {
							if (forceAcceptData || acceptData(elem)) {

								id = elem[internalKey];
								data = id && cache[id];

								if (data) {
									if (data.events) {
										for (type in data.events) {
											if (special[type]) {
												jQuery.event.remove(elem, type);

												// This is a shortcut to avoid jQuery.event.remove's overhead
											} else {
												jQuery.removeEvent(elem, type, data.handle);
											}
										}
									}

									// Remove cache only if it was not already removed by jQuery.event.remove
									if (cache[id]) {

										delete cache[id];

										// Support: IE<9
										// IE does not allow us to delete expando properties from nodes
										// IE creates expando attributes along with the property
										// IE does not have a removeAttribute function on Document nodes
										if (!attributes && typeof elem.removeAttribute !== "undefined") {
											elem.removeAttribute(internalKey);

											// Webkit & Blink performance suffers when deleting properties
											// from DOM nodes, so set to undefined instead
											// https://code.google.com/p/chromium/issues/detail?id=378607
										} else {
											elem[internalKey] = undefined;
										}

										deletedIds.push(id);
									}
								}
							}
						}
					}
				});

				jQuery.fn.extend({

					// Keep domManip exposed until 3.0 (gh-2225)
					domManip: domManip,

					detach: function (selector) {
						return remove(this, selector, true);
					},

					remove: function (selector) {
						return remove(this, selector);
					},

					text: function (value) {
						return access(this, function (value) {
							return value === undefined ?
								jQuery.text(this) :
								this.empty().append(
									(this[0] && this[0].ownerDocument || document).createTextNode(value)
								);
						}, null, value, arguments.length);
					},

					append: function () {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.appendChild(elem);
							}
						});
					},

					prepend: function () {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.insertBefore(elem, target.firstChild);
							}
						});
					},

					before: function () {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this);
							}
						});
					},

					after: function () {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this.nextSibling);
							}
						});
					},

					empty: function () {
						var elem,
							i = 0;

						for (; (elem = this[i]) != null; i++) {

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
							}

							// Remove any remaining nodes
							while (elem.firstChild) {
								elem.removeChild(elem.firstChild);
							}

							// If this is a select, ensure that it displays empty (#12336)
							// Support: IE<9
							if (elem.options && jQuery.nodeName(elem, "select")) {
								elem.options.length = 0;
							}
						}

						return this;
					},

					clone: function (dataAndEvents, deepDataAndEvents) {
						dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
						deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

						return this.map(function () {
							return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
						});
					},

					html: function (value) {
						return access(this, function (value) {
							var elem = this[0] || {},
								i = 0,
								l = this.length;

							if (value === undefined) {
								return elem.nodeType === 1 ?
									elem.innerHTML.replace(rinlinejQuery, "") :
									undefined;
							}

							// See if we can take a shortcut and just use innerHTML
							if (typeof value === "string" && !rnoInnerhtml.test(value) &&
								(support.htmlSerialize || !rnoshimcache.test(value)) &&
								(support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
								!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

								value = jQuery.htmlPrefilter(value);

								try {
									for (; i < l; i++) {

										// Remove element nodes and prevent memory leaks
										elem = this[i] || {};
										if (elem.nodeType === 1) {
											jQuery.cleanData(getAll(elem, false));
											elem.innerHTML = value;
										}
									}

									elem = 0;

									// If using innerHTML throws an exception, use the fallback method
								} catch (e) { }
							}

							if (elem) {
								this.empty().append(value);
							}
						}, null, value, arguments.length);
					},

					replaceWith: function () {
						var ignored = [];

						// Make the changes, replacing each non-ignored context element with the new content
						return domManip(this, arguments, function (elem) {
							var parent = this.parentNode;

							if (jQuery.inArray(this, ignored) < 0) {
								jQuery.cleanData(getAll(this));
								if (parent) {
									parent.replaceChild(elem, this);
								}
							}

							// Force callback invocation
						}, ignored);
					}
				});

				jQuery.each({
					appendTo: "append",
					prependTo: "prepend",
					insertBefore: "before",
					insertAfter: "after",
					replaceAll: "replaceWith"
				}, function (name, original) {
					jQuery.fn[name] = function (selector) {
						var elems,
							i = 0,
							ret = [],
							insert = jQuery(selector),
							last = insert.length - 1;

						for (; i <= last; i++) {
							elems = i === last ? this : this.clone(true);
							jQuery(insert[i])[original](elems);

							// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
							push.apply(ret, elems.get());
						}

						return this.pushStack(ret);
					};
				});


				var iframe,
					elemdisplay = {

						// Support: Firefox
						// We have to pre-define these values for FF (#10227)
						HTML: "block",
						BODY: "block"
					};

				/**
				 * Retrieve the actual display of a element
				 * @param {String} name nodeName of the element
				 * @param {Object} doc Document object
				 */

				// Called only from within defaultDisplay
				function actualDisplay(name, doc) {
					var elem = jQuery(doc.createElement(name)).appendTo(doc.body),

						display = jQuery.css(elem[0], "display");

					// We don't have any data stored on the element,
					// so use "detach" method as fast way to get rid of the element
					elem.detach();

					return display;
				}

				/**
				 * Try to determine the default display value of an element
				 * @param {String} nodeName
				 */
				function defaultDisplay(nodeName) {
					var doc = document,
						display = elemdisplay[nodeName];

					if (!display) {
						display = actualDisplay(nodeName, doc);

						// If the simple way fails, read from inside an iframe
						if (display === "none" || !display) {

							// Use the already-created iframe if possible
							iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>"))
								.appendTo(doc.documentElement);

							// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
							doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;

							// Support: IE
							doc.write();
							doc.close();

							display = actualDisplay(nodeName, doc);
							iframe.detach();
						}

						// Store the correct default display
						elemdisplay[nodeName] = display;
					}

					return display;
				}
				var rmargin = (/^margin/);

				var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

				var swap = function (elem, options, callback, args) {
					var ret, name,
						old = {};

					// Remember the old values, and insert the new ones
					for (name in options) {
						old[name] = elem.style[name];
						elem.style[name] = options[name];
					}

					ret = callback.apply(elem, args || []);

					// Revert the old values
					for (name in options) {
						elem.style[name] = old[name];
					}

					return ret;
				};


				var documentElement = document.documentElement;



				(function () {
					var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,
						reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,
						container = document.createElement("div"),
						div = document.createElement("div");

					// Finish early in limited (non-browser) environments
					if (!div.style) {
						return;
					}

					div.style.cssText = "float:left;opacity:.5";

					// Support: IE<9
					// Make sure that element opacity exists (as opposed to filter)
					support.opacity = div.style.opacity === "0.5";

					// Verify style float existence
					// (IE uses styleFloat instead of cssFloat)
					support.cssFloat = !!div.style.cssFloat;

					div.style.backgroundClip = "content-box";
					div.cloneNode(true).style.backgroundClip = "";
					support.clearCloneStyle = div.style.backgroundClip === "content-box";

					container = document.createElement("div");
					container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
						"padding:0;margin-top:1px;position:absolute";
					div.innerHTML = "";
					container.appendChild(div);

					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||
						div.style.WebkitBoxSizing === "";

					jQuery.extend(support, {
						reliableHiddenOffsets: function () {
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return reliableHiddenOffsetsVal;
						},

						boxSizingReliable: function () {

							// We're checking for pixelPositionVal here instead of boxSizingReliableVal
							// since that compresses better and they're computed together anyway.
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return boxSizingReliableVal;
						},

						pixelMarginRight: function () {

							// Support: Android 4.0-4.3
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return pixelMarginRightVal;
						},

						pixelPosition: function () {
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return pixelPositionVal;
						},

						reliableMarginRight: function () {

							// Support: Android 2.3
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return reliableMarginRightVal;
						},

						reliableMarginLeft: function () {

							// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
							if (pixelPositionVal == null) {
								computeStyleTests();
							}
							return reliableMarginLeftVal;
						}
					});

					function computeStyleTests() {
						var contents, divStyle,
							documentElement = document.documentElement;

						// Setup
						documentElement.appendChild(container);

						div.style.cssText =

							// Support: Android 2.3
							// Vendor-prefix box-sizing
							"-webkit-box-sizing:border-box;box-sizing:border-box;" +
							"position:relative;display:block;" +
							"margin:auto;border:1px;padding:1px;" +
							"top:1%;width:50%";

						// Support: IE<9
						// Assume reasonable values in the absence of getComputedStyle
						pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
						pixelMarginRightVal = reliableMarginRightVal = true;

						// Check for getComputedStyle so that this code is not run in IE<9.
						if (window.getComputedStyle) {
							divStyle = window.getComputedStyle(div);
							pixelPositionVal = (divStyle || {}).top !== "1%";
							reliableMarginLeftVal = (divStyle || {}).marginLeft === "2px";
							boxSizingReliableVal = (divStyle || { width: "4px" }).width === "4px";

							// Support: Android 4.0 - 4.3 only
							// Some styles come back with percentage values, even though they shouldn't
							div.style.marginRight = "50%";
							pixelMarginRightVal = (divStyle || { marginRight: "4px" }).marginRight === "4px";

							// Support: Android 2.3 only
							// Div with explicit width and no margin-right incorrectly
							// gets computed margin-right based on width of container (#3333)
							// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
							contents = div.appendChild(document.createElement("div"));

							// Reset CSS: box-sizing; display; margin; border; padding
							contents.style.cssText = div.style.cssText =

								// Support: Android 2.3
								// Vendor-prefix box-sizing
								"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
								"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
							contents.style.marginRight = contents.style.width = "0";
							div.style.width = "1px";

							reliableMarginRightVal =
								!parseFloat((window.getComputedStyle(contents) || {}).marginRight);

							div.removeChild(contents);
						}

						// Support: IE6-8
						// First check that getClientRects works as expected
						// Check if table cells still have offsetWidth/Height when they are set
						// to display:none and there are still other visible table cells in a
						// table row; if so, offsetWidth/Height are not reliable for use when
						// determining if an element has been hidden directly using
						// display:none (it is still safe to use offsets if a parent element is
						// hidden; don safety goggles and see bug #4512 for more information).
						div.style.display = "none";
						reliableHiddenOffsetsVal = div.getClientRects().length === 0;
						if (reliableHiddenOffsetsVal) {
							div.style.display = "";
							div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
							div.childNodes[0].style.borderCollapse = "separate";
							contents = div.getElementsByTagName("td");
							contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
							reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
							if (reliableHiddenOffsetsVal) {
								contents[0].style.display = "";
								contents[1].style.display = "none";
								reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
							}
						}

						// Teardown
						documentElement.removeChild(container);
					}

				})();


				var getStyles, curCSS,
					rposition = /^(top|right|bottom|left)$/;

				if (window.getComputedStyle) {
					getStyles = function (elem) {

						// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
						// IE throws on elements created in popups
						// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
						var view = elem.ownerDocument.defaultView;

						if (!view || !view.opener) {
							view = window;
						}

						return view.getComputedStyle(elem);
					};

					curCSS = function (elem, name, computed) {
						var width, minWidth, maxWidth, ret,
							style = elem.style;

						computed = computed || getStyles(elem);

						// getPropertyValue is only needed for .css('filter') in IE9, see #12537
						ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

						// Support: Opera 12.1x only
						// Fall back to style even without computed
						// computed is undefined for elems on document fragments
						if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
							ret = jQuery.style(elem, name);
						}

						if (computed) {

							// A tribute to the "awesome hack by Dean Edwards"
							// Chrome < 17 and Safari 5.0 uses "computed value"
							// instead of "used value" for margin-right
							// Safari 5.1.7 (at least) returns percentage for a larger set of values,
							// but width seems to be reliably pixels
							// this is against the CSSOM draft spec:
							// http://dev.w3.org/csswg/cssom/#resolved-values
							if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

								// Remember the original values
								width = style.width;
								minWidth = style.minWidth;
								maxWidth = style.maxWidth;

								// Put in the new values to get a computed value out
								style.minWidth = style.maxWidth = style.width = ret;
								ret = computed.width;

								// Revert the changed values
								style.width = width;
								style.minWidth = minWidth;
								style.maxWidth = maxWidth;
							}
						}

						// Support: IE
						// IE returns zIndex value as an integer.
						return ret === undefined ?
							ret :
							ret + "";
					};
				} else if (documentElement.currentStyle) {
					getStyles = function (elem) {
						return elem.currentStyle;
					};

					curCSS = function (elem, name, computed) {
						var left, rs, rsLeft, ret,
							style = elem.style;

						computed = computed || getStyles(elem);
						ret = computed ? computed[name] : undefined;

						// Avoid setting ret to empty string here
						// so we don't default to auto
						if (ret == null && style && style[name]) {
							ret = style[name];
						}

						// From the awesome hack by Dean Edwards
						// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

						// If we're not dealing with a regular pixel number
						// but a number that has a weird ending, we need to convert it to pixels
						// but not position css attributes, as those are
						// proportional to the parent element instead
						// and we can't measure the parent instead because it
						// might trigger a "stacking dolls" problem
						if (rnumnonpx.test(ret) && !rposition.test(name)) {

							// Remember the original values
							left = style.left;
							rs = elem.runtimeStyle;
							rsLeft = rs && rs.left;

							// Put in the new values to get a computed value out
							if (rsLeft) {
								rs.left = elem.currentStyle.left;
							}
							style.left = name === "fontSize" ? "1em" : ret;
							ret = style.pixelLeft + "px";

							// Revert the changed values
							style.left = left;
							if (rsLeft) {
								rs.left = rsLeft;
							}
						}

						// Support: IE
						// IE returns zIndex value as an integer.
						return ret === undefined ?
							ret :
							ret + "" || "auto";
					};
				}




				function addGetHookIf(conditionFn, hookFn) {

					// Define the hook, we'll check on the first run if it's really needed.
					return {
						get: function () {
							if (conditionFn()) {

								// Hook not needed (or it's not possible to use it due
								// to missing dependency), remove it.
								delete this.get;
								return;
							}

							// Hook needed; redefine it so that the support test is not executed again.
							return (this.get = hookFn).apply(this, arguments);
						}
					};
				}


				var

					ralpha = /alpha\([^)]*\)/i,
					ropacity = /opacity\s*=\s*([^)]*)/i,

					// swappable if display is none or starts with table except
					// "table", "table-cell", or "table-caption"
					// see here for display values:
					// https://developer.mozilla.org/en-US/docs/CSS/display
					rdisplayswap = /^(none|table(?!-c[ea]).+)/,
					rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),

					cssShow = { position: "absolute", visibility: "hidden", display: "block" },
					cssNormalTransform = {
						letterSpacing: "0",
						fontWeight: "400"
					},

					cssPrefixes = ["Webkit", "O", "Moz", "ms"],
					emptyStyle = document.createElement("div").style;


				// return a css property mapped to a potentially vendor prefixed property
				function vendorPropName(name) {

					// shortcut for names that are not vendor prefixed
					if (name in emptyStyle) {
						return name;
					}

					// check for vendor prefixed names
					var capName = name.charAt(0).toUpperCase() + name.slice(1),
						i = cssPrefixes.length;

					while (i--) {
						name = cssPrefixes[i] + capName;
						if (name in emptyStyle) {
							return name;
						}
					}
				}

				function showHide(elements, show) {
					var display, elem, hidden,
						values = [],
						index = 0,
						length = elements.length;

					for (; index < length; index++) {
						elem = elements[index];
						if (!elem.style) {
							continue;
						}

						values[index] = jQuery._data(elem, "olddisplay");
						display = elem.style.display;
						if (show) {

							// Reset the inline display of this element to learn if it is
							// being hidden by cascaded rules or not
							if (!values[index] && display === "none") {
								elem.style.display = "";
							}

							// Set elements which have been overridden with display: none
							// in a stylesheet to whatever the default browser style is
							// for such an element
							if (elem.style.display === "" && isHidden(elem)) {
								values[index] =
									jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
							}
						} else {
							hidden = isHidden(elem);

							if (display && display !== "none" || !hidden) {
								jQuery._data(
									elem,
									"olddisplay",
									hidden ? display : jQuery.css(elem, "display")
								);
							}
						}
					}

					// Set the display of most of the elements in a second loop
					// to avoid the constant reflow
					for (index = 0; index < length; index++) {
						elem = elements[index];
						if (!elem.style) {
							continue;
						}
						if (!show || elem.style.display === "none" || elem.style.display === "") {
							elem.style.display = show ? values[index] || "" : "none";
						}
					}

					return elements;
				}

				function setPositiveNumber(elem, value, subtract) {
					var matches = rnumsplit.exec(value);
					return matches ?

						// Guard against undefined "subtract", e.g., when used as in cssHooks
						Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
						value;
				}

				function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
					var i = extra === (isBorderBox ? "border" : "content") ?

						// If we already have the right measurement, avoid augmentation
						4 :

						// Otherwise initialize for horizontal or vertical properties
						name === "width" ? 1 : 0,

						val = 0;

					for (; i < 4; i += 2) {

						// both box models exclude margin, so add it if we want it
						if (extra === "margin") {
							val += jQuery.css(elem, extra + cssExpand[i], true, styles);
						}

						if (isBorderBox) {

							// border-box includes padding, so remove it if we want content
							if (extra === "content") {
								val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
							}

							// at this point, extra isn't border nor margin, so remove border
							if (extra !== "margin") {
								val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						} else {

							// at this point, extra isn't content, so add padding
							val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

							// at this point, extra isn't content nor padding, so add border
							if (extra !== "padding") {
								val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						}
					}

					return val;
				}

				function getWidthOrHeight(elem, name, extra) {

					// Start with offset property, which is equivalent to the border-box value
					var valueIsBorderBox = true,
						val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
						styles = getStyles(elem),
						isBorderBox = support.boxSizing &&
							jQuery.css(elem, "boxSizing", false, styles) === "border-box";

					// some non-html elements return undefined for offsetWidth, so check for null/undefined
					// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
					// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
					if (val <= 0 || val == null) {

						// Fall back to computed then uncomputed css if necessary
						val = curCSS(elem, name, styles);
						if (val < 0 || val == null) {
							val = elem.style[name];
						}

						// Computed unit is not pixels. Stop here and return.
						if (rnumnonpx.test(val)) {
							return val;
						}

						// we need the check for style in case a browser which returns unreliable values
						// for getComputedStyle silently falls back to the reliable elem.style
						valueIsBorderBox = isBorderBox &&
							(support.boxSizingReliable() || val === elem.style[name]);

						// Normalize "", auto, and prepare for extra
						val = parseFloat(val) || 0;
					}

					// use the active box-sizing model to add/subtract irrelevant styles
					return (val +
						augmentWidthOrHeight(
							elem,
							name,
							extra || (isBorderBox ? "border" : "content"),
							valueIsBorderBox,
							styles
						)
					) + "px";
				}

				jQuery.extend({

					// Add in style property hooks for overriding the default
					// behavior of getting and setting a style property
					cssHooks: {
						opacity: {
							get: function (elem, computed) {
								if (computed) {

									// We should always get a number back from opacity
									var ret = curCSS(elem, "opacity");
									return ret === "" ? "1" : ret;
								}
							}
						}
					},

					// Don't automatically add "px" to these possibly-unitless properties
					cssNumber: {
						"animationIterationCount": true,
						"columnCount": true,
						"fillOpacity": true,
						"flexGrow": true,
						"flexShrink": true,
						"fontWeight": true,
						"lineHeight": true,
						"opacity": true,
						"order": true,
						"orphans": true,
						"widows": true,
						"zIndex": true,
						"zoom": true
					},

					// Add in properties whose names you wish to fix before
					// setting or getting the value
					cssProps: {

						// normalize float css property
						"float": support.cssFloat ? "cssFloat" : "styleFloat"
					},

					// Get and set the style property on a DOM Node
					style: function (elem, name, value, extra) {

						// Don't set styles on text and comment nodes
						if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
							return;
						}

						// Make sure that we're working with the right name
						var ret, type, hooks,
							origName = jQuery.camelCase(name),
							style = elem.style;

						name = jQuery.cssProps[origName] ||
							(jQuery.cssProps[origName] = vendorPropName(origName) || origName);

						// gets hook for the prefixed version
						// followed by the unprefixed version
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

						// Check if we're setting a value
						if (value !== undefined) {
							type = typeof value;

							// Convert "+=" or "-=" to relative numbers (#7345)
							if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
								value = adjustCSS(elem, name, ret);

								// Fixes bug #9237
								type = "number";
							}

							// Make sure that null and NaN values aren't set. See: #7116
							if (value == null || value !== value) {
								return;
							}

							// If a number was passed in, add the unit (except for certain CSS properties)
							if (type === "number") {
								value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
							}

							// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
							// but it would mean to define eight
							// (for every problematic property) identical functions
							if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
								style[name] = "inherit";
							}

							// If a hook was provided, use that value, otherwise just set the specified value
							if (!hooks || !("set" in hooks) ||
								(value = hooks.set(elem, value, extra)) !== undefined) {

								// Support: IE
								// Swallow errors from 'invalid' CSS values (#5509)
								try {
									style[name] = value;
								} catch (e) { }
							}

						} else {

							// If a hook was provided get the non-computed value from there
							if (hooks && "get" in hooks &&
								(ret = hooks.get(elem, false, extra)) !== undefined) {

								return ret;
							}

							// Otherwise just get the value from the style object
							return style[name];
						}
					},

					css: function (elem, name, extra, styles) {
						var num, val, hooks,
							origName = jQuery.camelCase(name);

						// Make sure that we're working with the right name
						name = jQuery.cssProps[origName] ||
							(jQuery.cssProps[origName] = vendorPropName(origName) || origName);

						// gets hook for the prefixed version
						// followed by the unprefixed version
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

						// If a hook was provided get the computed value from there
						if (hooks && "get" in hooks) {
							val = hooks.get(elem, true, extra);
						}

						// Otherwise, if a way to get the computed value exists, use that
						if (val === undefined) {
							val = curCSS(elem, name, styles);
						}

						//convert "normal" to computed value
						if (val === "normal" && name in cssNormalTransform) {
							val = cssNormalTransform[name];
						}

						// Return, converting to number if forced or a qualifier was provided and val looks numeric
						if (extra === "" || extra) {
							num = parseFloat(val);
							return extra === true || isFinite(num) ? num || 0 : val;
						}
						return val;
					}
				});

				jQuery.each(["height", "width"], function (i, name) {
					jQuery.cssHooks[name] = {
						get: function (elem, computed, extra) {
							if (computed) {

								// certain elements can have dimension info if we invisibly show them
								// however, it must have a current display style that would benefit from this
								return rdisplayswap.test(jQuery.css(elem, "display")) &&
									elem.offsetWidth === 0 ?
									swap(elem, cssShow, function () {
										return getWidthOrHeight(elem, name, extra);
									}) :
									getWidthOrHeight(elem, name, extra);
							}
						},

						set: function (elem, value, extra) {
							var styles = extra && getStyles(elem);
							return setPositiveNumber(elem, value, extra ?
								augmentWidthOrHeight(
									elem,
									name,
									extra,
									support.boxSizing &&
									jQuery.css(elem, "boxSizing", false, styles) === "border-box",
									styles
								) : 0
							);
						}
					};
				});

				if (!support.opacity) {
					jQuery.cssHooks.opacity = {
						get: function (elem, computed) {

							// IE uses filters for opacity
							return ropacity.test((computed && elem.currentStyle ?
								elem.currentStyle.filter :
								elem.style.filter) || "") ?
								(0.01 * parseFloat(RegExp.$1)) + "" :
								computed ? "1" : "";
						},

						set: function (elem, value) {
							var style = elem.style,
								currentStyle = elem.currentStyle,
								opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
								filter = currentStyle && currentStyle.filter || style.filter || "";

							// IE has trouble with opacity if it does not have layout
							// Force it by setting the zoom level
							style.zoom = 1;

							// if setting opacity to 1, and no other filters exist -
							// attempt to remove filter attribute #6652
							// if value === "", then remove inline opacity #12685
							if ((value >= 1 || value === "") &&
								jQuery.trim(filter.replace(ralpha, "")) === "" &&
								style.removeAttribute) {

								// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
								// if "filter:" is present at all, clearType is disabled, we want to avoid this
								// style.removeAttribute is IE Only, but so apparently is this code path...
								style.removeAttribute("filter");

								// if there is no filter style applied in a css rule
								// or unset inline opacity, we are done
								if (value === "" || currentStyle && !currentStyle.filter) {
									return;
								}
							}

							// otherwise, set new filter values
							style.filter = ralpha.test(filter) ?
								filter.replace(ralpha, opacity) :
								filter + " " + opacity;
						}
					};
				}

				jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
					function (elem, computed) {
						if (computed) {
							return swap(elem, { "display": "inline-block" },
								curCSS, [elem, "marginRight"]);
						}
					}
				);

				jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
					function (elem, computed) {
						if (computed) {
							return (
								parseFloat(curCSS(elem, "marginLeft")) ||

								// Support: IE<=11+
								// Running getBoundingClientRect on a disconnected node in IE throws an error
								// Support: IE8 only
								// getClientRects() errors on disconnected elems
								(jQuery.contains(elem.ownerDocument, elem) ?
									elem.getBoundingClientRect().left -
									swap(elem, { marginLeft: 0 }, function () {
										return elem.getBoundingClientRect().left;
									}) :
									0
								)
							) + "px";
						}
					}
				);

				// These hooks are used by animate to expand properties
				jQuery.each({
					margin: "",
					padding: "",
					border: "Width"
				}, function (prefix, suffix) {
					jQuery.cssHooks[prefix + suffix] = {
						expand: function (value) {
							var i = 0,
								expanded = {},

								// assumes a single number if not a string
								parts = typeof value === "string" ? value.split(" ") : [value];

							for (; i < 4; i++) {
								expanded[prefix + cssExpand[i] + suffix] =
									parts[i] || parts[i - 2] || parts[0];
							}

							return expanded;
						}
					};

					if (!rmargin.test(prefix)) {
						jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
					}
				});

				jQuery.fn.extend({
					css: function (name, value) {
						return access(this, function (elem, name, value) {
							var styles, len,
								map = {},
								i = 0;

							if (jQuery.isArray(name)) {
								styles = getStyles(elem);
								len = name.length;

								for (; i < len; i++) {
									map[name[i]] = jQuery.css(elem, name[i], false, styles);
								}

								return map;
							}

							return value !== undefined ?
								jQuery.style(elem, name, value) :
								jQuery.css(elem, name);
						}, name, value, arguments.length > 1);
					},
					show: function () {
						return showHide(this, true);
					},
					hide: function () {
						return showHide(this);
					},
					toggle: function (state) {
						if (typeof state === "boolean") {
							return state ? this.show() : this.hide();
						}

						return this.each(function () {
							if (isHidden(this)) {
								jQuery(this).show();
							} else {
								jQuery(this).hide();
							}
						});
					}
				});


				function Tween(elem, options, prop, end, easing) {
					return new Tween.prototype.init(elem, options, prop, end, easing);
				}
				jQuery.Tween = Tween;

				Tween.prototype = {
					constructor: Tween,
					init: function (elem, options, prop, end, easing, unit) {
						this.elem = elem;
						this.prop = prop;
						this.easing = easing || jQuery.easing._default;
						this.options = options;
						this.start = this.now = this.cur();
						this.end = end;
						this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
					},
					cur: function () {
						var hooks = Tween.propHooks[this.prop];

						return hooks && hooks.get ?
							hooks.get(this) :
							Tween.propHooks._default.get(this);
					},
					run: function (percent) {
						var eased,
							hooks = Tween.propHooks[this.prop];

						if (this.options.duration) {
							this.pos = eased = jQuery.easing[this.easing](
								percent, this.options.duration * percent, 0, 1, this.options.duration
							);
						} else {
							this.pos = eased = percent;
						}
						this.now = (this.end - this.start) * eased + this.start;

						if (this.options.step) {
							this.options.step.call(this.elem, this.now, this);
						}

						if (hooks && hooks.set) {
							hooks.set(this);
						} else {
							Tween.propHooks._default.set(this);
						}
						return this;
					}
				};

				Tween.prototype.init.prototype = Tween.prototype;

				Tween.propHooks = {
					_default: {
						get: function (tween) {
							var result;

							// Use a property on the element directly when it is not a DOM element,
							// or when there is no matching style property that exists.
							if (tween.elem.nodeType !== 1 ||
								tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
								return tween.elem[tween.prop];
							}

							// passing an empty string as a 3rd parameter to .css will automatically
							// attempt a parseFloat and fallback to a string if the parse fails
							// so, simple values such as "10px" are parsed to Float.
							// complex values such as "rotate(1rad)" are returned as is.
							result = jQuery.css(tween.elem, tween.prop, "");

							// Empty strings, null, undefined and "auto" are converted to 0.
							return !result || result === "auto" ? 0 : result;
						},
						set: function (tween) {

							// use step hook for back compat - use cssHook if its there - use .style if its
							// available and use plain properties where available
							if (jQuery.fx.step[tween.prop]) {
								jQuery.fx.step[tween.prop](tween);
							} else if (tween.elem.nodeType === 1 &&
								(tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
									jQuery.cssHooks[tween.prop])) {
								jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
							} else {
								tween.elem[tween.prop] = tween.now;
							}
						}
					}
				};

				// Support: IE <=9
				// Panic based approach to setting things on disconnected nodes

				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
					set: function (tween) {
						if (tween.elem.nodeType && tween.elem.parentNode) {
							tween.elem[tween.prop] = tween.now;
						}
					}
				};

				jQuery.easing = {
					linear: function (p) {
						return p;
					},
					swing: function (p) {
						return 0.5 - Math.cos(p * Math.PI) / 2;
					},
					_default: "swing"
				};

				jQuery.fx = Tween.prototype.init;

				// Back Compat <1.8 extension point
				jQuery.fx.step = {};




				var
					fxNow, timerId,
					rfxtypes = /^(?:toggle|show|hide)$/,
					rrun = /queueHooks$/;

				// Animations created synchronously will run synchronously
				function createFxNow() {
					window.setTimeout(function () {
						fxNow = undefined;
					});
					return (fxNow = jQuery.now());
				}

				// Generate parameters to create a standard animation
				function genFx(type, includeWidth) {
					var which,
						attrs = { height: type },
						i = 0;

					// if we include width, step value is 1 to do all cssExpand values,
					// if we don't include width, step value is 2 to skip over Left and Right
					includeWidth = includeWidth ? 1 : 0;
					for (; i < 4; i += 2 - includeWidth) {
						which = cssExpand[i];
						attrs["margin" + which] = attrs["padding" + which] = type;
					}

					if (includeWidth) {
						attrs.opacity = attrs.width = type;
					}

					return attrs;
				}

				function createTween(value, prop, animation) {
					var tween,
						collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
						index = 0,
						length = collection.length;
					for (; index < length; index++) {
						if ((tween = collection[index].call(animation, prop, value))) {

							// we're done with this property
							return tween;
						}
					}
				}

				function defaultPrefilter(elem, props, opts) {
					/* jshint validthis: true */
					var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
						anim = this,
						orig = {},
						style = elem.style,
						hidden = elem.nodeType && isHidden(elem),
						dataShow = jQuery._data(elem, "fxshow");

					// handle queue: false promises
					if (!opts.queue) {
						hooks = jQuery._queueHooks(elem, "fx");
						if (hooks.unqueued == null) {
							hooks.unqueued = 0;
							oldfire = hooks.empty.fire;
							hooks.empty.fire = function () {
								if (!hooks.unqueued) {
									oldfire();
								}
							};
						}
						hooks.unqueued++;

						anim.always(function () {

							// doing this makes sure that the complete handler will be called
							// before this completes
							anim.always(function () {
								hooks.unqueued--;
								if (!jQuery.queue(elem, "fx").length) {
									hooks.empty.fire();
								}
							});
						});
					}

					// height/width overflow pass
					if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

						// Make sure that nothing sneaks out
						// Record all 3 overflow attributes because IE does not
						// change the overflow attribute when overflowX and
						// overflowY are set to the same value
						opts.overflow = [style.overflow, style.overflowX, style.overflowY];

						// Set display property to inline-block for height/width
						// animations on inline elements that are having width/height animated
						display = jQuery.css(elem, "display");

						// Test default display if display is currently "none"
						checkDisplay = display === "none" ?
							jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

						if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === "inline") {
								style.display = "inline-block";
							} else {
								style.zoom = 1;
							}
						}
					}

					if (opts.overflow) {
						style.overflow = "hidden";
						if (!support.shrinkWrapBlocks()) {
							anim.always(function () {
								style.overflow = opts.overflow[0];
								style.overflowX = opts.overflow[1];
								style.overflowY = opts.overflow[2];
							});
						}
					}

					// show/hide pass
					for (prop in props) {
						value = props[prop];
						if (rfxtypes.exec(value)) {
							delete props[prop];
							toggle = toggle || value === "toggle";
							if (value === (hidden ? "hide" : "show")) {

								// If there is dataShow left over from a stopped hide or show
								// and we are going to proceed with show, we should pretend to be hidden
								if (value === "show" && dataShow && dataShow[prop] !== undefined) {
									hidden = true;
								} else {
									continue;
								}
							}
							orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

							// Any non-fx value stops us from restoring the original display value
						} else {
							display = undefined;
						}
					}

					if (!jQuery.isEmptyObject(orig)) {
						if (dataShow) {
							if ("hidden" in dataShow) {
								hidden = dataShow.hidden;
							}
						} else {
							dataShow = jQuery._data(elem, "fxshow", {});
						}

						// store state if its toggle - enables .stop().toggle() to "reverse"
						if (toggle) {
							dataShow.hidden = !hidden;
						}
						if (hidden) {
							jQuery(elem).show();
						} else {
							anim.done(function () {
								jQuery(elem).hide();
							});
						}
						anim.done(function () {
							var prop;
							jQuery._removeData(elem, "fxshow");
							for (prop in orig) {
								jQuery.style(elem, prop, orig[prop]);
							}
						});
						for (prop in orig) {
							tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

							if (!(prop in dataShow)) {
								dataShow[prop] = tween.start;
								if (hidden) {
									tween.end = tween.start;
									tween.start = prop === "width" || prop === "height" ? 1 : 0;
								}
							}
						}

						// If this is a noop like .hide().hide(), restore an overwritten display value
					} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
						style.display = display;
					}
				}

				function propFilter(props, specialEasing) {
					var index, name, easing, value, hooks;

					// camelCase, specialEasing and expand cssHook pass
					for (index in props) {
						name = jQuery.camelCase(index);
						easing = specialEasing[name];
						value = props[index];
						if (jQuery.isArray(value)) {
							easing = value[1];
							value = props[index] = value[0];
						}

						if (index !== name) {
							props[name] = value;
							delete props[index];
						}

						hooks = jQuery.cssHooks[name];
						if (hooks && "expand" in hooks) {
							value = hooks.expand(value);
							delete props[name];

							// not quite $.extend, this wont overwrite keys already present.
							// also - reusing 'index' from above because we have the correct "name"
							for (index in value) {
								if (!(index in props)) {
									props[index] = value[index];
									specialEasing[index] = easing;
								}
							}
						} else {
							specialEasing[name] = easing;
						}
					}
				}

				function Animation(elem, properties, options) {
					var result,
						stopped,
						index = 0,
						length = Animation.prefilters.length,
						deferred = jQuery.Deferred().always(function () {

							// don't match elem in the :animated selector
							delete tick.elem;
						}),
						tick = function () {
							if (stopped) {
								return false;
							}
							var currentTime = fxNow || createFxNow(),
								remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

								// Support: Android 2.3
								// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
								temp = remaining / animation.duration || 0,
								percent = 1 - temp,
								index = 0,
								length = animation.tweens.length;

							for (; index < length; index++) {
								animation.tweens[index].run(percent);
							}

							deferred.notifyWith(elem, [animation, percent, remaining]);

							if (percent < 1 && length) {
								return remaining;
							} else {
								deferred.resolveWith(elem, [animation]);
								return false;
							}
						},
						animation = deferred.promise({
							elem: elem,
							props: jQuery.extend({}, properties),
							opts: jQuery.extend(true, {
								specialEasing: {},
								easing: jQuery.easing._default
							}, options),
							originalProperties: properties,
							originalOptions: options,
							startTime: fxNow || createFxNow(),
							duration: options.duration,
							tweens: [],
							createTween: function (prop, end) {
								var tween = jQuery.Tween(elem, animation.opts, prop, end,
									animation.opts.specialEasing[prop] || animation.opts.easing);
								animation.tweens.push(tween);
								return tween;
							},
							stop: function (gotoEnd) {
								var index = 0,

									// if we are going to the end, we want to run all the tweens
									// otherwise we skip this part
									length = gotoEnd ? animation.tweens.length : 0;
								if (stopped) {
									return this;
								}
								stopped = true;
								for (; index < length; index++) {
									animation.tweens[index].run(1);
								}

								// resolve when we played the last frame
								// otherwise, reject
								if (gotoEnd) {
									deferred.notifyWith(elem, [animation, 1, 0]);
									deferred.resolveWith(elem, [animation, gotoEnd]);
								} else {
									deferred.rejectWith(elem, [animation, gotoEnd]);
								}
								return this;
							}
						}),
						props = animation.props;

					propFilter(props, animation.opts.specialEasing);

					for (; index < length; index++) {
						result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
						if (result) {
							if (jQuery.isFunction(result.stop)) {
								jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
									jQuery.proxy(result.stop, result);
							}
							return result;
						}
					}

					jQuery.map(props, createTween, animation);

					if (jQuery.isFunction(animation.opts.start)) {
						animation.opts.start.call(elem, animation);
					}

					jQuery.fx.timer(
						jQuery.extend(tick, {
							elem: elem,
							anim: animation,
							queue: animation.opts.queue
						})
					);

					// attach callbacks from options
					return animation.progress(animation.opts.progress)
						.done(animation.opts.done, animation.opts.complete)
						.fail(animation.opts.fail)
						.always(animation.opts.always);
				}

				jQuery.Animation = jQuery.extend(Animation, {

					tweeners: {
						"*": [function (prop, value) {
							var tween = this.createTween(prop, value);
							adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
							return tween;
						}]
					},

					tweener: function (props, callback) {
						if (jQuery.isFunction(props)) {
							callback = props;
							props = ["*"];
						} else {
							props = props.match(rnotwhite);
						}

						var prop,
							index = 0,
							length = props.length;

						for (; index < length; index++) {
							prop = props[index];
							Animation.tweeners[prop] = Animation.tweeners[prop] || [];
							Animation.tweeners[prop].unshift(callback);
						}
					},

					prefilters: [defaultPrefilter],

					prefilter: function (callback, prepend) {
						if (prepend) {
							Animation.prefilters.unshift(callback);
						} else {
							Animation.prefilters.push(callback);
						}
					}
				});

				jQuery.speed = function (speed, easing, fn) {
					var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
						complete: fn || !fn && easing ||
							jQuery.isFunction(speed) && speed,
						duration: speed,
						easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
					};

					opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
						opt.duration in jQuery.fx.speeds ?
							jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

					// normalize opt.queue - true/undefined/null -> "fx"
					if (opt.queue == null || opt.queue === true) {
						opt.queue = "fx";
					}

					// Queueing
					opt.old = opt.complete;

					opt.complete = function () {
						if (jQuery.isFunction(opt.old)) {
							opt.old.call(this);
						}

						if (opt.queue) {
							jQuery.dequeue(this, opt.queue);
						}
					};

					return opt;
				};

				jQuery.fn.extend({
					fadeTo: function (speed, to, easing, callback) {

						// show any hidden elements after setting opacity to 0
						return this.filter(isHidden).css("opacity", 0).show()

							// animate to the value specified
							.end().animate({ opacity: to }, speed, easing, callback);
					},
					animate: function (prop, speed, easing, callback) {
						var empty = jQuery.isEmptyObject(prop),
							optall = jQuery.speed(speed, easing, callback),
							doAnimation = function () {

								// Operate on a copy of prop so per-property easing won't be lost
								var anim = Animation(this, jQuery.extend({}, prop), optall);

								// Empty animations, or finishing resolves immediately
								if (empty || jQuery._data(this, "finish")) {
									anim.stop(true);
								}
							};
						doAnimation.finish = doAnimation;

						return empty || optall.queue === false ?
							this.each(doAnimation) :
							this.queue(optall.queue, doAnimation);
					},
					stop: function (type, clearQueue, gotoEnd) {
						var stopQueue = function (hooks) {
							var stop = hooks.stop;
							delete hooks.stop;
							stop(gotoEnd);
						};

						if (typeof type !== "string") {
							gotoEnd = clearQueue;
							clearQueue = type;
							type = undefined;
						}
						if (clearQueue && type !== false) {
							this.queue(type || "fx", []);
						}

						return this.each(function () {
							var dequeue = true,
								index = type != null && type + "queueHooks",
								timers = jQuery.timers,
								data = jQuery._data(this);

							if (index) {
								if (data[index] && data[index].stop) {
									stopQueue(data[index]);
								}
							} else {
								for (index in data) {
									if (data[index] && data[index].stop && rrun.test(index)) {
										stopQueue(data[index]);
									}
								}
							}

							for (index = timers.length; index--;) {
								if (timers[index].elem === this &&
									(type == null || timers[index].queue === type)) {

									timers[index].anim.stop(gotoEnd);
									dequeue = false;
									timers.splice(index, 1);
								}
							}

							// start the next in the queue if the last step wasn't forced
							// timers currently will call their complete callbacks, which will dequeue
							// but only if they were gotoEnd
							if (dequeue || !gotoEnd) {
								jQuery.dequeue(this, type);
							}
						});
					},
					finish: function (type) {
						if (type !== false) {
							type = type || "fx";
						}
						return this.each(function () {
							var index,
								data = jQuery._data(this),
								queue = data[type + "queue"],
								hooks = data[type + "queueHooks"],
								timers = jQuery.timers,
								length = queue ? queue.length : 0;

							// enable finishing flag on private data
							data.finish = true;

							// empty the queue first
							jQuery.queue(this, type, []);

							if (hooks && hooks.stop) {
								hooks.stop.call(this, true);
							}

							// look for any active animations, and finish them
							for (index = timers.length; index--;) {
								if (timers[index].elem === this && timers[index].queue === type) {
									timers[index].anim.stop(true);
									timers.splice(index, 1);
								}
							}

							// look for any animations in the old queue and finish them
							for (index = 0; index < length; index++) {
								if (queue[index] && queue[index].finish) {
									queue[index].finish.call(this);
								}
							}

							// turn off finishing flag
							delete data.finish;
						});
					}
				});

				jQuery.each(["toggle", "show", "hide"], function (i, name) {
					var cssFn = jQuery.fn[name];
					jQuery.fn[name] = function (speed, easing, callback) {
						return speed == null || typeof speed === "boolean" ?
							cssFn.apply(this, arguments) :
							this.animate(genFx(name, true), speed, easing, callback);
					};
				});

				// Generate shortcuts for custom animations
				jQuery.each({
					slideDown: genFx("show"),
					slideUp: genFx("hide"),
					slideToggle: genFx("toggle"),
					fadeIn: { opacity: "show" },
					fadeOut: { opacity: "hide" },
					fadeToggle: { opacity: "toggle" }
				}, function (name, props) {
					jQuery.fn[name] = function (speed, easing, callback) {
						return this.animate(props, speed, easing, callback);
					};
				});

				jQuery.timers = [];
				jQuery.fx.tick = function () {
					var timer,
						timers = jQuery.timers,
						i = 0;

					fxNow = jQuery.now();

					for (; i < timers.length; i++) {
						timer = timers[i];

						// Checks the timer has not already been removed
						if (!timer() && timers[i] === timer) {
							timers.splice(i--, 1);
						}
					}

					if (!timers.length) {
						jQuery.fx.stop();
					}
					fxNow = undefined;
				};

				jQuery.fx.timer = function (timer) {
					jQuery.timers.push(timer);
					if (timer()) {
						jQuery.fx.start();
					} else {
						jQuery.timers.pop();
					}
				};

				jQuery.fx.interval = 13;

				jQuery.fx.start = function () {
					if (!timerId) {
						timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
					}
				};

				jQuery.fx.stop = function () {
					window.clearInterval(timerId);
					timerId = null;
				};

				jQuery.fx.speeds = {
					slow: 600,
					fast: 200,

					// Default speed
					_default: 400
				};


				// Based off of the plugin by Clint Helfers, with permission.
				// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
				jQuery.fn.delay = function (time, type) {
					time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
					type = type || "fx";

					return this.queue(type, function (next, hooks) {
						var timeout = window.setTimeout(next, time);
						hooks.stop = function () {
							window.clearTimeout(timeout);
						};
					});
				};


				(function () {
					var a,
						input = document.createElement("input"),
						div = document.createElement("div"),
						select = document.createElement("select"),
						opt = select.appendChild(document.createElement("option"));

					// Setup
					div = document.createElement("div");
					div.setAttribute("className", "t");
					div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
					a = div.getElementsByTagName("a")[0];

					// Support: Windows Web Apps (WWA)
					// `type` must use .setAttribute for WWA (#14901)
					input.setAttribute("type", "checkbox");
					div.appendChild(input);

					a = div.getElementsByTagName("a")[0];

					// First batch of tests.
					a.style.cssText = "top:1px";

					// Test setAttribute on camelCase class.
					// If it works, we need attrFixes when doing get/setAttribute (ie6/7)
					support.getSetAttribute = div.className !== "t";

					// Get the style information from getAttribute
					// (IE uses .cssText instead)
					support.style = /top/.test(a.getAttribute("style"));

					// Make sure that URLs aren't manipulated
					// (IE normalizes it by default)
					support.hrefNormalized = a.getAttribute("href") === "/a";

					// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
					support.checkOn = !!input.value;

					// Make sure that a selected-by-default option has a working selected property.
					// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
					support.optSelected = opt.selected;

					// Tests for enctype support on a form (#6743)
					support.enctype = !!document.createElement("form").enctype;

					// Make sure that the options inside disabled selects aren't marked as disabled
					// (WebKit marks them as disabled)
					select.disabled = true;
					support.optDisabled = !opt.disabled;

					// Support: IE8 only
					// Check if we can trust getAttribute("value")
					input = document.createElement("input");
					input.setAttribute("value", "");
					support.input = input.getAttribute("value") === "";

					// Check if an input maintains its value after becoming a radio
					input.value = "t";
					input.setAttribute("type", "radio");
					support.radioValue = input.value === "t";
				})();


				var rreturn = /\r/g,
					rspaces = /[\x20\t\r\n\f]+/g;

				jQuery.fn.extend({
					val: function (value) {
						var hooks, ret, isFunction,
							elem = this[0];

						if (!arguments.length) {
							if (elem) {
								hooks = jQuery.valHooks[elem.type] ||
									jQuery.valHooks[elem.nodeName.toLowerCase()];

								if (
									hooks &&
									"get" in hooks &&
									(ret = hooks.get(elem, "value")) !== undefined
								) {
									return ret;
								}

								ret = elem.value;

								return typeof ret === "string" ?

									// handle most common string cases
									ret.replace(rreturn, "") :

									// handle cases where value is null/undef or number
									ret == null ? "" : ret;
							}

							return;
						}

						isFunction = jQuery.isFunction(value);

						return this.each(function (i) {
							var val;

							if (this.nodeType !== 1) {
								return;
							}

							if (isFunction) {
								val = value.call(this, i, jQuery(this).val());
							} else {
								val = value;
							}

							// Treat null/undefined as ""; convert numbers to string
							if (val == null) {
								val = "";
							} else if (typeof val === "number") {
								val += "";
							} else if (jQuery.isArray(val)) {
								val = jQuery.map(val, function (value) {
									return value == null ? "" : value + "";
								});
							}

							hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

							// If set returns undefined, fall back to normal setting
							if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
								this.value = val;
							}
						});
					}
				});

				jQuery.extend({
					valHooks: {
						option: {
							get: function (elem) {
								var val = jQuery.find.attr(elem, "value");
								return val != null ?
									val :

									// Support: IE10-11+
									// option.text throws exceptions (#14686, #14858)
									// Strip and collapse whitespace
									// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
									jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
							}
						},
						select: {
							get: function (elem) {
								var value, option,
									options = elem.options,
									index = elem.selectedIndex,
									one = elem.type === "select-one" || index < 0,
									values = one ? null : [],
									max = one ? index + 1 : options.length,
									i = index < 0 ?
										max :
										one ? index : 0;

								// Loop through all the selected options
								for (; i < max; i++) {
									option = options[i];

									// oldIE doesn't update selected after form reset (#2551)
									if ((option.selected || i === index) &&

										// Don't return options that are disabled or in a disabled optgroup
										(support.optDisabled ?
											!option.disabled :
											option.getAttribute("disabled") === null) &&
										(!option.parentNode.disabled ||
											!jQuery.nodeName(option.parentNode, "optgroup"))) {

										// Get the specific value for the option
										value = jQuery(option).val();

										// We don't need an array for one selects
										if (one) {
											return value;
										}

										// Multi-Selects return an array
										values.push(value);
									}
								}

								return values;
							},

							set: function (elem, value) {
								var optionSet, option,
									options = elem.options,
									values = jQuery.makeArray(value),
									i = options.length;

								while (i--) {
									option = options[i];

									if (jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {

										// Support: IE6
										// When new option element is added to select box we need to
										// force reflow of newly added node in order to workaround delay
										// of initialization properties
										try {
											option.selected = optionSet = true;

										} catch (_) {

											// Will be executed only in IE6
											option.scrollHeight;
										}

									} else {
										option.selected = false;
									}
								}

								// Force browsers to behave consistently when non-matching value is set
								if (!optionSet) {
									elem.selectedIndex = -1;
								}

								return options;
							}
						}
					}
				});

				// Radios and checkboxes getter/setter
				jQuery.each(["radio", "checkbox"], function () {
					jQuery.valHooks[this] = {
						set: function (elem, value) {
							if (jQuery.isArray(value)) {
								return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
							}
						}
					};
					if (!support.checkOn) {
						jQuery.valHooks[this].get = function (elem) {
							return elem.getAttribute("value") === null ? "on" : elem.value;
						};
					}
				});




				var nodeHook, boolHook,
					attrHandle = jQuery.expr.attrHandle,
					ruseDefault = /^(?:checked|selected)$/i,
					getSetAttribute = support.getSetAttribute,
					getSetInput = support.input;

				jQuery.fn.extend({
					attr: function (name, value) {
						return access(this, jQuery.attr, name, value, arguments.length > 1);
					},

					removeAttr: function (name) {
						return this.each(function () {
							jQuery.removeAttr(this, name);
						});
					}
				});

				jQuery.extend({
					attr: function (elem, name, value) {
						var ret, hooks,
							nType = elem.nodeType;

						// Don't get/set attributes on text, comment and attribute nodes
						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						}

						// Fallback to prop when attributes are not supported
						if (typeof elem.getAttribute === "undefined") {
							return jQuery.prop(elem, name, value);
						}

						// All attributes are lowercase
						// Grab necessary hook if one is defined
						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
							name = name.toLowerCase();
							hooks = jQuery.attrHooks[name] ||
								(jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
						}

						if (value !== undefined) {
							if (value === null) {
								jQuery.removeAttr(elem, name);
								return;
							}

							if (hooks && "set" in hooks &&
								(ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}

							elem.setAttribute(name, value + "");
							return value;
						}

						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}

						ret = jQuery.find.attr(elem, name);

						// Non-existent attributes return null, we normalize to undefined
						return ret == null ? undefined : ret;
					},

					attrHooks: {
						type: {
							set: function (elem, value) {
								if (!support.radioValue && value === "radio" &&
									jQuery.nodeName(elem, "input")) {

									// Setting the type on a radio button after the value resets the value in IE8-9
									// Reset value to default in case type is set after value during creation
									var val = elem.value;
									elem.setAttribute("type", value);
									if (val) {
										elem.value = val;
									}
									return value;
								}
							}
						}
					},

					removeAttr: function (elem, value) {
						var name, propName,
							i = 0,
							attrNames = value && value.match(rnotwhite);

						if (attrNames && elem.nodeType === 1) {
							while ((name = attrNames[i++])) {
								propName = jQuery.propFix[name] || name;

								// Boolean attributes get special treatment (#10870)
								if (jQuery.expr.match.bool.test(name)) {

									// Set corresponding property to false
									if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
										elem[propName] = false;

										// Support: IE<9
										// Also clear defaultChecked/defaultSelected (if appropriate)
									} else {
										elem[jQuery.camelCase("default-" + name)] =
											elem[propName] = false;
									}

									// See #9699 for explanation of this approach (setting first, then removal)
								} else {
									jQuery.attr(elem, name, "");
								}

								elem.removeAttribute(getSetAttribute ? name : propName);
							}
						}
					}
				});

				// Hooks for boolean attributes
				boolHook = {
					set: function (elem, value, name) {
						if (value === false) {

							// Remove boolean attributes when set to false
							jQuery.removeAttr(elem, name);
						} else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {

							// IE<8 needs the *property* name
							elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);

						} else {

							// Support: IE<9
							// Use defaultChecked and defaultSelected for oldIE
							elem[jQuery.camelCase("default-" + name)] = elem[name] = true;
						}
						return name;
					}
				};

				jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
					var getter = attrHandle[name] || jQuery.find.attr;

					if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
						attrHandle[name] = function (elem, name, isXML) {
							var ret, handle;
							if (!isXML) {

								// Avoid an infinite loop by temporarily removing this function from the getter
								handle = attrHandle[name];
								attrHandle[name] = ret;
								ret = getter(elem, name, isXML) != null ?
									name.toLowerCase() :
									null;
								attrHandle[name] = handle;
							}
							return ret;
						};
					} else {
						attrHandle[name] = function (elem, name, isXML) {
							if (!isXML) {
								return elem[jQuery.camelCase("default-" + name)] ?
									name.toLowerCase() :
									null;
							}
						};
					}
				});

				// fix oldIE attroperties
				if (!getSetInput || !getSetAttribute) {
					jQuery.attrHooks.value = {
						set: function (elem, value, name) {
							if (jQuery.nodeName(elem, "input")) {

								// Does not return so that setAttribute is also used
								elem.defaultValue = value;
							} else {

								// Use nodeHook if defined (#1954); otherwise setAttribute is fine
								return nodeHook && nodeHook.set(elem, value, name);
							}
						}
					};
				}

				// IE6/7 do not support getting/setting some attributes with get/setAttribute
				if (!getSetAttribute) {

					// Use this for any attribute in IE6/7
					// This fixes almost every IE6/7 issue
					nodeHook = {
						set: function (elem, value, name) {

							// Set the existing or create a new attribute node
							var ret = elem.getAttributeNode(name);
							if (!ret) {
								elem.setAttributeNode(
									(ret = elem.ownerDocument.createAttribute(name))
								);
							}

							ret.value = value += "";

							// Break association with cloned elements by also using setAttribute (#9646)
							if (name === "value" || value === elem.getAttribute(name)) {
								return value;
							}
						}
					};

					// Some attributes are constructed with empty-string values when not defined
					attrHandle.id = attrHandle.name = attrHandle.coords =
						function (elem, name, isXML) {
							var ret;
							if (!isXML) {
								return (ret = elem.getAttributeNode(name)) && ret.value !== "" ?
									ret.value :
									null;
							}
						};

					// Fixing value retrieval on a button requires this module
					jQuery.valHooks.button = {
						get: function (elem, name) {
							var ret = elem.getAttributeNode(name);
							if (ret && ret.specified) {
								return ret.value;
							}
						},
						set: nodeHook.set
					};

					// Set contenteditable to false on removals(#10429)
					// Setting to empty string throws an error as an invalid value
					jQuery.attrHooks.contenteditable = {
						set: function (elem, value, name) {
							nodeHook.set(elem, value === "" ? false : value, name);
						}
					};

					// Set width and height to auto instead of 0 on empty string( Bug #8150 )
					// This is for removals
					jQuery.each(["width", "height"], function (i, name) {
						jQuery.attrHooks[name] = {
							set: function (elem, value) {
								if (value === "") {
									elem.setAttribute(name, "auto");
									return value;
								}
							}
						};
					});
				}

				if (!support.style) {
					jQuery.attrHooks.style = {
						get: function (elem) {

							// Return undefined in the case of empty string
							// Note: IE uppercases css property names, but if we were to .toLowerCase()
							// .cssText, that would destroy case sensitivity in URL's, like in "background"
							return elem.style.cssText || undefined;
						},
						set: function (elem, value) {
							return (elem.style.cssText = value + "");
						}
					};
				}




				var rfocusable = /^(?:input|select|textarea|button|object)$/i,
					rclickable = /^(?:a|area)$/i;

				jQuery.fn.extend({
					prop: function (name, value) {
						return access(this, jQuery.prop, name, value, arguments.length > 1);
					},

					removeProp: function (name) {
						name = jQuery.propFix[name] || name;
						return this.each(function () {

							// try/catch handles cases where IE balks (such as removing a property on window)
							try {
								this[name] = undefined;
								delete this[name];
							} catch (e) { }
						});
					}
				});

				jQuery.extend({
					prop: function (elem, name, value) {
						var ret, hooks,
							nType = elem.nodeType;

						// Don't get/set properties on text, comment and attribute nodes
						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						}

						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

							// Fix name and attach hooks
							name = jQuery.propFix[name] || name;
							hooks = jQuery.propHooks[name];
						}

						if (value !== undefined) {
							if (hooks && "set" in hooks &&
								(ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}

							return (elem[name] = value);
						}

						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}

						return elem[name];
					},

					propHooks: {
						tabIndex: {
							get: function (elem) {

								// elem.tabIndex doesn't always return the
								// correct value when it hasn't been explicitly set
								// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
								// Use proper attribute retrieval(#12072)
								var tabindex = jQuery.find.attr(elem, "tabindex");

								return tabindex ?
									parseInt(tabindex, 10) :
									rfocusable.test(elem.nodeName) ||
										rclickable.test(elem.nodeName) && elem.href ?
										0 :
										-1;
							}
						}
					},

					propFix: {
						"for": "htmlFor",
						"class": "className"
					}
				});

				// Some attributes require a special call on IE
				// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
				if (!support.hrefNormalized) {

					// href/src property should get the full normalized URL (#10299/#12915)
					jQuery.each(["href", "src"], function (i, name) {
						jQuery.propHooks[name] = {
							get: function (elem) {
								return elem.getAttribute(name, 4);
							}
						};
					});
				}

				// Support: Safari, IE9+
				// Accessing the selectedIndex property
				// forces the browser to respect setting selected
				// on the option
				// The getter ensures a default option is selected
				// when in an optgroup
				if (!support.optSelected) {
					jQuery.propHooks.selected = {
						get: function (elem) {
							var parent = elem.parentNode;

							if (parent) {
								parent.selectedIndex;

								// Make sure that it also works with optgroups, see #5701
								if (parent.parentNode) {
									parent.parentNode.selectedIndex;
								}
							}
							return null;
						},
						set: function (elem) {
							var parent = elem.parentNode;
							if (parent) {
								parent.selectedIndex;

								if (parent.parentNode) {
									parent.parentNode.selectedIndex;
								}
							}
						}
					};
				}

				jQuery.each([
					"tabIndex",
					"readOnly",
					"maxLength",
					"cellSpacing",
					"cellPadding",
					"rowSpan",
					"colSpan",
					"useMap",
					"frameBorder",
					"contentEditable"
				], function () {
					jQuery.propFix[this.toLowerCase()] = this;
				});

				// IE6/7 call enctype encoding
				if (!support.enctype) {
					jQuery.propFix.enctype = "encoding";
				}




				var rclass = /[\t\r\n\f]/g;

				function getClass(elem) {
					return jQuery.attr(elem, "class") || "";
				}

				jQuery.fn.extend({
					addClass: function (value) {
						var classes, elem, cur, curValue, clazz, j, finalValue,
							i = 0;

						if (jQuery.isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).addClass(value.call(this, j, getClass(this)));
							});
						}

						if (typeof value === "string" && value) {
							classes = value.match(rnotwhite) || [];

							while ((elem = this[i++])) {
								curValue = getClass(elem);
								cur = elem.nodeType === 1 &&
									(" " + curValue + " ").replace(rclass, " ");

								if (cur) {
									j = 0;
									while ((clazz = classes[j++])) {
										if (cur.indexOf(" " + clazz + " ") < 0) {
											cur += clazz + " ";
										}
									}

									// only assign if different to avoid unneeded rendering.
									finalValue = jQuery.trim(cur);
									if (curValue !== finalValue) {
										jQuery.attr(elem, "class", finalValue);
									}
								}
							}
						}

						return this;
					},

					removeClass: function (value) {
						var classes, elem, cur, curValue, clazz, j, finalValue,
							i = 0;

						if (jQuery.isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).removeClass(value.call(this, j, getClass(this)));
							});
						}

						if (!arguments.length) {
							return this.attr("class", "");
						}

						if (typeof value === "string" && value) {
							classes = value.match(rnotwhite) || [];

							while ((elem = this[i++])) {
								curValue = getClass(elem);

								// This expression is here for better compressibility (see addClass)
								cur = elem.nodeType === 1 &&
									(" " + curValue + " ").replace(rclass, " ");

								if (cur) {
									j = 0;
									while ((clazz = classes[j++])) {

										// Remove *all* instances
										while (cur.indexOf(" " + clazz + " ") > -1) {
											cur = cur.replace(" " + clazz + " ", " ");
										}
									}

									// Only assign if different to avoid unneeded rendering.
									finalValue = jQuery.trim(cur);
									if (curValue !== finalValue) {
										jQuery.attr(elem, "class", finalValue);
									}
								}
							}
						}

						return this;
					},

					toggleClass: function (value, stateVal) {
						var type = typeof value;

						if (typeof stateVal === "boolean" && type === "string") {
							return stateVal ? this.addClass(value) : this.removeClass(value);
						}

						if (jQuery.isFunction(value)) {
							return this.each(function (i) {
								jQuery(this).toggleClass(
									value.call(this, i, getClass(this), stateVal),
									stateVal
								);
							});
						}

						return this.each(function () {
							var className, i, self, classNames;

							if (type === "string") {

								// Toggle individual class names
								i = 0;
								self = jQuery(this);
								classNames = value.match(rnotwhite) || [];

								while ((className = classNames[i++])) {

									// Check each className given, space separated list
									if (self.hasClass(className)) {
										self.removeClass(className);
									} else {
										self.addClass(className);
									}
								}

								// Toggle whole class name
							} else if (value === undefined || type === "boolean") {
								className = getClass(this);
								if (className) {

									// store className if set
									jQuery._data(this, "__className__", className);
								}

								// If the element has a class name or if we're passed "false",
								// then remove the whole classname (if there was one, the above saved it).
								// Otherwise bring back whatever was previously saved (if anything),
								// falling back to the empty string if nothing was stored.
								jQuery.attr(this, "class",
									className || value === false ?
										"" :
										jQuery._data(this, "__className__") || ""
								);
							}
						});
					},

					hasClass: function (selector) {
						var className, elem,
							i = 0;

						className = " " + selector + " ";
						while ((elem = this[i++])) {
							if (elem.nodeType === 1 &&
								(" " + getClass(elem) + " ").replace(rclass, " ")
									.indexOf(className) > -1
							) {
								return true;
							}
						}

						return false;
					}
				});




				// Return jQuery for attributes-only inclusion


				jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
					"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
					"change select submit keydown keypress keyup error contextmenu").split(" "),
					function (i, name) {

						// Handle event binding
						jQuery.fn[name] = function (data, fn) {
							return arguments.length > 0 ?
								this.on(name, null, data, fn) :
								this.trigger(name);
						};
					});

				jQuery.fn.extend({
					hover: function (fnOver, fnOut) {
						return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
					}
				});


				var location = window.location;

				var nonce = jQuery.now();

				var rquery = (/\?/);



				var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

				jQuery.parseJSON = function (data) {

					// Attempt to parse using the native JSON parser first
					if (window.JSON && window.JSON.parse) {

						// Support: Android 2.3
						// Workaround failure to string-cast null input
						return window.JSON.parse(data + "");
					}

					var requireNonComma,
						depth = null,
						str = jQuery.trim(data + "");

					// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
					// after removing valid tokens
					return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {

						// Force termination if we see a misplaced comma
						if (requireNonComma && comma) {
							depth = 0;
						}

						// Perform no more replacements after returning to outermost depth
						if (depth === 0) {
							return token;
						}

						// Commas must not follow "[", "{", or ","
						requireNonComma = open || comma;

						// Determine new depth
						// array/object open ("[" or "{"): depth += true - false (increment)
						// array/object close ("]" or "}"): depth += false - true (decrement)
						// other cases ("," or primitive): depth += true - true (numeric cast)
						depth += !close - !open;

						// Remove this token
						return "";
					})) ?
						(Function("return " + str))() :
						jQuery.error("Invalid JSON: " + data);
				};


				// Cross-browser xml parsing
				jQuery.parseXML = function (data) {
					var xml, tmp;
					if (!data || typeof data !== "string") {
						return null;
					}
					try {
						if (window.DOMParser) { // Standard
							tmp = new window.DOMParser();
							xml = tmp.parseFromString(data, "text/xml");
						} else { // IE
							xml = new window.ActiveXObject("Microsoft.XMLDOM");
							xml.async = "false";
							xml.loadXML(data);
						}
					} catch (e) {
						xml = undefined;
					}
					if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
						jQuery.error("Invalid XML: " + data);
					}
					return xml;
				};


				var
					rhash = /#.*$/,
					rts = /([?&])_=[^&]*/,

					// IE leaves an \r character at EOL
					rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,

					// #7653, #8125, #8152: local protocol detection
					rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
					rnoContent = /^(?:GET|HEAD)$/,
					rprotocol = /^\/\//,
					rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

					/* Prefilters
					 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
					 * 2) These are called:
					 *    - BEFORE asking for a transport
					 *    - AFTER param serialization (s.data is a string if s.processData is true)
					 * 3) key is the dataType
					 * 4) the catchall symbol "*" can be used
					 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
					 */
					prefilters = {},

					/* Transports bindings
					 * 1) key is the dataType
					 * 2) the catchall symbol "*" can be used
					 * 3) selection will start with transport dataType and THEN go to "*" if needed
					 */
					transports = {},

					// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
					allTypes = "*/".concat("*"),

					// Document location
					ajaxLocation = location.href,

					// Segment location into parts
					ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

				// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
				function addToPrefiltersOrTransports(structure) {

					// dataTypeExpression is optional and defaults to "*"
					return function (dataTypeExpression, func) {

						if (typeof dataTypeExpression !== "string") {
							func = dataTypeExpression;
							dataTypeExpression = "*";
						}

						var dataType,
							i = 0,
							dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

						if (jQuery.isFunction(func)) {

							// For each dataType in the dataTypeExpression
							while ((dataType = dataTypes[i++])) {

								// Prepend if requested
								if (dataType.charAt(0) === "+") {
									dataType = dataType.slice(1) || "*";
									(structure[dataType] = structure[dataType] || []).unshift(func);

									// Otherwise append
								} else {
									(structure[dataType] = structure[dataType] || []).push(func);
								}
							}
						}
					};
				}

				// Base inspection function for prefilters and transports
				function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

					var inspected = {},
						seekingTransport = (structure === transports);

					function inspect(dataType) {
						var selected;
						inspected[dataType] = true;
						jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
							var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
							if (typeof dataTypeOrTransport === "string" &&
								!seekingTransport && !inspected[dataTypeOrTransport]) {

								options.dataTypes.unshift(dataTypeOrTransport);
								inspect(dataTypeOrTransport);
								return false;
							} else if (seekingTransport) {
								return !(selected = dataTypeOrTransport);
							}
						});
						return selected;
					}

					return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
				}

				// A special extend for ajax options
				// that takes "flat" options (not to be deep extended)
				// Fixes #9887
				function ajaxExtend(target, src) {
					var deep, key,
						flatOptions = jQuery.ajaxSettings.flatOptions || {};

					for (key in src) {
						if (src[key] !== undefined) {
							(flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
						}
					}
					if (deep) {
						jQuery.extend(true, target, deep);
					}

					return target;
				}

				/* Handles responses to an ajax request:
				 * - finds the right dataType (mediates between content-type and expected dataType)
				 * - returns the corresponding response
				 */
				function ajaxHandleResponses(s, jqXHR, responses) {
					var firstDataType, ct, finalDataType, type,
						contents = s.contents,
						dataTypes = s.dataTypes;

					// Remove auto dataType and get content-type in the process
					while (dataTypes[0] === "*") {
						dataTypes.shift();
						if (ct === undefined) {
							ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
						}
					}

					// Check if we're dealing with a known content-type
					if (ct) {
						for (type in contents) {
							if (contents[type] && contents[type].test(ct)) {
								dataTypes.unshift(type);
								break;
							}
						}
					}

					// Check to see if we have a response for the expected dataType
					if (dataTypes[0] in responses) {
						finalDataType = dataTypes[0];
					} else {

						// Try convertible dataTypes
						for (type in responses) {
							if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
								finalDataType = type;
								break;
							}
							if (!firstDataType) {
								firstDataType = type;
							}
						}

						// Or just use first one
						finalDataType = finalDataType || firstDataType;
					}

					// If we found a dataType
					// We add the dataType to the list if needed
					// and return the corresponding response
					if (finalDataType) {
						if (finalDataType !== dataTypes[0]) {
							dataTypes.unshift(finalDataType);
						}
						return responses[finalDataType];
					}
				}

				/* Chain conversions given the request and the original response
				 * Also sets the responseXXX fields on the jqXHR instance
				 */
				function ajaxConvert(s, response, jqXHR, isSuccess) {
					var conv2, current, conv, tmp, prev,
						converters = {},

						// Work with a copy of dataTypes in case we need to modify it for conversion
						dataTypes = s.dataTypes.slice();

					// Create converters map with lowercased keys
					if (dataTypes[1]) {
						for (conv in s.converters) {
							converters[conv.toLowerCase()] = s.converters[conv];
						}
					}

					current = dataTypes.shift();

					// Convert to each sequential dataType
					while (current) {

						if (s.responseFields[current]) {
							jqXHR[s.responseFields[current]] = response;
						}

						// Apply the dataFilter if provided
						if (!prev && isSuccess && s.dataFilter) {
							response = s.dataFilter(response, s.dataType);
						}

						prev = current;
						current = dataTypes.shift();

						if (current) {

							// There's only work to do if current dataType is non-auto
							if (current === "*") {

								current = prev;

								// Convert response if prev dataType is non-auto and differs from current
							} else if (prev !== "*" && prev !== current) {

								// Seek a direct converter
								conv = converters[prev + " " + current] || converters["* " + current];

								// If none found, seek a pair
								if (!conv) {
									for (conv2 in converters) {

										// If conv2 outputs current
										tmp = conv2.split(" ");
										if (tmp[1] === current) {

											// If prev can be converted to accepted input
											conv = converters[prev + " " + tmp[0]] ||
												converters["* " + tmp[0]];
											if (conv) {

												// Condense equivalence converters
												if (conv === true) {
													conv = converters[conv2];

													// Otherwise, insert the intermediate dataType
												} else if (converters[conv2] !== true) {
													current = tmp[0];
													dataTypes.unshift(tmp[1]);
												}
												break;
											}
										}
									}
								}

								// Apply converter (if not an equivalence)
								if (conv !== true) {

									// Unless errors are allowed to bubble, catch and return them
									if (conv && s["throws"]) { // jscs:ignore requireDotNotation
										response = conv(response);
									} else {
										try {
											response = conv(response);
										} catch (e) {
											return {
												state: "parsererror",
												error: conv ? e : "No conversion from " + prev + " to " + current
											};
										}
									}
								}
							}
						}
					}

					return { state: "success", data: response };
				}

				jQuery.extend({

					// Counter for holding the number of active queries
					active: 0,

					// Last-Modified header cache for next request
					lastModified: {},
					etag: {},

					ajaxSettings: {
						url: ajaxLocation,
						type: "GET",
						isLocal: rlocalProtocol.test(ajaxLocParts[1]),
						global: true,
						processData: true,
						async: true,
						contentType: "application/x-www-form-urlencoded; charset=UTF-8",
						/*
						timeout: 0,
						data: null,
						dataType: null,
						username: null,
						password: null,
						cache: null,
						throws: false,
						traditional: false,
						headers: {},
						*/

						accepts: {
							"*": allTypes,
							text: "text/plain",
							html: "text/html",
							xml: "application/xml, text/xml",
							json: "application/json, text/javascript"
						},

						contents: {
							xml: /\bxml\b/,
							html: /\bhtml/,
							json: /\bjson\b/
						},

						responseFields: {
							xml: "responseXML",
							text: "responseText",
							json: "responseJSON"
						},

						// Data converters
						// Keys separate source (or catchall "*") and destination types with a single space
						converters: {

							// Convert anything to text
							"* text": String,

							// Text to html (true = no transformation)
							"text html": true,

							// Evaluate text as a json expression
							"text json": jQuery.parseJSON,

							// Parse text as xml
							"text xml": jQuery.parseXML
						},

						// For options that shouldn't be deep extended:
						// you can add your own custom options here if
						// and when you create one that shouldn't be
						// deep extended (see ajaxExtend)
						flatOptions: {
							url: true,
							context: true
						}
					},

					// Creates a full fledged settings object into target
					// with both ajaxSettings and settings fields.
					// If target is omitted, writes into ajaxSettings.
					ajaxSetup: function (target, settings) {
						return settings ?

							// Building a settings object
							ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

							// Extending ajaxSettings
							ajaxExtend(jQuery.ajaxSettings, target);
					},

					ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
					ajaxTransport: addToPrefiltersOrTransports(transports),

					// Main method
					ajax: function (url, options) {

						// If url is an object, simulate pre-1.5 signature
						if (typeof url === "object") {
							options = url;
							url = undefined;
						}

						// Force options to be an object
						options = options || {};

						var

							// Cross-domain detection vars
							parts,

							// Loop variable
							i,

							// URL without anti-cache param
							cacheURL,

							// Response headers as string
							responseHeadersString,

							// timeout handle
							timeoutTimer,

							// To know if global events are to be dispatched
							fireGlobals,

							transport,

							// Response headers
							responseHeaders,

							// Create the final options object
							s = jQuery.ajaxSetup({}, options),

							// Callbacks context
							callbackContext = s.context || s,

							// Context for global events is callbackContext if it is a DOM node or jQuery collection
							globalEventContext = s.context &&
								(callbackContext.nodeType || callbackContext.jquery) ?
								jQuery(callbackContext) :
								jQuery.event,

							// Deferreds
							deferred = jQuery.Deferred(),
							completeDeferred = jQuery.Callbacks("once memory"),

							// Status-dependent callbacks
							statusCode = s.statusCode || {},

							// Headers (they are sent all at once)
							requestHeaders = {},
							requestHeadersNames = {},

							// The jqXHR state
							state = 0,

							// Default abort message
							strAbort = "canceled",

							// Fake xhr
							jqXHR = {
								readyState: 0,

								// Builds headers hashtable if needed
								getResponseHeader: function (key) {
									var match;
									if (state === 2) {
										if (!responseHeaders) {
											responseHeaders = {};
											while ((match = rheaders.exec(responseHeadersString))) {
												responseHeaders[match[1].toLowerCase()] = match[2];
											}
										}
										match = responseHeaders[key.toLowerCase()];
									}
									return match == null ? null : match;
								},

								// Raw string
								getAllResponseHeaders: function () {
									return state === 2 ? responseHeadersString : null;
								},

								// Caches the header
								setRequestHeader: function (name, value) {
									var lname = name.toLowerCase();
									if (!state) {
										name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
										requestHeaders[name] = value;
									}
									return this;
								},

								// Overrides response content-type header
								overrideMimeType: function (type) {
									if (!state) {
										s.mimeType = type;
									}
									return this;
								},

								// Status-dependent callbacks
								statusCode: function (map) {
									var code;
									if (map) {
										if (state < 2) {
											for (code in map) {

												// Lazy-add the new callback in a way that preserves old ones
												statusCode[code] = [statusCode[code], map[code]];
											}
										} else {

											// Execute the appropriate callbacks
											jqXHR.always(map[jqXHR.status]);
										}
									}
									return this;
								},

								// Cancel the request
								abort: function (statusText) {
									var finalText = statusText || strAbort;
									if (transport) {
										transport.abort(finalText);
									}
									done(0, finalText);
									return this;
								}
							};

						// Attach deferreds
						deferred.promise(jqXHR).complete = completeDeferred.add;
						jqXHR.success = jqXHR.done;
						jqXHR.error = jqXHR.fail;

						// Remove hash character (#7531: and string promotion)
						// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
						// Handle falsy url in the settings object (#10093: consistency with old signature)
						// We also use the url parameter if available
						s.url = ((url || s.url || ajaxLocation) + "")
							.replace(rhash, "")
							.replace(rprotocol, ajaxLocParts[1] + "//");

						// Alias method option to type as per ticket #12004
						s.type = options.method || options.type || s.method || s.type;

						// Extract dataTypes list
						s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

						// A cross-domain request is in order when we have a protocol:host:port mismatch
						if (s.crossDomain == null) {
							parts = rurl.exec(s.url.toLowerCase());
							s.crossDomain = !!(parts &&
								(parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
									(parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
									(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
							);
						}

						// Convert data if not already a string
						if (s.data && s.processData && typeof s.data !== "string") {
							s.data = jQuery.param(s.data, s.traditional);
						}

						// Apply prefilters
						inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

						// If request was aborted inside a prefilter, stop there
						if (state === 2) {
							return jqXHR;
						}

						// We can fire global events as of now if asked to
						// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
						fireGlobals = jQuery.event && s.global;

						// Watch for a new set of requests
						if (fireGlobals && jQuery.active++ === 0) {
							jQuery.event.trigger("ajaxStart");
						}

						// Uppercase the type
						s.type = s.type.toUpperCase();

						// Determine if request has content
						s.hasContent = !rnoContent.test(s.type);

						// Save the URL in case we're toying with the If-Modified-Since
						// and/or If-None-Match header later on
						cacheURL = s.url;

						// More options handling for requests with no content
						if (!s.hasContent) {

							// If data is available, append data to url
							if (s.data) {
								cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);

								// #9682: remove data so that it's not used in an eventual retry
								delete s.data;
							}

							// Add anti-cache in url if needed
							if (s.cache === false) {
								s.url = rts.test(cacheURL) ?

									// If there is already a '_' parameter, set its value
									cacheURL.replace(rts, "$1_=" + nonce++) :

									// Otherwise add one to the end
									cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
							}
						}

						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if (s.ifModified) {
							if (jQuery.lastModified[cacheURL]) {
								jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
							}
							if (jQuery.etag[cacheURL]) {
								jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
							}
						}

						// Set the correct header, if data is being sent
						if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
							jqXHR.setRequestHeader("Content-Type", s.contentType);
						}

						// Set the Accepts header for the server, depending on the dataType
						jqXHR.setRequestHeader(
							"Accept",
							s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
								s.accepts[s.dataTypes[0]] +
								(s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
								s.accepts["*"]
						);

						// Check for headers option
						for (i in s.headers) {
							jqXHR.setRequestHeader(i, s.headers[i]);
						}

						// Allow custom headers/mimetypes and early abort
						if (s.beforeSend &&
							(s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

							// Abort if not done already and return
							return jqXHR.abort();
						}

						// aborting is no longer a cancellation
						strAbort = "abort";

						// Install callbacks on deferreds
						for (i in { success: 1, error: 1, complete: 1 }) {
							jqXHR[i](s[i]);
						}

						// Get transport
						transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

						// If no transport, we auto-abort
						if (!transport) {
							done(-1, "No Transport");
						} else {
							jqXHR.readyState = 1;

							// Send global event
							if (fireGlobals) {
								globalEventContext.trigger("ajaxSend", [jqXHR, s]);
							}

							// If request was aborted inside ajaxSend, stop there
							if (state === 2) {
								return jqXHR;
							}

							// Timeout
							if (s.async && s.timeout > 0) {
								timeoutTimer = window.setTimeout(function () {
									jqXHR.abort("timeout");
								}, s.timeout);
							}

							try {
								state = 1;
								transport.send(requestHeaders, done);
							} catch (e) {

								// Propagate exception as error if not done
								if (state < 2) {
									done(-1, e);

									// Simply rethrow otherwise
								} else {
									throw e;
								}
							}
						}

						// Callback for when everything is done
						function done(status, nativeStatusText, responses, headers) {
							var isSuccess, success, error, response, modified,
								statusText = nativeStatusText;

							// Called once
							if (state === 2) {
								return;
							}

							// State is "done" now
							state = 2;

							// Clear timeout if it exists
							if (timeoutTimer) {
								window.clearTimeout(timeoutTimer);
							}

							// Dereference transport for early garbage collection
							// (no matter how long the jqXHR object will be used)
							transport = undefined;

							// Cache response headers
							responseHeadersString = headers || "";

							// Set readyState
							jqXHR.readyState = status > 0 ? 4 : 0;

							// Determine if successful
							isSuccess = status >= 200 && status < 300 || status === 304;

							// Get response data
							if (responses) {
								response = ajaxHandleResponses(s, jqXHR, responses);
							}

							// Convert no matter what (that way responseXXX fields are always set)
							response = ajaxConvert(s, response, jqXHR, isSuccess);

							// If successful, handle type chaining
							if (isSuccess) {

								// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
								if (s.ifModified) {
									modified = jqXHR.getResponseHeader("Last-Modified");
									if (modified) {
										jQuery.lastModified[cacheURL] = modified;
									}
									modified = jqXHR.getResponseHeader("etag");
									if (modified) {
										jQuery.etag[cacheURL] = modified;
									}
								}

								// if no content
								if (status === 204 || s.type === "HEAD") {
									statusText = "nocontent";

									// if not modified
								} else if (status === 304) {
									statusText = "notmodified";

									// If we have data, let's convert it
								} else {
									statusText = response.state;
									success = response.data;
									error = response.error;
									isSuccess = !error;
								}
							} else {

								// We extract error from statusText
								// then normalize statusText and status for non-aborts
								error = statusText;
								if (status || !statusText) {
									statusText = "error";
									if (status < 0) {
										status = 0;
									}
								}
							}

							// Set data for the fake xhr object
							jqXHR.status = status;
							jqXHR.statusText = (nativeStatusText || statusText) + "";

							// Success/Error
							if (isSuccess) {
								deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
							} else {
								deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
							}

							// Status-dependent callbacks
							jqXHR.statusCode(statusCode);
							statusCode = undefined;

							if (fireGlobals) {
								globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
									[jqXHR, s, isSuccess ? success : error]);
							}

							// Complete
							completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

							if (fireGlobals) {
								globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

								// Handle the global AJAX counter
								if (!(--jQuery.active)) {
									jQuery.event.trigger("ajaxStop");
								}
							}
						}

						return jqXHR;
					},

					getJSON: function (url, data, callback) {
						return jQuery.get(url, data, callback, "json");
					},

					getScript: function (url, callback) {
						return jQuery.get(url, undefined, callback, "script");
					}
				});

				jQuery.each(["get", "post"], function (i, method) {
					jQuery[method] = function (url, data, callback, type) {

						// shift arguments if data argument was omitted
						if (jQuery.isFunction(data)) {
							type = type || callback;
							callback = data;
							data = undefined;
						}

						// The url can be an options object (which then must have .url)
						return jQuery.ajax(jQuery.extend({
							url: url,
							type: method,
							dataType: type,
							data: data,
							success: callback
						}, jQuery.isPlainObject(url) && url));
					};
				});


				jQuery._evalUrl = function (url) {
					return jQuery.ajax({
						url: url,

						// Make this explicit, since user can override this through ajaxSetup (#11264)
						type: "GET",
						dataType: "script",
						cache: true,
						async: false,
						global: false,
						"throws": true
					});
				};


				jQuery.fn.extend({
					wrapAll: function (html) {
						if (jQuery.isFunction(html)) {
							return this.each(function (i) {
								jQuery(this).wrapAll(html.call(this, i));
							});
						}

						if (this[0]) {

							// The elements to wrap the target around
							var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

							if (this[0].parentNode) {
								wrap.insertBefore(this[0]);
							}

							wrap.map(function () {
								var elem = this;

								while (elem.firstChild && elem.firstChild.nodeType === 1) {
									elem = elem.firstChild;
								}

								return elem;
							}).append(this);
						}

						return this;
					},

					wrapInner: function (html) {
						if (jQuery.isFunction(html)) {
							return this.each(function (i) {
								jQuery(this).wrapInner(html.call(this, i));
							});
						}

						return this.each(function () {
							var self = jQuery(this),
								contents = self.contents();

							if (contents.length) {
								contents.wrapAll(html);

							} else {
								self.append(html);
							}
						});
					},

					wrap: function (html) {
						var isFunction = jQuery.isFunction(html);

						return this.each(function (i) {
							jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
						});
					},

					unwrap: function () {
						return this.parent().each(function () {
							if (!jQuery.nodeName(this, "body")) {
								jQuery(this).replaceWith(this.childNodes);
							}
						}).end();
					}
				});


				function getDisplay(elem) {
					return elem.style && elem.style.display || jQuery.css(elem, "display");
				}

				function filterHidden(elem) {

					// Disconnected elements are considered hidden
					if (!jQuery.contains(elem.ownerDocument || document, elem)) {
						return true;
					}
					while (elem && elem.nodeType === 1) {
						if (getDisplay(elem) === "none" || elem.type === "hidden") {
							return true;
						}
						elem = elem.parentNode;
					}
					return false;
				}

				jQuery.expr.filters.hidden = function (elem) {

					// Support: Opera <= 12.12
					// Opera reports offsetWidths and offsetHeights less than zero on some elements
					return support.reliableHiddenOffsets() ?
						(elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&
							!elem.getClientRects().length) :
						filterHidden(elem);
				};

				jQuery.expr.filters.visible = function (elem) {
					return !jQuery.expr.filters.hidden(elem);
				};




				var r20 = /%20/g,
					rbracket = /\[\]$/,
					rCRLF = /\r?\n/g,
					rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
					rsubmittable = /^(?:input|select|textarea|keygen)/i;

				function buildParams(prefix, obj, traditional, add) {
					var name;

					if (jQuery.isArray(obj)) {

						// Serialize array item.
						jQuery.each(obj, function (i, v) {
							if (traditional || rbracket.test(prefix)) {

								// Treat each array item as a scalar.
								add(prefix, v);

							} else {

								// Item is non-scalar (array or object), encode its numeric index.
								buildParams(
									prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
									v,
									traditional,
									add
								);
							}
						});

					} else if (!traditional && jQuery.type(obj) === "object") {

						// Serialize object item.
						for (name in obj) {
							buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
						}

					} else {

						// Serialize scalar item.
						add(prefix, obj);
					}
				}

				// Serialize an array of form elements or a set of
				// key/values into a query string
				jQuery.param = function (a, traditional) {
					var prefix,
						s = [],
						add = function (key, value) {

							// If value is a function, invoke it and return its value
							value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
							s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
						};

					// Set traditional to true for jQuery <= 1.3.2 behavior.
					if (traditional === undefined) {
						traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
					}

					// If an array was passed in, assume that it is an array of form elements.
					if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

						// Serialize the form elements
						jQuery.each(a, function () {
							add(this.name, this.value);
						});

					} else {

						// If traditional, encode the "old" way (the way 1.3.2 or older
						// did it), otherwise encode params recursively.
						for (prefix in a) {
							buildParams(prefix, a[prefix], traditional, add);
						}
					}

					// Return the resulting serialization
					return s.join("&").replace(r20, "+");
				};

				jQuery.fn.extend({
					serialize: function () {
						return jQuery.param(this.serializeArray());
					},
					serializeArray: function () {
						return this.map(function () {

							// Can add propHook for "elements" to filter or add form elements
							var elements = jQuery.prop(this, "elements");
							return elements ? jQuery.makeArray(elements) : this;
						})
							.filter(function () {
								var type = this.type;

								// Use .is(":disabled") so that fieldset[disabled] works
								return this.name && !jQuery(this).is(":disabled") &&
									rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
									(this.checked || !rcheckableType.test(type));
							})
							.map(function (i, elem) {
								var val = jQuery(this).val();

								return val == null ?
									null :
									jQuery.isArray(val) ?
										jQuery.map(val, function (val) {
											return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
										}) :
										{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
							}).get();
					}
				});


				// Create the request object
				// (This is still attached to ajaxSettings for backward compatibility)
				jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?

					// Support: IE6-IE8
					function () {

						// XHR cannot access local files, always use ActiveX for that case
						if (this.isLocal) {
							return createActiveXHR();
						}

						// Support: IE 9-11
						// IE seems to error on cross-domain PATCH requests when ActiveX XHR
						// is used. In IE 9+ always use the native XHR.
						// Note: this condition won't catch Edge as it doesn't define
						// document.documentMode but it also doesn't support ActiveX so it won't
						// reach this code.
						if (document.documentMode > 8) {
							return createStandardXHR();
						}

						// Support: IE<9
						// oldIE XHR does not support non-RFC2616 methods (#13240)
						// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
						// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
						// Although this check for six methods instead of eight
						// since IE also does not support "trace" and "connect"
						return /^(get|post|head|put|delete|options)$/i.test(this.type) &&
							createStandardXHR() || createActiveXHR();
					} :

					// For all other browsers, use the standard XMLHttpRequest object
					createStandardXHR;

				var xhrId = 0,
					xhrCallbacks = {},
					xhrSupported = jQuery.ajaxSettings.xhr();

				// Support: IE<10
				// Open requests must be manually aborted on unload (#5280)
				// See https://support.microsoft.com/kb/2856746 for more info
				if (window.attachEvent) {
					window.attachEvent("onunload", function () {
						for (var key in xhrCallbacks) {
							xhrCallbacks[key](undefined, true);
						}
					});
				}

				// Determine support properties
				support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
				xhrSupported = support.ajax = !!xhrSupported;

				// Create transport if the browser can provide an xhr
				if (xhrSupported) {

					jQuery.ajaxTransport(function (options) {

						// Cross domain only allowed if supported through XMLHttpRequest
						if (!options.crossDomain || support.cors) {

							var callback;

							return {
								send: function (headers, complete) {
									var i,
										xhr = options.xhr(),
										id = ++xhrId;

									// Open the socket
									xhr.open(
										options.type,
										options.url,
										options.async,
										options.username,
										options.password
									);

									// Apply custom fields if provided
									if (options.xhrFields) {
										for (i in options.xhrFields) {
											xhr[i] = options.xhrFields[i];
										}
									}

									// Override mime type if needed
									if (options.mimeType && xhr.overrideMimeType) {
										xhr.overrideMimeType(options.mimeType);
									}

									// X-Requested-With header
									// For cross-domain requests, seeing as conditions for a preflight are
									// akin to a jigsaw puzzle, we simply never set it to be sure.
									// (it can always be set on a per-request basis or even using ajaxSetup)
									// For same-domain requests, won't change header if already provided.
									if (!options.crossDomain && !headers["X-Requested-With"]) {
										headers["X-Requested-With"] = "XMLHttpRequest";
									}

									// Set headers
									for (i in headers) {

										// Support: IE<9
										// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
										// request header to a null-value.
										//
										// To keep consistent with other XHR implementations, cast the value
										// to string and ignore `undefined`.
										if (headers[i] !== undefined) {
											xhr.setRequestHeader(i, headers[i] + "");
										}
									}

									// Do send the request
									// This may raise an exception which is actually
									// handled in jQuery.ajax (so no try/catch here)
									xhr.send((options.hasContent && options.data) || null);

									// Listener
									callback = function (_, isAbort) {
										var status, statusText, responses;

										// Was never called and is aborted or complete
										if (callback && (isAbort || xhr.readyState === 4)) {

											// Clean up
											delete xhrCallbacks[id];
											callback = undefined;
											xhr.onreadystatechange = jQuery.noop;

											// Abort manually if needed
											if (isAbort) {
												if (xhr.readyState !== 4) {
													xhr.abort();
												}
											} else {
												responses = {};
												status = xhr.status;

												// Support: IE<10
												// Accessing binary-data responseText throws an exception
												// (#11426)
												if (typeof xhr.responseText === "string") {
													responses.text = xhr.responseText;
												}

												// Firefox throws an exception when accessing
												// statusText for faulty cross-domain requests
												try {
													statusText = xhr.statusText;
												} catch (e) {

													// We normalize with Webkit giving an empty statusText
													statusText = "";
												}

												// Filter status for non standard behaviors

												// If the request is local and we have data: assume a success
												// (success with no data won't get notified, that's the best we
												// can do given current implementations)
												if (!status && options.isLocal && !options.crossDomain) {
													status = responses.text ? 200 : 404;

													// IE - #1450: sometimes returns 1223 when it should be 204
												} else if (status === 1223) {
													status = 204;
												}
											}
										}

										// Call complete if needed
										if (responses) {
											complete(status, statusText, responses, xhr.getAllResponseHeaders());
										}
									};

									// Do send the request
									// `xhr.send` may raise an exception, but it will be
									// handled in jQuery.ajax (so no try/catch here)
									if (!options.async) {

										// If we're in sync mode we fire the callback
										callback();
									} else if (xhr.readyState === 4) {

										// (IE6 & IE7) if it's in cache and has been
										// retrieved directly we need to fire the callback
										window.setTimeout(callback);
									} else {

										// Register the callback, but delay it in case `xhr.send` throws
										// Add to the list of active xhr callbacks
										xhr.onreadystatechange = xhrCallbacks[id] = callback;
									}
								},

								abort: function () {
									if (callback) {
										callback(undefined, true);
									}
								}
							};
						}
					});
				}

				// Functions to create xhrs
				function createStandardXHR() {
					try {
						return new window.XMLHttpRequest();
					} catch (e) { }
				}

				function createActiveXHR() {
					try {
						return new window.ActiveXObject("Microsoft.XMLHTTP");
					} catch (e) { }
				}




				// Install script dataType
				jQuery.ajaxSetup({
					accepts: {
						script: "text/javascript, application/javascript, " +
							"application/ecmascript, application/x-ecmascript"
					},
					contents: {
						script: /\b(?:java|ecma)script\b/
					},
					converters: {
						"text script": function (text) {
							jQuery.globalEval(text);
							return text;
						}
					}
				});

				// Handle cache's special case and global
				jQuery.ajaxPrefilter("script", function (s) {
					if (s.cache === undefined) {
						s.cache = false;
					}
					if (s.crossDomain) {
						s.type = "GET";
						s.global = false;
					}
				});

				// Bind script tag hack transport
				jQuery.ajaxTransport("script", function (s) {

					// This transport only deals with cross domain requests
					if (s.crossDomain) {

						var script,
							head = document.head || jQuery("head")[0] || document.documentElement;

						return {

							send: function (_, callback) {

								script = document.createElement("script");

								script.async = true;

								if (s.scriptCharset) {
									script.charset = s.scriptCharset;
								}

								script.src = s.url;

								// Attach handlers for all browsers
								script.onload = script.onreadystatechange = function (_, isAbort) {

									if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

										// Handle memory leak in IE
										script.onload = script.onreadystatechange = null;

										// Remove the script
										if (script.parentNode) {
											script.parentNode.removeChild(script);
										}

										// Dereference the script
										script = null;

										// Callback if not abort
										if (!isAbort) {
											callback(200, "success");
										}
									}
								};

								// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
								// Use native DOM manipulation to avoid our domManip AJAX trickery
								head.insertBefore(script, head.firstChild);
							},

							abort: function () {
								if (script) {
									script.onload(undefined, true);
								}
							}
						};
					}
				});




				var oldCallbacks = [],
					rjsonp = /(=)\?(?=&|$)|\?\?/;

				// Default jsonp settings
				jQuery.ajaxSetup({
					jsonp: "callback",
					jsonpCallback: function () {
						var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
						this[callback] = true;
						return callback;
					}
				});

				// Detect, normalize options and install callbacks for jsonp requests
				jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

					var callbackName, overwritten, responseContainer,
						jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
							"url" :
							typeof s.data === "string" &&
							(s.contentType || "")
								.indexOf("application/x-www-form-urlencoded") === 0 &&
							rjsonp.test(s.data) && "data"
						);

					// Handle iff the expected data type is "jsonp" or we have a parameter to set
					if (jsonProp || s.dataTypes[0] === "jsonp") {

						// Get callback name, remembering preexisting value associated with it
						callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
							s.jsonpCallback() :
							s.jsonpCallback;

						// Insert callback into url or form data
						if (jsonProp) {
							s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
						} else if (s.jsonp !== false) {
							s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
						}

						// Use data converter to retrieve json after script execution
						s.converters["script json"] = function () {
							if (!responseContainer) {
								jQuery.error(callbackName + " was not called");
							}
							return responseContainer[0];
						};

						// force json dataType
						s.dataTypes[0] = "json";

						// Install callback
						overwritten = window[callbackName];
						window[callbackName] = function () {
							responseContainer = arguments;
						};

						// Clean-up function (fires after converters)
						jqXHR.always(function () {

							// If previous value didn't exist - remove it
							if (overwritten === undefined) {
								jQuery(window).removeProp(callbackName);

								// Otherwise restore preexisting value
							} else {
								window[callbackName] = overwritten;
							}

							// Save back as free
							if (s[callbackName]) {

								// make sure that re-using the options doesn't screw things around
								s.jsonpCallback = originalSettings.jsonpCallback;

								// save the callback name for future use
								oldCallbacks.push(callbackName);
							}

							// Call if it was a function and we have a response
							if (responseContainer && jQuery.isFunction(overwritten)) {
								overwritten(responseContainer[0]);
							}

							responseContainer = overwritten = undefined;
						});

						// Delegate to script
						return "script";
					}
				});




				// data: string of html
				// context (optional): If specified, the fragment will be created in this context,
				// defaults to document
				// keepScripts (optional): If true, will include scripts passed in the html string
				jQuery.parseHTML = function (data, context, keepScripts) {
					if (!data || typeof data !== "string") {
						return null;
					}
					if (typeof context === "boolean") {
						keepScripts = context;
						context = false;
					}
					context = context || document;

					var parsed = rsingleTag.exec(data),
						scripts = !keepScripts && [];

					// Single tag
					if (parsed) {
						return [context.createElement(parsed[1])];
					}

					parsed = buildFragment([data], context, scripts);

					if (scripts && scripts.length) {
						jQuery(scripts).remove();
					}

					return jQuery.merge([], parsed.childNodes);
				};


				// Keep a copy of the old load method
				var _load = jQuery.fn.load;

				/**
				 * Load a url into a page
				 */
				jQuery.fn.load = function (url, params, callback) {
					if (typeof url !== "string" && _load) {
						return _load.apply(this, arguments);
					}

					var selector, type, response,
						self = this,
						off = url.indexOf(" ");

					if (off > -1) {
						selector = jQuery.trim(url.slice(off, url.length));
						url = url.slice(0, off);
					}

					// If it's a function
					if (jQuery.isFunction(params)) {

						// We assume that it's the callback
						callback = params;
						params = undefined;

						// Otherwise, build a param string
					} else if (params && typeof params === "object") {
						type = "POST";
					}

					// If we have elements to modify, make the request
					if (self.length > 0) {
						jQuery.ajax({
							url: url,

							// If "type" variable is undefined, then "GET" method will be used.
							// Make value of this field explicit since
							// user can override it through ajaxSetup method
							type: type || "GET",
							dataType: "html",
							data: params
						}).done(function (responseText) {

							// Save response for use in complete callback
							response = arguments;

							self.html(selector ?

								// If a selector was specified, locate the right elements in a dummy div
								// Exclude scripts to avoid IE 'Permission Denied' errors
								jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

								// Otherwise use the full result
								responseText);

							// If the request succeeds, this function gets "data", "status", "jqXHR"
							// but they are ignored because response was set above.
							// If it fails, this function gets "jqXHR", "status", "error"
						}).always(callback && function (jqXHR, status) {
							self.each(function () {
								callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
							});
						});
					}

					return this;
				};




				// Attach a bunch of functions for handling common AJAX events
				jQuery.each([
					"ajaxStart",
					"ajaxStop",
					"ajaxComplete",
					"ajaxError",
					"ajaxSuccess",
					"ajaxSend"
				], function (i, type) {
					jQuery.fn[type] = function (fn) {
						return this.on(type, fn);
					};
				});




				jQuery.expr.filters.animated = function (elem) {
					return jQuery.grep(jQuery.timers, function (fn) {
						return elem === fn.elem;
					}).length;
				};





				/**
				 * Gets a window from an element
				 */
				function getWindow(elem) {
					return jQuery.isWindow(elem) ?
						elem :
						elem.nodeType === 9 ?
							elem.defaultView || elem.parentWindow :
							false;
				}

				jQuery.offset = {
					setOffset: function (elem, options, i) {
						var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
							position = jQuery.css(elem, "position"),
							curElem = jQuery(elem),
							props = {};

						// set position first, in-case top/left are set even on static elem
						if (position === "static") {
							elem.style.position = "relative";
						}

						curOffset = curElem.offset();
						curCSSTop = jQuery.css(elem, "top");
						curCSSLeft = jQuery.css(elem, "left");
						calculatePosition = (position === "absolute" || position === "fixed") &&
							jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1;

						// need to be able to calculate position if either top or left
						// is auto and position is either absolute or fixed
						if (calculatePosition) {
							curPosition = curElem.position();
							curTop = curPosition.top;
							curLeft = curPosition.left;
						} else {
							curTop = parseFloat(curCSSTop) || 0;
							curLeft = parseFloat(curCSSLeft) || 0;
						}

						if (jQuery.isFunction(options)) {

							// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
							options = options.call(elem, i, jQuery.extend({}, curOffset));
						}

						if (options.top != null) {
							props.top = (options.top - curOffset.top) + curTop;
						}
						if (options.left != null) {
							props.left = (options.left - curOffset.left) + curLeft;
						}

						if ("using" in options) {
							options.using.call(elem, props);
						} else {
							curElem.css(props);
						}
					}
				};

				jQuery.fn.extend({
					offset: function (options) {
						if (arguments.length) {
							return options === undefined ?
								this :
								this.each(function (i) {
									jQuery.offset.setOffset(this, options, i);
								});
						}

						var docElem, win,
							box = { top: 0, left: 0 },
							elem = this[0],
							doc = elem && elem.ownerDocument;

						if (!doc) {
							return;
						}

						docElem = doc.documentElement;

						// Make sure it's not a disconnected DOM node
						if (!jQuery.contains(docElem, elem)) {
							return box;
						}

						// If we don't have gBCR, just use 0,0 rather than error
						// BlackBerry 5, iOS 3 (original iPhone)
						if (typeof elem.getBoundingClientRect !== "undefined") {
							box = elem.getBoundingClientRect();
						}
						win = getWindow(doc);
						return {
							top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
							left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
						};
					},

					position: function () {
						if (!this[0]) {
							return;
						}

						var offsetParent, offset,
							parentOffset = { top: 0, left: 0 },
							elem = this[0];

						// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
						// because it is its only offset parent
						if (jQuery.css(elem, "position") === "fixed") {

							// we assume that getBoundingClientRect is available when computed position is fixed
							offset = elem.getBoundingClientRect();
						} else {

							// Get *real* offsetParent
							offsetParent = this.offsetParent();

							// Get correct offsets
							offset = this.offset();
							if (!jQuery.nodeName(offsetParent[0], "html")) {
								parentOffset = offsetParent.offset();
							}

							// Add offsetParent borders
							parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
							parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
						}

						// Subtract parent offsets and element margins
						// note: when an element has margin: auto the offsetLeft and marginLeft
						// are the same in Safari causing offset.left to incorrectly be 0
						return {
							top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
							left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
						};
					},

					offsetParent: function () {
						return this.map(function () {
							var offsetParent = this.offsetParent;

							while (offsetParent && (!jQuery.nodeName(offsetParent, "html") &&
								jQuery.css(offsetParent, "position") === "static")) {
								offsetParent = offsetParent.offsetParent;
							}
							return offsetParent || documentElement;
						});
					}
				});

				// Create scrollLeft and scrollTop methods
				jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
					var top = /Y/.test(prop);

					jQuery.fn[method] = function (val) {
						return access(this, function (elem, method, val) {
							var win = getWindow(elem);

							if (val === undefined) {
								return win ? (prop in win) ? win[prop] :
									win.document.documentElement[method] :
									elem[method];
							}

							if (win) {
								win.scrollTo(
									!top ? val : jQuery(win).scrollLeft(),
									top ? val : jQuery(win).scrollTop()
								);

							} else {
								elem[method] = val;
							}
						}, method, val, arguments.length, null);
					};
				});

				// Support: Safari<7-8+, Chrome<37-44+
				// Add the top/left cssHooks using jQuery.fn.position
				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// getComputedStyle returns percent when specified for top/left/bottom/right
				// rather than make the css module depend on the offset module, we just check for it here
				jQuery.each(["top", "left"], function (i, prop) {
					jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
						function (elem, computed) {
							if (computed) {
								computed = curCSS(elem, prop);

								// if curCSS returns percentage, fallback to offset
								return rnumnonpx.test(computed) ?
									jQuery(elem).position()[prop] + "px" :
									computed;
							}
						}
					);
				});


				// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
				jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
					jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name },
						function (defaultExtra, funcName) {

							// margin is only for outerHeight, outerWidth
							jQuery.fn[funcName] = function (margin, value) {
								var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
									extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

								return access(this, function (elem, type, value) {
									var doc;

									if (jQuery.isWindow(elem)) {

										// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
										// isn't a whole lot we can do. See pull request at this URL for discussion:
										// https://github.com/jquery/jquery/pull/764
										return elem.document.documentElement["client" + name];
									}

									// Get document width or height
									if (elem.nodeType === 9) {
										doc = elem.documentElement;

										// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
										// whichever is greatest
										// unfortunately, this causes bug #3838 in IE6/8 only,
										// but there is currently no good, small way to fix it.
										return Math.max(
											elem.body["scroll" + name], doc["scroll" + name],
											elem.body["offset" + name], doc["offset" + name],
											doc["client" + name]
										);
									}

									return value === undefined ?

										// Get width or height on the element, requesting but not forcing parseFloat
										jQuery.css(elem, type, extra) :

										// Set width or height on the element
										jQuery.style(elem, type, value, extra);
								}, type, chainable ? margin : undefined, chainable, null);
							};
						});
				});


				jQuery.fn.extend({

					bind: function (types, data, fn) {
						return this.on(types, null, data, fn);
					},
					unbind: function (types, fn) {
						return this.off(types, null, fn);
					},

					delegate: function (selector, types, data, fn) {
						return this.on(types, selector, data, fn);
					},
					undelegate: function (selector, types, fn) {

						// ( namespace ) or ( selector, types [, fn] )
						return arguments.length === 1 ?
							this.off(selector, "**") :
							this.off(types, selector || "**", fn);
					}
				});

				// The number of elements contained in the matched element set
				jQuery.fn.size = function () {
					return this.length;
				};

				jQuery.fn.andSelf = jQuery.fn.addBack;




				// Register as a named AMD module, since jQuery can be concatenated with other
				// files that may use define, but not via a proper concatenation script that
				// understands anonymous AMD modules. A named AMD is safest and most robust
				// way to register. Lowercase jquery is used because AMD module names are
				// derived from file names, and jQuery is normally delivered in a lowercase
				// file name. Do this after creating the global so that if an AMD module wants
				// to call noConflict to hide this version of jQuery, it will work.

				// Note that for maximum portability, libraries that are not jQuery should
				// declare themselves as anonymous modules, and avoid setting a global if an
				// AMD loader is present. jQuery is a special case. For more information, see
				// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

				if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
						return jQuery;
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				}



				var

					// Map over jQuery in case of overwrite
					_jQuery = window.jQuery,

					// Map over the $ in case of overwrite
					_$ = window.$;

				jQuery.noConflict = function (deep) {
					if (window.$ === jQuery) {
						window.$ = _$;
					}

					if (deep && window.jQuery === jQuery) {
						window.jQuery = _jQuery;
					}

					return jQuery;
				};

				// Expose jQuery and $ identifiers, even in
				// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
				// and CommonJS for browser emulators (#13566)
				if (!noGlobal) {
					window.jQuery = window.$ = jQuery;
				}

				return jQuery;
			}));


			/***/
		}),

/***/ "./node_modules/jquerykeyframes/dist/jquery.keyframes.min.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jquerykeyframes/dist/jquery.keyframes.min.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var require; var require; !function o(a, u, s) { function l(t, e) { if (!u[t]) { if (!a[t]) { var n = "function" == typeof require && require; if (!e && n) return require(t, !0); if (c) return c(t, !0); var r = new Error("Cannot find module '" + t + "'"); throw r.code = "MODULE_NOT_FOUND", r } var i = u[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return l(a[t][1][e] || e) }, i, i.exports, o, a, u, s) } return u[t].exports } for (var c = "function" == typeof require && require, e = 0; e < s.length; e++)l(s[e]); return l }({ 1: [function (e, t, n) { "use strict"; var r, i, o = (r = e("@keyframes/core")) && r.__esModule ? r : { default: r }; function a(e, n) { e.each(function (e, t) { t.Keyframes || (t.Keyframes = new o.default(t)), n(t.Keyframes) }) } (i = jQuery).keyframe = { isSupported: o.default.isSupported, generate: o.default.generate, generateCSS: o.default.generateCSS, define: o.default.define }, i.fn.resetKeyframe = function (t) { a(this, function (e) { return e.reset().then(t) }) }, i.fn.pauseKeyframe = function () { a(this, function (e) { return e.pause() }) }, i.fn.resumeKeyframe = function () { a(this, function (e) { return e.resume() }) }, i.fn.playKeyframe = function (t, e) { var n = e; t.complete && (e = t.complete), "function" == typeof e && (n = { onIteration: e, onEnd: e }), a(this, function (e) { return e.play(t, n) }) } }, { "@keyframes/core": 2 }], 2: [function (e, t, n) { "use strict"; var o = function () { return (o = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }).apply(this, arguments) }, d = function (e, a, u, s) { return new (u = u || Promise)(function (t, n) { function r(e) { try { o(s.next(e)) } catch (e) { n(e) } } function i(e) { try { o(s.throw(e)) } catch (e) { n(e) } } function o(e) { e.done ? t(e.value) : function (t) { return t instanceof u ? t : new u(function (e) { e(t) }) }(e.value).then(r, i) } o((s = s.apply(e, a || [])).next()) }) }, p = function (n, r) { var i, o, a, e, u = { label: 0, sent: function () { if (1 & a[0]) throw a[1]; return a[1] }, trys: [], ops: [] }; return e = { next: t(0), throw: t(1), return: t(2) }, "function" == typeof Symbol && (e[Symbol.iterator] = function () { return this }), e; function t(t) { return function (e) { return function (t) { if (i) throw new TypeError("Generator is already executing."); for (; u;)try { if (i = 1, o && (a = 2 & t[0] ? o.return : t[0] ? o.throw || ((a = o.return) && a.call(o), 0) : o.next) && !(a = a.call(o, t[1])).done) return a; switch (o = 0, a && (t = [2 & t[0], a.value]), t[0]) { case 0: case 1: a = t; break; case 4: return u.label++, { value: t[1], done: !1 }; case 5: u.label++, o = t[1], t = [0]; continue; case 7: t = u.ops.pop(), u.trys.pop(); continue; default: if (!(a = 0 < (a = u.trys).length && a[a.length - 1]) && (6 === t[0] || 2 === t[0])) { u = 0; continue } if (3 === t[0] && (!a || t[1] > a[0] && t[1] < a[3])) { u.label = t[1]; break } if (6 === t[0] && u.label < a[1]) { u.label = a[1], a = t; break } if (a && u.label < a[2]) { u.label = a[2], u.ops.push(t); break } a[2] && u.ops.pop(), u.trys.pop(); continue }t = r.call(n, u) } catch (e) { t = [6, e], o = 0 } finally { i = a = 0 } if (5 & t[0]) throw t[1]; return { value: t[0] ? t[1] : void 0, done: !0 } }([t, e]) } } }, r = function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(n, "__esModule", { value: !0 }); function i() { return new Promise(function (e) { requestAnimationFrame(function () { e() }) }) } var a, u = r(e("add-px-to-style")), s = r(e("hyphenate-style-name")), l = "undefined" != typeof window; if (l) { var c = document.createElement("style"); c.setAttribute("id", "keyframesjs-stylesheet"), document.head.appendChild(c), a = c.sheet } function f() { } function h(e) { if (!Object.keys(e).length) return ""; var t = ""; for (var n in e) t += s.default(n) + ":" + u.default(n, e[n]) + ";"; return t } var m = (y.isSupported = function () { return void 0 !== document.body.style.animationName }, y.prototype.reset = function () { return d(this, void 0, void 0, function () { return p(this, function (e) { switch (e.label) { case 0: return this.removeEvents(), this.mountedElement.style.animationPlayState = "running", this.mountedElement.style.animation = "none", [4, i()]; case 1: return e.sent(), [2, this] } }) }) }, y.prototype.pause = function () { return this.mountedElement.style.animationPlayState = "paused", this }, y.prototype.resume = function () { return this.mountedElement.style.animationPlayState = "running", this }, y.prototype.play = function (t, n) { var r = this; if (this.mountedElement.style.animationName === this.getAnimationName(t)) return requestAnimationFrame(function () { return d(r, void 0, void 0, function () { return p(this, function (e) { switch (e.label) { case 0: return [4, this.reset()]; case 1: return e.sent(), this.play(t, n), [2] } }) }) }), this; function e(e, t) { var n = e + "Listener"; r.mountedElement.removeEventListener(e, r[n]), r[n] = t, r.mountedElement.addEventListener(e, r[n]) } var i = n || {}, o = i.onBeforeStart, a = void 0 === o ? null : o, u = i.onStart, s = void 0 === u ? null : u, l = i.onIteration, c = void 0 === l ? null : l, f = i.onEnd, h = void 0 === f ? null : f, m = y.playCSS(t); return a && a(), this.mountedElement.style.animationPlayState = "running", this.mountedElement.style.animation = m, c && e("animationiteration", c), h && e("animationend", h), s && requestAnimationFrame(s), this }, y.prototype.removeEvents = function () { return this.mountedElement.removeEventListener("animationiteration", this.animationiterationListener), this.mountedElement.removeEventListener("animationend", this.animationendListener), this }, y.prototype.playNext = function () { var e = this, t = this.queueStore.pop(); t ? this.play(t, { onEnd: function () { return e.playNext() }, onIteration: this.callbacks.onIteration }) : this.callbacks.onEnd && this.callbacks.onEnd() }, y.prototype.updateCallbacks = function (e) { e && (this.callbacks = o(o({}, this.callbacks), e)) }, y.prototype.queue = function (e, t) { var n = this.queueStore.length; return this.updateCallbacks(t), e.constructor === Array ? this.queueStore = e.reverse().concat(this.queueStore) : this.queueStore.unshift(e), n || (this.callbacks.onBeforeStart && this.callbacks.onBeforeStart(), this.playNext(), this.callbacks.onStart && requestAnimationFrame(this.callbacks.onStart)), this }, y.prototype.resetQueue = function () { return d(this, void 0, void 0, function () { return p(this, function (e) { switch (e.label) { case 0: return [4, i()]; case 1: return e.sent(), this.removeEvents(), this.queueStore = [], [4, this.reset()]; case 2: return e.sent(), [2, this] } }) }) }, y.prototype.chain = function (t, n) { return d(this, void 0, void 0, function () { return p(this, function (e) { switch (e.label) { case 0: return [4, this.resetQueue()]; case 1: return e.sent(), this.queue(t, n), [2, this] } }) }) }, y.prototype.getAnimationName = function (e) { switch (e.constructor) { case Array: return e.map(this.getAnimationName).join(", "); case String: return e.split(" ")[0]; default: return e.name } }, y.playCSS = function (e) { function t(e) { var t = o({ duration: "0s", timingFunction: "ease", delay: "0s", iterationCount: 1, direction: "normal", fillMode: "forwards" }, e); return [t.name, t.duration, t.timingFunction, t.delay, t.iterationCount, t.direction, t.fillMode].join(" ") } if (e.constructor !== Array) return e.constructor === String ? e : t(e); for (var n = e, r = [], i = 0; i < n.length; i += 1)r.push(n[i].constructor === String ? n[i] : t(n[i])); return r.join(", ") }, y.generateCSS = function (e) { var t = "@keyframes " + e.name + " {"; for (var n in e) "name" !== n && "media" !== n && "complete" !== n && (t += n + " {" + h(e[n]) + "}"); return t += "}", e.media && (t = "@media " + e.media + "{" + t + "}"), t }, y.generate = function (e) { var t = this.generateCSS(e), n = y.rules.indexOf(e.name); -1 < n && (y.sheet.deleteRule(n), y.rules.splice(n, 1)); var r = (y.sheet.cssRules || y.sheet.rules).length; y.sheet.insertRule(t, r), y.rules[r] = e.name }, y.define = function (e) { if (e.length) for (var t = 0; t < e.length; t += 1)this.generate(e[t]); else this.generate(e) }, y.defineCSS = function (e) { if (e.length) { for (var t = "", n = 0; n < e.length; n += 1)t += this.generateCSS(e[n]); return t } return this.generateCSS(e) }, y.plugin = function (e) { if (e.constructor === Array) for (var t = 0; t < e.length; t += 1)e[t](this); else e(this) }, y.sheet = a, y.rules = [], y); function y(e) { this.queueStore = [], this.callbacks = { onStart: f, onBeforeStart: f, onIteration: f, onEnd: f }, this.animationendListener = f, this.animationiterationListener = f, this.mountedElement = e } l && (window.Keyframes = m), n.default = m }, { "add-px-to-style": 3, "hyphenate-style-name": 4 }], 3: [function (e, t, n) { "use strict"; var r = { animationIterationCount: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridColumn: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, stopOpacity: !0, strokeDashoffset: !0, strokeOpacity: !0, strokeWidth: !0 }; t.exports = function (e, t) { return "number" != typeof t || r[e] ? t : t + "px" } }, {}], 4: [function (e, t, n) { "use strict"; var r = /[A-Z]/g, i = /^ms-/, o = {}; function a(e) { return "-" + e.toLowerCase() } t.exports = function (e) { if (o.hasOwnProperty(e)) return o[e]; var t = e.replace(r, a); return o[e] = i.test(t) ? "-" + t : t } }, {}] }, {}, [1]);


			/***/
		}),

/***/ "./node_modules/lightbox2/dist/js/lightbox.js":
/*!****************************************************!*\
  !*** ./node_modules/lightbox2/dist/js/lightbox.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Lightbox v2.11.3
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 *
 * @preserve
 */

			// Uses Node, AMD or browser globals to create a module.
			(function (root, factory) {
				if (true) {
					// AMD. Register as an anonymous module.
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }
			}(this, function ($) {

				function Lightbox(options) {
					this.album = [];
					this.currentImageIndex = void 0;
					this.init();

					// options
					this.options = $.extend({}, this.constructor.defaults);
					this.option(options);
				}

				// Descriptions of all options available on the demo site:
				// http://lokeshdhakar.com/projects/lightbox2/index.html#options
				Lightbox.defaults = {
					albumLabel: 'Image %1 of %2',
					alwaysShowNavOnTouchDevices: false,
					fadeDuration: 600,
					fitImagesInViewport: true,
					imageFadeDuration: 600,
					// maxWidth: 800,
					// maxHeight: 600,
					positionFromTop: 50,
					resizeDuration: 700,
					showImageNumberLabel: true,
					wrapAround: false,
					disableScrolling: false,
					/*
					Sanitize Title
					If the caption data is trusted, for example you are hardcoding it in, then leave this to false.
					This will free you to add html tags, such as links, in the caption.
			
					If the caption data is user submitted or from some other untrusted source, then set this to true
					to prevent xss and other injection attacks.
					 */
					sanitizeTitle: false
				};

				Lightbox.prototype.option = function (options) {
					$.extend(this.options, options);
				};

				Lightbox.prototype.imageCountLabel = function (currentImageNum, totalImages) {
					return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
				};

				Lightbox.prototype.init = function () {
					var self = this;
					// Both enable and build methods require the body tag to be in the DOM.
					$(document).ready(function () {
						self.enable();
						self.build();
					});
				};

				// Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
				// that contain 'lightbox'. When these are clicked, start lightbox.
				Lightbox.prototype.enable = function () {
					var self = this;
					$('body').on('click', 'a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]', function (event) {
						self.start($(event.currentTarget));
						return false;
					});
				};

				// Build html for the lightbox and the overlay.
				// Attach event handlers to the new DOM elements. click click click
				Lightbox.prototype.build = function () {
					if ($('#lightbox').length > 0) {
						return;
					}

					var self = this;

					// The two root notes generated, #lightboxOverlay and #lightbox are given
					// tabindex attrs so they are focusable. We attach our keyboard event
					// listeners to these two elements, and not the document. Clicking anywhere
					// while Lightbox is opened will keep the focus on or inside one of these
					// two elements.
					//
					// We do this so we can prevent propogation of the Esc keypress when
					// Lightbox is open. This prevents it from intefering with other components
					// on the page below.
					//
					// Github issue: https://github.com/lokesh/lightbox2/issues/663
					$('<div id="lightboxOverlay" tabindex="-1" class="lightboxOverlay"></div><div id="lightbox" tabindex="-1" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" alt=""/><div class="lb-nav"><a class="lb-prev" aria-label="Previous image" href="" ></a><a class="lb-next" aria-label="Next image" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));

					// Cache jQuery objects
					this.$lightbox = $('#lightbox');
					this.$overlay = $('#lightboxOverlay');
					this.$outerContainer = this.$lightbox.find('.lb-outerContainer');
					this.$container = this.$lightbox.find('.lb-container');
					this.$image = this.$lightbox.find('.lb-image');
					this.$nav = this.$lightbox.find('.lb-nav');

					// Store css values for future lookup
					this.containerPadding = {
						top: parseInt(this.$container.css('padding-top'), 10),
						right: parseInt(this.$container.css('padding-right'), 10),
						bottom: parseInt(this.$container.css('padding-bottom'), 10),
						left: parseInt(this.$container.css('padding-left'), 10)
					};

					this.imageBorderWidth = {
						top: parseInt(this.$image.css('border-top-width'), 10),
						right: parseInt(this.$image.css('border-right-width'), 10),
						bottom: parseInt(this.$image.css('border-bottom-width'), 10),
						left: parseInt(this.$image.css('border-left-width'), 10)
					};

					// Attach event handlers to the newly minted DOM elements
					this.$overlay.hide().on('click', function () {
						self.end();
						return false;
					});

					this.$lightbox.hide().on('click', function (event) {
						if ($(event.target).attr('id') === 'lightbox') {
							self.end();
						}
					});

					this.$outerContainer.on('click', function (event) {
						if ($(event.target).attr('id') === 'lightbox') {
							self.end();
						}
						return false;
					});

					this.$lightbox.find('.lb-prev').on('click', function () {
						if (self.currentImageIndex === 0) {
							self.changeImage(self.album.length - 1);
						} else {
							self.changeImage(self.currentImageIndex - 1);
						}
						return false;
					});

					this.$lightbox.find('.lb-next').on('click', function () {
						if (self.currentImageIndex === self.album.length - 1) {
							self.changeImage(0);
						} else {
							self.changeImage(self.currentImageIndex + 1);
						}
						return false;
					});

					/*
						Show context menu for image on right-click
			
						There is a div containing the navigation that spans the entire image and lives above of it. If
						you right-click, you are right clicking this div and not the image. This prevents users from
						saving the image or using other context menu actions with the image.
			
						To fix this, when we detect the right mouse button is pressed down, but not yet clicked, we
						set pointer-events to none on the nav div. This is so that the upcoming right-click event on
						the next mouseup will bubble down to the image. Once the right-click/contextmenu event occurs
						we set the pointer events back to auto for the nav div so it can capture hover and left-click
						events as usual.
					 */
					this.$nav.on('mousedown', function (event) {
						if (event.which === 3) {
							self.$nav.css('pointer-events', 'none');

							self.$lightbox.one('contextmenu', function () {
								setTimeout(function () {
									this.$nav.css('pointer-events', 'auto');
								}.bind(self), 0);
							});
						}
					});


					this.$lightbox.find('.lb-loader, .lb-close').on('click', function () {
						self.end();
						return false;
					});
				};

				// Show overlay and lightbox. If the image is part of a set, add siblings to album array.
				Lightbox.prototype.start = function ($link) {
					var self = this;
					var $window = $(window);

					$window.on('resize', $.proxy(this.sizeOverlay, this));

					this.sizeOverlay();

					this.album = [];
					var imageNumber = 0;

					function addToAlbum($link) {
						self.album.push({
							alt: $link.attr('data-alt'),
							link: $link.attr('href'),
							title: $link.attr('data-title') || $link.attr('title')
						});
					}

					// Support both data-lightbox attribute and rel attribute implementations
					var dataLightboxValue = $link.attr('data-lightbox');
					var $links;

					if (dataLightboxValue) {
						$links = $($link.prop('tagName') + '[data-lightbox="' + dataLightboxValue + '"]');
						for (var i = 0; i < $links.length; i = ++i) {
							addToAlbum($($links[i]));
							if ($links[i] === $link[0]) {
								imageNumber = i;
							}
						}
					} else {
						if ($link.attr('rel') === 'lightbox') {
							// If image is not part of a set
							addToAlbum($link);
						} else {
							// If image is part of a set
							$links = $($link.prop('tagName') + '[rel="' + $link.attr('rel') + '"]');
							for (var j = 0; j < $links.length; j = ++j) {
								addToAlbum($($links[j]));
								if ($links[j] === $link[0]) {
									imageNumber = j;
								}
							}
						}
					}

					// Position Lightbox
					var top = $window.scrollTop() + this.options.positionFromTop;
					var left = $window.scrollLeft();
					this.$lightbox.css({
						top: top + 'px',
						left: left + 'px'
					}).fadeIn(this.options.fadeDuration);

					// Disable scrolling of the page while open
					if (this.options.disableScrolling) {
						$('body').addClass('lb-disable-scrolling');
					}

					this.changeImage(imageNumber);
				};

				// Hide most UI elements in preparation for the animated resizing of the lightbox.
				Lightbox.prototype.changeImage = function (imageNumber) {
					var self = this;
					var filename = this.album[imageNumber].link;
					var filetype = filename.split('.').slice(-1)[0];
					var $image = this.$lightbox.find('.lb-image');

					// Disable keyboard nav during transitions
					this.disableKeyboardNav();

					// Show loading state
					this.$overlay.fadeIn(this.options.fadeDuration);
					$('.lb-loader').fadeIn('slow');
					this.$lightbox.find('.lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption').hide();
					this.$outerContainer.addClass('animating');

					// When image to show is preloaded, we send the width and height to sizeContainer()
					var preloader = new Image();
					preloader.onload = function () {
						var $preloader;
						var imageHeight;
						var imageWidth;
						var maxImageHeight;
						var maxImageWidth;
						var windowHeight;
						var windowWidth;

						$image.attr({
							'alt': self.album[imageNumber].alt,
							'src': filename
						});

						$preloader = $(preloader);

						$image.width(preloader.width);
						$image.height(preloader.height);
						windowWidth = $(window).width();
						windowHeight = $(window).height();

						// Calculate the max image dimensions for the current viewport.
						// Take into account the border around the image and an additional 10px gutter on each side.
						maxImageWidth = windowWidth - self.containerPadding.left - self.containerPadding.right - self.imageBorderWidth.left - self.imageBorderWidth.right - 20;
						maxImageHeight = windowHeight - self.containerPadding.top - self.containerPadding.bottom - self.imageBorderWidth.top - self.imageBorderWidth.bottom - self.options.positionFromTop - 70;

						/*
						Since many SVGs have small intrinsic dimensions, but they support scaling
						up without quality loss because of their vector format, max out their
						size.
						*/
						if (filetype === 'svg') {
							$image.width(maxImageWidth);
							$image.height(maxImageHeight);
						}

						// Fit image inside the viewport.
						if (self.options.fitImagesInViewport) {

							// Check if image size is larger then maxWidth|maxHeight in settings
							if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
								maxImageWidth = self.options.maxWidth;
							}
							if (self.options.maxHeight && self.options.maxHeight < maxImageHeight) {
								maxImageHeight = self.options.maxHeight;
							}

						} else {
							maxImageWidth = self.options.maxWidth || preloader.width || maxImageWidth;
							maxImageHeight = self.options.maxHeight || preloader.height || maxImageHeight;
						}

						// Is the current image's width or height is greater than the maxImageWidth or maxImageHeight
						// option than we need to size down while maintaining the aspect ratio.
						if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
							if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
								imageWidth = maxImageWidth;
								imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
								$image.width(imageWidth);
								$image.height(imageHeight);
							} else {
								imageHeight = maxImageHeight;
								imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
								$image.width(imageWidth);
								$image.height(imageHeight);
							}
						}
						self.sizeContainer($image.width(), $image.height());
					};

					// Preload image before showing
					preloader.src = this.album[imageNumber].link;
					this.currentImageIndex = imageNumber;
				};

				// Stretch overlay to fit the viewport
				Lightbox.prototype.sizeOverlay = function () {
					var self = this;
					/*
					We use a setTimeout 0 to pause JS execution and let the rendering catch-up.
					Why do this? If the `disableScrolling` option is set to true, a class is added to the body
					tag that disables scrolling and hides the scrollbar. We want to make sure the scrollbar is
					hidden before we measure the document width, as the presence of the scrollbar will affect the
					number.
					*/
					setTimeout(function () {
						self.$overlay
							.width($(document).width())
							.height($(document).height());

					}, 0);
				};

				// Animate the size of the lightbox to fit the image we are showing
				// This method also shows the the image.
				Lightbox.prototype.sizeContainer = function (imageWidth, imageHeight) {
					var self = this;

					var oldWidth = this.$outerContainer.outerWidth();
					var oldHeight = this.$outerContainer.outerHeight();
					var newWidth = imageWidth + this.containerPadding.left + this.containerPadding.right + this.imageBorderWidth.left + this.imageBorderWidth.right;
					var newHeight = imageHeight + this.containerPadding.top + this.containerPadding.bottom + this.imageBorderWidth.top + this.imageBorderWidth.bottom;

					function postResize() {
						self.$lightbox.find('.lb-dataContainer').width(newWidth);
						self.$lightbox.find('.lb-prevLink').height(newHeight);
						self.$lightbox.find('.lb-nextLink').height(newHeight);

						// Set focus on one of the two root nodes so keyboard events are captured.
						self.$overlay.focus();

						self.showImage();
					}

					if (oldWidth !== newWidth || oldHeight !== newHeight) {
						this.$outerContainer.animate({
							width: newWidth,
							height: newHeight
						}, this.options.resizeDuration, 'swing', function () {
							postResize();
						});
					} else {
						postResize();
					}
				};

				// Display the image and its details and begin preload neighboring images.
				Lightbox.prototype.showImage = function () {
					this.$lightbox.find('.lb-loader').stop(true).hide();
					this.$lightbox.find('.lb-image').fadeIn(this.options.imageFadeDuration);

					this.updateNav();
					this.updateDetails();
					this.preloadNeighboringImages();
					this.enableKeyboardNav();
				};

				// Display previous and next navigation if appropriate.
				Lightbox.prototype.updateNav = function () {
					// Check to see if the browser supports touch events. If so, we take the conservative approach
					// and assume that mouse hover events are not supported and always show prev/next navigation
					// arrows in image sets.
					var alwaysShowNav = false;
					try {
						document.createEvent('TouchEvent');
						alwaysShowNav = (this.options.alwaysShowNavOnTouchDevices) ? true : false;
					} catch (e) { }

					this.$lightbox.find('.lb-nav').show();

					if (this.album.length > 1) {
						if (this.options.wrapAround) {
							if (alwaysShowNav) {
								this.$lightbox.find('.lb-prev, .lb-next').css('opacity', '1');
							}
							this.$lightbox.find('.lb-prev, .lb-next').show();
						} else {
							if (this.currentImageIndex > 0) {
								this.$lightbox.find('.lb-prev').show();
								if (alwaysShowNav) {
									this.$lightbox.find('.lb-prev').css('opacity', '1');
								}
							}
							if (this.currentImageIndex < this.album.length - 1) {
								this.$lightbox.find('.lb-next').show();
								if (alwaysShowNav) {
									this.$lightbox.find('.lb-next').css('opacity', '1');
								}
							}
						}
					}
				};

				// Display caption, image number, and closing button.
				Lightbox.prototype.updateDetails = function () {
					var self = this;

					// Enable anchor clicks in the injected caption html.
					// Thanks Nate Wright for the fix. @https://github.com/NateWr
					if (typeof this.album[this.currentImageIndex].title !== 'undefined' &&
						this.album[this.currentImageIndex].title !== '') {
						var $caption = this.$lightbox.find('.lb-caption');
						if (this.options.sanitizeTitle) {
							$caption.text(this.album[this.currentImageIndex].title);
						} else {
							$caption.html(this.album[this.currentImageIndex].title);
						}
						$caption.fadeIn('fast');
					}

					if (this.album.length > 1 && this.options.showImageNumberLabel) {
						var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
						this.$lightbox.find('.lb-number').text(labelText).fadeIn('fast');
					} else {
						this.$lightbox.find('.lb-number').hide();
					}

					this.$outerContainer.removeClass('animating');

					this.$lightbox.find('.lb-dataContainer').fadeIn(this.options.resizeDuration, function () {
						return self.sizeOverlay();
					});
				};

				// Preload previous and next images in set.
				Lightbox.prototype.preloadNeighboringImages = function () {
					if (this.album.length > this.currentImageIndex + 1) {
						var preloadNext = new Image();
						preloadNext.src = this.album[this.currentImageIndex + 1].link;
					}
					if (this.currentImageIndex > 0) {
						var preloadPrev = new Image();
						preloadPrev.src = this.album[this.currentImageIndex - 1].link;
					}
				};

				Lightbox.prototype.enableKeyboardNav = function () {
					this.$lightbox.on('keyup.keyboard', $.proxy(this.keyboardAction, this));
					this.$overlay.on('keyup.keyboard', $.proxy(this.keyboardAction, this));
				};

				Lightbox.prototype.disableKeyboardNav = function () {
					this.$lightbox.off('.keyboard');
					this.$overlay.off('.keyboard');
				};

				Lightbox.prototype.keyboardAction = function (event) {
					var KEYCODE_ESC = 27;
					var KEYCODE_LEFTARROW = 37;
					var KEYCODE_RIGHTARROW = 39;

					var keycode = event.keyCode;
					if (keycode === KEYCODE_ESC) {
						// Prevent bubbling so as to not affect other components on the page.
						event.stopPropagation();
						this.end();
					} else if (keycode === KEYCODE_LEFTARROW) {
						if (this.currentImageIndex !== 0) {
							this.changeImage(this.currentImageIndex - 1);
						} else if (this.options.wrapAround && this.album.length > 1) {
							this.changeImage(this.album.length - 1);
						}
					} else if (keycode === KEYCODE_RIGHTARROW) {
						if (this.currentImageIndex !== this.album.length - 1) {
							this.changeImage(this.currentImageIndex + 1);
						} else if (this.options.wrapAround && this.album.length > 1) {
							this.changeImage(0);
						}
					}
				};

				// Closing time. :-(
				Lightbox.prototype.end = function () {
					this.disableKeyboardNav();
					$(window).off('resize', this.sizeOverlay);
					this.$lightbox.fadeOut(this.options.fadeDuration);
					this.$overlay.fadeOut(this.options.fadeDuration);

					if (this.options.disableScrolling) {
						$('body').removeClass('lb-disable-scrolling');
					}
				};

				return new Lightbox();
			}));


			/***/
		}),

/***/ "./node_modules/masonry-layout/masonry.js":
/*!************************************************!*\
  !*** ./node_modules/masonry-layout/masonry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Masonry v4.2.2
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

			(function (window, factory) {
				// universal module definition
				/* jshint strict: false */ /*globals define, module, require */
				if (true) {
					// AMD
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
						__webpack_require__(/*! outlayer/outlayer */ "./node_modules/outlayer/outlayer.js"),
						__webpack_require__(/*! get-size/get-size */ "./node_modules/get-size/get-size.js")
					], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory(Outlayer, getSize) {

				'use strict';

				// -------------------------- masonryDefinition -------------------------- //

				// create an Outlayer layout class
				var Masonry = Outlayer.create('masonry');
				// isFitWidth -> fitWidth
				Masonry.compatOptions.fitWidth = 'isFitWidth';

				var proto = Masonry.prototype;

				proto._resetLayout = function () {
					this.getSize();
					this._getMeasurement('columnWidth', 'outerWidth');
					this._getMeasurement('gutter', 'outerWidth');
					this.measureColumns();

					// reset column Y
					this.colYs = [];
					for (var i = 0; i < this.cols; i++) {
						this.colYs.push(0);
					}

					this.maxY = 0;
					this.horizontalColIndex = 0;
				};

				proto.measureColumns = function () {
					this.getContainerWidth();
					// if columnWidth is 0, default to outerWidth of first item
					if (!this.columnWidth) {
						var firstItem = this.items[0];
						var firstItemElem = firstItem && firstItem.element;
						// columnWidth fall back to item of first element
						this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth ||
							// if first elem has no width, default to size of container
							this.containerWidth;
					}

					var columnWidth = this.columnWidth += this.gutter;

					// calculate columns
					var containerWidth = this.containerWidth + this.gutter;
					var cols = containerWidth / columnWidth;
					// fix rounding errors, typically with gutters
					var excess = columnWidth - containerWidth % columnWidth;
					// if overshoot is less than a pixel, round up, otherwise floor it
					var mathMethod = excess && excess < 1 ? 'round' : 'floor';
					cols = Math[mathMethod](cols);
					this.cols = Math.max(cols, 1);
				};

				proto.getContainerWidth = function () {
					// container is parent if fit width
					var isFitWidth = this._getOption('fitWidth');
					var container = isFitWidth ? this.element.parentNode : this.element;
					// check that this.size and size are there
					// IE8 triggers resize on body size change, so they might not be
					var size = getSize(container);
					this.containerWidth = size && size.innerWidth;
				};

				proto._getItemLayoutPosition = function (item) {
					item.getSize();
					// how many columns does this brick span
					var remainder = item.size.outerWidth % this.columnWidth;
					var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
					// round if off by 1 pixel, otherwise use ceil
					var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
					colSpan = Math.min(colSpan, this.cols);
					// use horizontal or top column position
					var colPosMethod = this.options.horizontalOrder ?
						'_getHorizontalColPosition' : '_getTopColPosition';
					var colPosition = this[colPosMethod](colSpan, item);
					// position the brick
					var position = {
						x: this.columnWidth * colPosition.col,
						y: colPosition.y
					};
					// apply setHeight to necessary columns
					var setHeight = colPosition.y + item.size.outerHeight;
					var setMax = colSpan + colPosition.col;
					for (var i = colPosition.col; i < setMax; i++) {
						this.colYs[i] = setHeight;
					}

					return position;
				};

				proto._getTopColPosition = function (colSpan) {
					var colGroup = this._getTopColGroup(colSpan);
					// get the minimum Y value from the columns
					var minimumY = Math.min.apply(Math, colGroup);

					return {
						col: colGroup.indexOf(minimumY),
						y: minimumY,
					};
				};

				/**
				 * @param {Number} colSpan - number of columns the element spans
				 * @returns {Array} colGroup
				 */
				proto._getTopColGroup = function (colSpan) {
					if (colSpan < 2) {
						// if brick spans only one column, use all the column Ys
						return this.colYs;
					}

					var colGroup = [];
					// how many different places could this brick fit horizontally
					var groupCount = this.cols + 1 - colSpan;
					// for each group potential horizontal position
					for (var i = 0; i < groupCount; i++) {
						colGroup[i] = this._getColGroupY(i, colSpan);
					}
					return colGroup;
				};

				proto._getColGroupY = function (col, colSpan) {
					if (colSpan < 2) {
						return this.colYs[col];
					}
					// make an array of colY values for that one group
					var groupColYs = this.colYs.slice(col, col + colSpan);
					// and get the max value of the array
					return Math.max.apply(Math, groupColYs);
				};

				// get column position based on horizontal index. #873
				proto._getHorizontalColPosition = function (colSpan, item) {
					var col = this.horizontalColIndex % this.cols;
					var isOver = colSpan > 1 && col + colSpan > this.cols;
					// shift to next row if item can't fit on current row
					col = isOver ? 0 : col;
					// don't let zero-size items take up space
					var hasSize = item.size.outerWidth && item.size.outerHeight;
					this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;

					return {
						col: col,
						y: this._getColGroupY(col, colSpan),
					};
				};

				proto._manageStamp = function (stamp) {
					var stampSize = getSize(stamp);
					var offset = this._getElementOffset(stamp);
					// get the columns that this stamp affects
					var isOriginLeft = this._getOption('originLeft');
					var firstX = isOriginLeft ? offset.left : offset.right;
					var lastX = firstX + stampSize.outerWidth;
					var firstCol = Math.floor(firstX / this.columnWidth);
					firstCol = Math.max(0, firstCol);
					var lastCol = Math.floor(lastX / this.columnWidth);
					// lastCol should not go over if multiple of columnWidth #425
					lastCol -= lastX % this.columnWidth ? 0 : 1;
					lastCol = Math.min(this.cols - 1, lastCol);
					// set colYs to bottom of the stamp

					var isOriginTop = this._getOption('originTop');
					var stampMaxY = (isOriginTop ? offset.top : offset.bottom) +
						stampSize.outerHeight;
					for (var i = firstCol; i <= lastCol; i++) {
						this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
					}
				};

				proto._getContainerSize = function () {
					this.maxY = Math.max.apply(Math, this.colYs);
					var size = {
						height: this.maxY
					};

					if (this._getOption('fitWidth')) {
						size.width = this._getContainerFitWidth();
					}

					return size;
				};

				proto._getContainerFitWidth = function () {
					var unusedCols = 0;
					// count unused columns
					var i = this.cols;
					while (--i) {
						if (this.colYs[i] !== 0) {
							break;
						}
						unusedCols++;
					}
					// fit container to columns that have been used
					return (this.cols - unusedCols) * this.columnWidth - this.gutter;
				};

				proto.needsResizeLayout = function () {
					var previousWidth = this.containerWidth;
					this.getContainerWidth();
					return previousWidth != this.containerWidth;
				};

				return Masonry;

			}));


			/***/
		}),

/***/ "./node_modules/outlayer/item.js":
/*!***************************************!*\
  !*** ./node_modules/outlayer/item.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Outlayer Item
 */

			(function (window, factory) {
				// universal module definition
				/* jshint strict: false */ /* globals define, module, require */
				if (true) {
					// AMD - RequireJS
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
						__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js"),
						__webpack_require__(/*! get-size/get-size */ "./node_modules/get-size/get-size.js")
					], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory(EvEmitter, getSize) {
				'use strict';

				// ----- helpers ----- //

				function isEmptyObj(obj) {
					for (var prop in obj) {
						return false;
					}
					prop = null;
					return true;
				}

				// -------------------------- CSS3 support -------------------------- //


				var docElemStyle = document.documentElement.style;

				var transitionProperty = typeof docElemStyle.transition == 'string' ?
					'transition' : 'WebkitTransition';
				var transformProperty = typeof docElemStyle.transform == 'string' ?
					'transform' : 'WebkitTransform';

				var transitionEndEvent = {
					WebkitTransition: 'webkitTransitionEnd',
					transition: 'transitionend'
				}[transitionProperty];

				// cache all vendor properties that could have vendor prefix
				var vendorProperties = {
					transform: transformProperty,
					transition: transitionProperty,
					transitionDuration: transitionProperty + 'Duration',
					transitionProperty: transitionProperty + 'Property',
					transitionDelay: transitionProperty + 'Delay'
				};

				// -------------------------- Item -------------------------- //

				function Item(element, layout) {
					if (!element) {
						return;
					}

					this.element = element;
					// parent layout class, i.e. Masonry, Isotope, or Packery
					this.layout = layout;
					this.position = {
						x: 0,
						y: 0
					};

					this._create();
				}

				// inherit EvEmitter
				var proto = Item.prototype = Object.create(EvEmitter.prototype);
				proto.constructor = Item;

				proto._create = function () {
					// transition objects
					this._transn = {
						ingProperties: {},
						clean: {},
						onEnd: {}
					};

					this.css({
						position: 'absolute'
					});
				};

				// trigger specified handler for event type
				proto.handleEvent = function (event) {
					var method = 'on' + event.type;
					if (this[method]) {
						this[method](event);
					}
				};

				proto.getSize = function () {
					this.size = getSize(this.element);
				};

				/**
				 * apply CSS styles to element
				 * @param {Object} style
				 */
				proto.css = function (style) {
					var elemStyle = this.element.style;

					for (var prop in style) {
						// use vendor property if available
						var supportedProp = vendorProperties[prop] || prop;
						elemStyle[supportedProp] = style[prop];
					}
				};

				// measure position, and sets it
				proto.getPosition = function () {
					var style = getComputedStyle(this.element);
					var isOriginLeft = this.layout._getOption('originLeft');
					var isOriginTop = this.layout._getOption('originTop');
					var xValue = style[isOriginLeft ? 'left' : 'right'];
					var yValue = style[isOriginTop ? 'top' : 'bottom'];
					var x = parseFloat(xValue);
					var y = parseFloat(yValue);
					// convert percent to pixels
					var layoutSize = this.layout.size;
					if (xValue.indexOf('%') != -1) {
						x = (x / 100) * layoutSize.width;
					}
					if (yValue.indexOf('%') != -1) {
						y = (y / 100) * layoutSize.height;
					}
					// clean up 'auto' or other non-integer values
					x = isNaN(x) ? 0 : x;
					y = isNaN(y) ? 0 : y;
					// remove padding from measurement
					x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
					y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

					this.position.x = x;
					this.position.y = y;
				};

				// set settled position, apply padding
				proto.layoutPosition = function () {
					var layoutSize = this.layout.size;
					var style = {};
					var isOriginLeft = this.layout._getOption('originLeft');
					var isOriginTop = this.layout._getOption('originTop');

					// x
					var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
					var xProperty = isOriginLeft ? 'left' : 'right';
					var xResetProperty = isOriginLeft ? 'right' : 'left';

					var x = this.position.x + layoutSize[xPadding];
					// set in percentage or pixels
					style[xProperty] = this.getXValue(x);
					// reset other property
					style[xResetProperty] = '';

					// y
					var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
					var yProperty = isOriginTop ? 'top' : 'bottom';
					var yResetProperty = isOriginTop ? 'bottom' : 'top';

					var y = this.position.y + layoutSize[yPadding];
					// set in percentage or pixels
					style[yProperty] = this.getYValue(y);
					// reset other property
					style[yResetProperty] = '';

					this.css(style);
					this.emitEvent('layout', [this]);
				};

				proto.getXValue = function (x) {
					var isHorizontal = this.layout._getOption('horizontal');
					return this.layout.options.percentPosition && !isHorizontal ?
						((x / this.layout.size.width) * 100) + '%' : x + 'px';
				};

				proto.getYValue = function (y) {
					var isHorizontal = this.layout._getOption('horizontal');
					return this.layout.options.percentPosition && isHorizontal ?
						((y / this.layout.size.height) * 100) + '%' : y + 'px';
				};

				proto._transitionTo = function (x, y) {
					this.getPosition();
					// get current x & y from top/left
					var curX = this.position.x;
					var curY = this.position.y;

					var didNotMove = x == this.position.x && y == this.position.y;

					// save end position
					this.setPosition(x, y);

					// if did not move and not transitioning, just go to layout
					if (didNotMove && !this.isTransitioning) {
						this.layoutPosition();
						return;
					}

					var transX = x - curX;
					var transY = y - curY;
					var transitionStyle = {};
					transitionStyle.transform = this.getTranslate(transX, transY);

					this.transition({
						to: transitionStyle,
						onTransitionEnd: {
							transform: this.layoutPosition
						},
						isCleaning: true
					});
				};

				proto.getTranslate = function (x, y) {
					// flip cooridinates if origin on right or bottom
					var isOriginLeft = this.layout._getOption('originLeft');
					var isOriginTop = this.layout._getOption('originTop');
					x = isOriginLeft ? x : -x;
					y = isOriginTop ? y : -y;
					return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
				};

				// non transition + transform support
				proto.goTo = function (x, y) {
					this.setPosition(x, y);
					this.layoutPosition();
				};

				proto.moveTo = proto._transitionTo;

				proto.setPosition = function (x, y) {
					this.position.x = parseFloat(x);
					this.position.y = parseFloat(y);
				};

				// ----- transition ----- //

				/**
				 * @param {Object} style - CSS
				 * @param {Function} onTransitionEnd
				 */

				// non transition, just trigger callback
				proto._nonTransition = function (args) {
					this.css(args.to);
					if (args.isCleaning) {
						this._removeStyles(args.to);
					}
					for (var prop in args.onTransitionEnd) {
						args.onTransitionEnd[prop].call(this);
					}
				};

				/**
				 * proper transition
				 * @param {Object} args - arguments
				 *   @param {Object} to - style to transition to
				 *   @param {Object} from - style to start transition from
				 *   @param {Boolean} isCleaning - removes transition styles after transition
				 *   @param {Function} onTransitionEnd - callback
				 */
				proto.transition = function (args) {
					// redirect to nonTransition if no transition duration
					if (!parseFloat(this.layout.options.transitionDuration)) {
						this._nonTransition(args);
						return;
					}

					var _transition = this._transn;
					// keep track of onTransitionEnd callback by css property
					for (var prop in args.onTransitionEnd) {
						_transition.onEnd[prop] = args.onTransitionEnd[prop];
					}
					// keep track of properties that are transitioning
					for (prop in args.to) {
						_transition.ingProperties[prop] = true;
						// keep track of properties to clean up when transition is done
						if (args.isCleaning) {
							_transition.clean[prop] = true;
						}
					}

					// set from styles
					if (args.from) {
						this.css(args.from);
						// force redraw. http://blog.alexmaccaw.com/css-transitions
						var h = this.element.offsetHeight;
						// hack for JSHint to hush about unused var
						h = null;
					}
					// enable transition
					this.enableTransition(args.to);
					// set styles that are transitioning
					this.css(args.to);

					this.isTransitioning = true;

				};

				// dash before all cap letters, including first for
				// WebkitTransform => -webkit-transform
				function toDashedAll(str) {
					return str.replace(/([A-Z])/g, function ($1) {
						return '-' + $1.toLowerCase();
					});
				}

				var transitionProps = 'opacity,' + toDashedAll(transformProperty);

				proto.enableTransition = function (/* style */) {
					// HACK changing transitionProperty during a transition
					// will cause transition to jump
					if (this.isTransitioning) {
						return;
					}

					// make `transition: foo, bar, baz` from style object
					// HACK un-comment this when enableTransition can work
					// while a transition is happening
					// var transitionValues = [];
					// for ( var prop in style ) {
					//   // dash-ify camelCased properties like WebkitTransition
					//   prop = vendorProperties[ prop ] || prop;
					//   transitionValues.push( toDashedAll( prop ) );
					// }
					// munge number to millisecond, to match stagger
					var duration = this.layout.options.transitionDuration;
					duration = typeof duration == 'number' ? duration + 'ms' : duration;
					// enable transition styles
					this.css({
						transitionProperty: transitionProps,
						transitionDuration: duration,
						transitionDelay: this.staggerDelay || 0
					});
					// listen for transition end event
					this.element.addEventListener(transitionEndEvent, this, false);
				};

				// ----- events ----- //

				proto.onwebkitTransitionEnd = function (event) {
					this.ontransitionend(event);
				};

				proto.onotransitionend = function (event) {
					this.ontransitionend(event);
				};

				// properties that I munge to make my life easier
				var dashedVendorProperties = {
					'-webkit-transform': 'transform'
				};

				proto.ontransitionend = function (event) {
					// disregard bubbled events from children
					if (event.target !== this.element) {
						return;
					}
					var _transition = this._transn;
					// get property name of transitioned property, convert to prefix-free
					var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;

					// remove property that has completed transitioning
					delete _transition.ingProperties[propertyName];
					// check if any properties are still transitioning
					if (isEmptyObj(_transition.ingProperties)) {
						// all properties have completed transitioning
						this.disableTransition();
					}
					// clean style
					if (propertyName in _transition.clean) {
						// clean up style
						this.element.style[event.propertyName] = '';
						delete _transition.clean[propertyName];
					}
					// trigger onTransitionEnd callback
					if (propertyName in _transition.onEnd) {
						var onTransitionEnd = _transition.onEnd[propertyName];
						onTransitionEnd.call(this);
						delete _transition.onEnd[propertyName];
					}

					this.emitEvent('transitionEnd', [this]);
				};

				proto.disableTransition = function () {
					this.removeTransitionStyles();
					this.element.removeEventListener(transitionEndEvent, this, false);
					this.isTransitioning = false;
				};

				/**
				 * removes style property from element
				 * @param {Object} style
				**/
				proto._removeStyles = function (style) {
					// clean up transition styles
					var cleanStyle = {};
					for (var prop in style) {
						cleanStyle[prop] = '';
					}
					this.css(cleanStyle);
				};

				var cleanTransitionStyle = {
					transitionProperty: '',
					transitionDuration: '',
					transitionDelay: ''
				};

				proto.removeTransitionStyles = function () {
					// remove transition
					this.css(cleanTransitionStyle);
				};

				// ----- stagger ----- //

				proto.stagger = function (delay) {
					delay = isNaN(delay) ? 0 : delay;
					this.staggerDelay = delay + 'ms';
				};

				// ----- show/hide/remove ----- //

				// remove element from DOM
				proto.removeElem = function () {
					this.element.parentNode.removeChild(this.element);
					// remove display: none
					this.css({ display: '' });
					this.emitEvent('remove', [this]);
				};

				proto.remove = function () {
					// just remove element if no transition support or no transition
					if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
						this.removeElem();
						return;
					}

					// start transition
					this.once('transitionEnd', function () {
						this.removeElem();
					});
					this.hide();
				};

				proto.reveal = function () {
					delete this.isHidden;
					// remove display: none
					this.css({ display: '' });

					var options = this.layout.options;

					var onTransitionEnd = {};
					var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
					onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;

					this.transition({
						from: options.hiddenStyle,
						to: options.visibleStyle,
						isCleaning: true,
						onTransitionEnd: onTransitionEnd
					});
				};

				proto.onRevealTransitionEnd = function () {
					// check if still visible
					// during transition, item may have been hidden
					if (!this.isHidden) {
						this.emitEvent('reveal');
					}
				};

				/**
				 * get style property use for hide/reveal transition end
				 * @param {String} styleProperty - hiddenStyle/visibleStyle
				 * @returns {String}
				 */
				proto.getHideRevealTransitionEndProperty = function (styleProperty) {
					var optionStyle = this.layout.options[styleProperty];
					// use opacity
					if (optionStyle.opacity) {
						return 'opacity';
					}
					// get first property
					for (var prop in optionStyle) {
						return prop;
					}
				};

				proto.hide = function () {
					// set flag
					this.isHidden = true;
					// remove display: none
					this.css({ display: '' });

					var options = this.layout.options;

					var onTransitionEnd = {};
					var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
					onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;

					this.transition({
						from: options.visibleStyle,
						to: options.hiddenStyle,
						// keep hidden stuff hidden
						isCleaning: true,
						onTransitionEnd: onTransitionEnd
					});
				};

				proto.onHideTransitionEnd = function () {
					// check if still hidden
					// during transition, item may have been un-hidden
					if (this.isHidden) {
						this.css({ display: 'none' });
						this.emitEvent('hide');
					}
				};

				proto.destroy = function () {
					this.css({
						position: '',
						left: '',
						right: '',
						top: '',
						bottom: '',
						transition: '',
						transform: ''
					});
				};

				return Item;

			}));


			/***/
		}),

/***/ "./node_modules/outlayer/outlayer.js":
/*!*******************************************!*\
  !*** ./node_modules/outlayer/outlayer.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Outlayer v2.1.1
 * the brains and guts of a layout library
 * MIT license
 */

			(function (window, factory) {
				'use strict';
				// universal module definition
				/* jshint strict: false */ /* globals define, module, require */
				if (true) {
					// AMD - RequireJS
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
						__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js"),
						__webpack_require__(/*! get-size/get-size */ "./node_modules/get-size/get-size.js"),
						__webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js"),
						__webpack_require__(/*! ./item */ "./node_modules/outlayer/item.js")
					], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter, getSize, utils, Item) {
						return factory(window, EvEmitter, getSize, utils, Item);
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(window, function factory(window, EvEmitter, getSize, utils, Item) {
				'use strict';

				// ----- vars ----- //

				var console = window.console;
				var jQuery = window.jQuery;
				var noop = function () { };

				// -------------------------- Outlayer -------------------------- //

				// globally unique identifiers
				var GUID = 0;
				// internal store of all Outlayer intances
				var instances = {};


				/**
				 * @param {Element, String} element
				 * @param {Object} options
				 * @constructor
				 */
				function Outlayer(element, options) {
					var queryElement = utils.getQueryElement(element);
					if (!queryElement) {
						if (console) {
							console.error('Bad element for ' + this.constructor.namespace +
								': ' + (queryElement || element));
						}
						return;
					}
					this.element = queryElement;
					// add jQuery
					if (jQuery) {
						this.$element = jQuery(this.element);
					}

					// options
					this.options = utils.extend({}, this.constructor.defaults);
					this.option(options);

					// add id for Outlayer.getFromElement
					var id = ++GUID;
					this.element.outlayerGUID = id; // expando
					instances[id] = this; // associate via id

					// kick it off
					this._create();

					var isInitLayout = this._getOption('initLayout');
					if (isInitLayout) {
						this.layout();
					}
				}

				// settings are for internal use only
				Outlayer.namespace = 'outlayer';
				Outlayer.Item = Item;

				// default options
				Outlayer.defaults = {
					containerStyle: {
						position: 'relative'
					},
					initLayout: true,
					originLeft: true,
					originTop: true,
					resize: true,
					resizeContainer: true,
					// item options
					transitionDuration: '0.4s',
					hiddenStyle: {
						opacity: 0,
						transform: 'scale(0.001)'
					},
					visibleStyle: {
						opacity: 1,
						transform: 'scale(1)'
					}
				};

				var proto = Outlayer.prototype;
				// inherit EvEmitter
				utils.extend(proto, EvEmitter.prototype);

				/**
				 * set options
				 * @param {Object} opts
				 */
				proto.option = function (opts) {
					utils.extend(this.options, opts);
				};

				/**
				 * get backwards compatible option value, check old name
				 */
				proto._getOption = function (option) {
					var oldOption = this.constructor.compatOptions[option];
					return oldOption && this.options[oldOption] !== undefined ?
						this.options[oldOption] : this.options[option];
				};

				Outlayer.compatOptions = {
					// currentName: oldName
					initLayout: 'isInitLayout',
					horizontal: 'isHorizontal',
					layoutInstant: 'isLayoutInstant',
					originLeft: 'isOriginLeft',
					originTop: 'isOriginTop',
					resize: 'isResizeBound',
					resizeContainer: 'isResizingContainer'
				};

				proto._create = function () {
					// get items from children
					this.reloadItems();
					// elements that affect layout, but are not laid out
					this.stamps = [];
					this.stamp(this.options.stamp);
					// set container style
					utils.extend(this.element.style, this.options.containerStyle);

					// bind resize method
					var canBindResize = this._getOption('resize');
					if (canBindResize) {
						this.bindResize();
					}
				};

				// goes through all children again and gets bricks in proper order
				proto.reloadItems = function () {
					// collection of item elements
					this.items = this._itemize(this.element.children);
				};


				/**
				 * turn elements into Outlayer.Items to be used in layout
				 * @param {Array or NodeList or HTMLElement} elems
				 * @returns {Array} items - collection of new Outlayer Items
				 */
				proto._itemize = function (elems) {

					var itemElems = this._filterFindItemElements(elems);
					var Item = this.constructor.Item;

					// create new Outlayer Items for collection
					var items = [];
					for (var i = 0; i < itemElems.length; i++) {
						var elem = itemElems[i];
						var item = new Item(elem, this);
						items.push(item);
					}

					return items;
				};

				/**
				 * get item elements to be used in layout
				 * @param {Array or NodeList or HTMLElement} elems
				 * @returns {Array} items - item elements
				 */
				proto._filterFindItemElements = function (elems) {
					return utils.filterFindElements(elems, this.options.itemSelector);
				};

				/**
				 * getter method for getting item elements
				 * @returns {Array} elems - collection of item elements
				 */
				proto.getItemElements = function () {
					return this.items.map(function (item) {
						return item.element;
					});
				};

				// ----- init & layout ----- //

				/**
				 * lays out all items
				 */
				proto.layout = function () {
					this._resetLayout();
					this._manageStamps();

					// don't animate first layout
					var layoutInstant = this._getOption('layoutInstant');
					var isInstant = layoutInstant !== undefined ?
						layoutInstant : !this._isLayoutInited;
					this.layoutItems(this.items, isInstant);

					// flag for initalized
					this._isLayoutInited = true;
				};

				// _init is alias for layout
				proto._init = proto.layout;

				/**
				 * logic before any new layout
				 */
				proto._resetLayout = function () {
					this.getSize();
				};


				proto.getSize = function () {
					this.size = getSize(this.element);
				};

				/**
				 * get measurement from option, for columnWidth, rowHeight, gutter
				 * if option is String -> get element from selector string, & get size of element
				 * if option is Element -> get size of element
				 * else use option as a number
				 *
				 * @param {String} measurement
				 * @param {String} size - width or height
				 * @private
				 */
				proto._getMeasurement = function (measurement, size) {
					var option = this.options[measurement];
					var elem;
					if (!option) {
						// default to 0
						this[measurement] = 0;
					} else {
						// use option as an element
						if (typeof option == 'string') {
							elem = this.element.querySelector(option);
						} else if (option instanceof HTMLElement) {
							elem = option;
						}
						// use size of element, if element
						this[measurement] = elem ? getSize(elem)[size] : option;
					}
				};

				/**
				 * layout a collection of item elements
				 * @api public
				 */
				proto.layoutItems = function (items, isInstant) {
					items = this._getItemsForLayout(items);

					this._layoutItems(items, isInstant);

					this._postLayout();
				};

				/**
				 * get the items to be laid out
				 * you may want to skip over some items
				 * @param {Array} items
				 * @returns {Array} items
				 */
				proto._getItemsForLayout = function (items) {
					return items.filter(function (item) {
						return !item.isIgnored;
					});
				};

				/**
				 * layout items
				 * @param {Array} items
				 * @param {Boolean} isInstant
				 */
				proto._layoutItems = function (items, isInstant) {
					this._emitCompleteOnItems('layout', items);

					if (!items || !items.length) {
						// no items, emit event with empty array
						return;
					}

					var queue = [];

					items.forEach(function (item) {
						// get x/y object from method
						var position = this._getItemLayoutPosition(item);
						// enqueue
						position.item = item;
						position.isInstant = isInstant || item.isLayoutInstant;
						queue.push(position);
					}, this);

					this._processLayoutQueue(queue);
				};

				/**
				 * get item layout position
				 * @param {Outlayer.Item} item
				 * @returns {Object} x and y position
				 */
				proto._getItemLayoutPosition = function ( /* item */) {
					return {
						x: 0,
						y: 0
					};
				};

				/**
				 * iterate over array and position each item
				 * Reason being - separating this logic prevents 'layout invalidation'
				 * thx @paul_irish
				 * @param {Array} queue
				 */
				proto._processLayoutQueue = function (queue) {
					this.updateStagger();
					queue.forEach(function (obj, i) {
						this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
					}, this);
				};

				// set stagger from option in milliseconds number
				proto.updateStagger = function () {
					var stagger = this.options.stagger;
					if (stagger === null || stagger === undefined) {
						this.stagger = 0;
						return;
					}
					this.stagger = getMilliseconds(stagger);
					return this.stagger;
				};

				/**
				 * Sets position of item in DOM
				 * @param {Outlayer.Item} item
				 * @param {Number} x - horizontal position
				 * @param {Number} y - vertical position
				 * @param {Boolean} isInstant - disables transitions
				 */
				proto._positionItem = function (item, x, y, isInstant, i) {
					if (isInstant) {
						// if not transition, just set CSS
						item.goTo(x, y);
					} else {
						item.stagger(i * this.stagger);
						item.moveTo(x, y);
					}
				};

				/**
				 * Any logic you want to do after each layout,
				 * i.e. size the container
				 */
				proto._postLayout = function () {
					this.resizeContainer();
				};

				proto.resizeContainer = function () {
					var isResizingContainer = this._getOption('resizeContainer');
					if (!isResizingContainer) {
						return;
					}
					var size = this._getContainerSize();
					if (size) {
						this._setContainerMeasure(size.width, true);
						this._setContainerMeasure(size.height, false);
					}
				};

				/**
				 * Sets width or height of container if returned
				 * @returns {Object} size
				 *   @param {Number} width
				 *   @param {Number} height
				 */
				proto._getContainerSize = noop;

				/**
				 * @param {Number} measure - size of width or height
				 * @param {Boolean} isWidth
				 */
				proto._setContainerMeasure = function (measure, isWidth) {
					if (measure === undefined) {
						return;
					}

					var elemSize = this.size;
					// add padding and border width if border box
					if (elemSize.isBorderBox) {
						measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
							elemSize.borderLeftWidth + elemSize.borderRightWidth :
							elemSize.paddingBottom + elemSize.paddingTop +
							elemSize.borderTopWidth + elemSize.borderBottomWidth;
					}

					measure = Math.max(measure, 0);
					this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';
				};

				/**
				 * emit eventComplete on a collection of items events
				 * @param {String} eventName
				 * @param {Array} items - Outlayer.Items
				 */
				proto._emitCompleteOnItems = function (eventName, items) {
					var _this = this;
					function onComplete() {
						_this.dispatchEvent(eventName + 'Complete', null, [items]);
					}

					var count = items.length;
					if (!items || !count) {
						onComplete();
						return;
					}

					var doneCount = 0;
					function tick() {
						doneCount++;
						if (doneCount == count) {
							onComplete();
						}
					}

					// bind callback
					items.forEach(function (item) {
						item.once(eventName, tick);
					});
				};

				/**
				 * emits events via EvEmitter and jQuery events
				 * @param {String} type - name of event
				 * @param {Event} event - original event
				 * @param {Array} args - extra arguments
				 */
				proto.dispatchEvent = function (type, event, args) {
					// add original event to arguments
					var emitArgs = event ? [event].concat(args) : args;
					this.emitEvent(type, emitArgs);

					if (jQuery) {
						// set this.$element
						this.$element = this.$element || jQuery(this.element);
						if (event) {
							// create jQuery event
							var $event = jQuery.Event(event);
							$event.type = type;
							this.$element.trigger($event, args);
						} else {
							// just trigger with type if no event available
							this.$element.trigger(type, args);
						}
					}
				};

				// -------------------------- ignore & stamps -------------------------- //


				/**
				 * keep item in collection, but do not lay it out
				 * ignored items do not get skipped in layout
				 * @param {Element} elem
				 */
				proto.ignore = function (elem) {
					var item = this.getItem(elem);
					if (item) {
						item.isIgnored = true;
					}
				};

				/**
				 * return item to layout collection
				 * @param {Element} elem
				 */
				proto.unignore = function (elem) {
					var item = this.getItem(elem);
					if (item) {
						delete item.isIgnored;
					}
				};

				/**
				 * adds elements to stamps
				 * @param {NodeList, Array, Element, or String} elems
				 */
				proto.stamp = function (elems) {
					elems = this._find(elems);
					if (!elems) {
						return;
					}

					this.stamps = this.stamps.concat(elems);
					// ignore
					elems.forEach(this.ignore, this);
				};

				/**
				 * removes elements to stamps
				 * @param {NodeList, Array, or Element} elems
				 */
				proto.unstamp = function (elems) {
					elems = this._find(elems);
					if (!elems) {
						return;
					}

					elems.forEach(function (elem) {
						// filter out removed stamp elements
						utils.removeFrom(this.stamps, elem);
						this.unignore(elem);
					}, this);
				};

				/**
				 * finds child elements
				 * @param {NodeList, Array, Element, or String} elems
				 * @returns {Array} elems
				 */
				proto._find = function (elems) {
					if (!elems) {
						return;
					}
					// if string, use argument as selector string
					if (typeof elems == 'string') {
						elems = this.element.querySelectorAll(elems);
					}
					elems = utils.makeArray(elems);
					return elems;
				};

				proto._manageStamps = function () {
					if (!this.stamps || !this.stamps.length) {
						return;
					}

					this._getBoundingRect();

					this.stamps.forEach(this._manageStamp, this);
				};

				// update boundingLeft / Top
				proto._getBoundingRect = function () {
					// get bounding rect for container element
					var boundingRect = this.element.getBoundingClientRect();
					var size = this.size;
					this._boundingRect = {
						left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
						top: boundingRect.top + size.paddingTop + size.borderTopWidth,
						right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
						bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
					};
				};

				/**
				 * @param {Element} stamp
				**/
				proto._manageStamp = noop;

				/**
				 * get x/y position of element relative to container element
				 * @param {Element} elem
				 * @returns {Object} offset - has left, top, right, bottom
				 */
				proto._getElementOffset = function (elem) {
					var boundingRect = elem.getBoundingClientRect();
					var thisRect = this._boundingRect;
					var size = getSize(elem);
					var offset = {
						left: boundingRect.left - thisRect.left - size.marginLeft,
						top: boundingRect.top - thisRect.top - size.marginTop,
						right: thisRect.right - boundingRect.right - size.marginRight,
						bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
					};
					return offset;
				};

				// -------------------------- resize -------------------------- //

				// enable event handlers for listeners
				// i.e. resize -> onresize
				proto.handleEvent = utils.handleEvent;

				/**
				 * Bind layout to window resizing
				 */
				proto.bindResize = function () {
					window.addEventListener('resize', this);
					this.isResizeBound = true;
				};

				/**
				 * Unbind layout to window resizing
				 */
				proto.unbindResize = function () {
					window.removeEventListener('resize', this);
					this.isResizeBound = false;
				};

				proto.onresize = function () {
					this.resize();
				};

				utils.debounceMethod(Outlayer, 'onresize', 100);

				proto.resize = function () {
					// don't trigger if size did not change
					// or if resize was unbound. See #9
					if (!this.isResizeBound || !this.needsResizeLayout()) {
						return;
					}

					this.layout();
				};

				/**
				 * check if layout is needed post layout
				 * @returns Boolean
				 */
				proto.needsResizeLayout = function () {
					var size = getSize(this.element);
					// check that this.size and size are there
					// IE8 triggers resize on body size change, so they might not be
					var hasSizes = this.size && size;
					return hasSizes && size.innerWidth !== this.size.innerWidth;
				};

				// -------------------------- methods -------------------------- //

				/**
				 * add items to Outlayer instance
				 * @param {Array or NodeList or Element} elems
				 * @returns {Array} items - Outlayer.Items
				**/
				proto.addItems = function (elems) {
					var items = this._itemize(elems);
					// add items to collection
					if (items.length) {
						this.items = this.items.concat(items);
					}
					return items;
				};

				/**
				 * Layout newly-appended item elements
				 * @param {Array or NodeList or Element} elems
				 */
				proto.appended = function (elems) {
					var items = this.addItems(elems);
					if (!items.length) {
						return;
					}
					// layout and reveal just the new items
					this.layoutItems(items, true);
					this.reveal(items);
				};

				/**
				 * Layout prepended elements
				 * @param {Array or NodeList or Element} elems
				 */
				proto.prepended = function (elems) {
					var items = this._itemize(elems);
					if (!items.length) {
						return;
					}
					// add items to beginning of collection
					var previousItems = this.items.slice(0);
					this.items = items.concat(previousItems);
					// start new layout
					this._resetLayout();
					this._manageStamps();
					// layout new stuff without transition
					this.layoutItems(items, true);
					this.reveal(items);
					// layout previous items
					this.layoutItems(previousItems);
				};

				/**
				 * reveal a collection of items
				 * @param {Array of Outlayer.Items} items
				 */
				proto.reveal = function (items) {
					this._emitCompleteOnItems('reveal', items);
					if (!items || !items.length) {
						return;
					}
					var stagger = this.updateStagger();
					items.forEach(function (item, i) {
						item.stagger(i * stagger);
						item.reveal();
					});
				};

				/**
				 * hide a collection of items
				 * @param {Array of Outlayer.Items} items
				 */
				proto.hide = function (items) {
					this._emitCompleteOnItems('hide', items);
					if (!items || !items.length) {
						return;
					}
					var stagger = this.updateStagger();
					items.forEach(function (item, i) {
						item.stagger(i * stagger);
						item.hide();
					});
				};

				/**
				 * reveal item elements
				 * @param {Array}, {Element}, {NodeList} items
				 */
				proto.revealItemElements = function (elems) {
					var items = this.getItems(elems);
					this.reveal(items);
				};

				/**
				 * hide item elements
				 * @param {Array}, {Element}, {NodeList} items
				 */
				proto.hideItemElements = function (elems) {
					var items = this.getItems(elems);
					this.hide(items);
				};

				/**
				 * get Outlayer.Item, given an Element
				 * @param {Element} elem
				 * @param {Function} callback
				 * @returns {Outlayer.Item} item
				 */
				proto.getItem = function (elem) {
					// loop through items to get the one that matches
					for (var i = 0; i < this.items.length; i++) {
						var item = this.items[i];
						if (item.element == elem) {
							// return item
							return item;
						}
					}
				};

				/**
				 * get collection of Outlayer.Items, given Elements
				 * @param {Array} elems
				 * @returns {Array} items - Outlayer.Items
				 */
				proto.getItems = function (elems) {
					elems = utils.makeArray(elems);
					var items = [];
					elems.forEach(function (elem) {
						var item = this.getItem(elem);
						if (item) {
							items.push(item);
						}
					}, this);

					return items;
				};

				/**
				 * remove element(s) from instance and DOM
				 * @param {Array or NodeList or Element} elems
				 */
				proto.remove = function (elems) {
					var removeItems = this.getItems(elems);

					this._emitCompleteOnItems('remove', removeItems);

					// bail if no items to remove
					if (!removeItems || !removeItems.length) {
						return;
					}

					removeItems.forEach(function (item) {
						item.remove();
						// remove item from collection
						utils.removeFrom(this.items, item);
					}, this);
				};

				// ----- destroy ----- //

				// remove and disable Outlayer instance
				proto.destroy = function () {
					// clean up dynamic styles
					var style = this.element.style;
					style.height = '';
					style.position = '';
					style.width = '';
					// destroy items
					this.items.forEach(function (item) {
						item.destroy();
					});

					this.unbindResize();

					var id = this.element.outlayerGUID;
					delete instances[id]; // remove reference to instance by id
					delete this.element.outlayerGUID;
					// remove data for jQuery
					if (jQuery) {
						jQuery.removeData(this.element, this.constructor.namespace);
					}

				};

				// -------------------------- data -------------------------- //

				/**
				 * get Outlayer instance from element
				 * @param {Element} elem
				 * @returns {Outlayer}
				 */
				Outlayer.data = function (elem) {
					elem = utils.getQueryElement(elem);
					var id = elem && elem.outlayerGUID;
					return id && instances[id];
				};


				// -------------------------- create Outlayer class -------------------------- //

				/**
				 * create a layout class
				 * @param {String} namespace
				 */
				Outlayer.create = function (namespace, options) {
					// sub-class Outlayer
					var Layout = subclass(Outlayer);
					// apply new options and compatOptions
					Layout.defaults = utils.extend({}, Outlayer.defaults);
					utils.extend(Layout.defaults, options);
					Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);

					Layout.namespace = namespace;

					Layout.data = Outlayer.data;

					// sub-class Item
					Layout.Item = subclass(Item);

					// -------------------------- declarative -------------------------- //

					utils.htmlInit(Layout, namespace);

					// -------------------------- jQuery bridge -------------------------- //

					// make into jQuery plugin
					if (jQuery && jQuery.bridget) {
						jQuery.bridget(namespace, Layout);
					}

					return Layout;
				};

				function subclass(Parent) {
					function SubClass() {
						Parent.apply(this, arguments);
					}

					SubClass.prototype = Object.create(Parent.prototype);
					SubClass.prototype.constructor = SubClass;

					return SubClass;
				}

				// ----- helpers ----- //

				// how many milliseconds are in each unit
				var msUnits = {
					ms: 1,
					s: 1000
				};

				// munge time-like parameter into millisecond number
				// '0.4s' -> 40
				function getMilliseconds(time) {
					if (typeof time == 'number') {
						return time;
					}
					var matches = time.match(/(^\d*\.?\d*)(\w*)/);
					var num = matches && matches[1];
					var unit = matches && matches[2];
					if (!num.length) {
						return 0;
					}
					num = parseFloat(num);
					var mult = msUnits[unit] || 1;
					return num * mult;
				}

				// ----- fin ----- //

				// back in global
				Outlayer.Item = Item;

				return Outlayer;

			}));


			/***/
		}),

/***/ "./node_modules/owl.carousel/dist/owl.carousel.js":
/*!********************************************************!*\
  !*** ./node_modules/owl.carousel/dist/owl.carousel.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function (module, exports) {

			/**
			 * Owl Carousel v2.3.4
			 * Copyright 2013-2018 David Deutsch
			 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
			 */
			/**
			 * Owl carousel
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 * @todo Lazy Load Icon
			 * @todo prevent animationend bubling
			 * @todo itemsScaleUp
			 * @todo Test Zepto
			 * @todo stagePadding calculate wrong active classes
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates a carousel.
				 * @class The Owl Carousel.
				 * @public
				 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
				 * @param {Object} [options] - The options
				 */
				function Owl(element, options) {

					/**
					 * Current settings for the carousel.
					 * @public
					 */
					this.settings = null;

					/**
					 * Current options set by the caller including defaults.
					 * @public
					 */
					this.options = $.extend({}, Owl.Defaults, options);

					/**
					 * Plugin element.
					 * @public
					 */
					this.$element = $(element);

					/**
					 * Proxied event handlers.
					 * @protected
					 */
					this._handlers = {};

					/**
					 * References to the running plugins of this carousel.
					 * @protected
					 */
					this._plugins = {};

					/**
					 * Currently suppressed events to prevent them from being retriggered.
					 * @protected
					 */
					this._supress = {};

					/**
					 * Absolute current position.
					 * @protected
					 */
					this._current = null;

					/**
					 * Animation speed in milliseconds.
					 * @protected
					 */
					this._speed = null;

					/**
					 * Coordinates of all items in pixel.
					 * @todo The name of this member is missleading.
					 * @protected
					 */
					this._coordinates = [];

					/**
					 * Current breakpoint.
					 * @todo Real media queries would be nice.
					 * @protected
					 */
					this._breakpoint = null;

					/**
					 * Current width of the plugin element.
					 */
					this._width = null;

					/**
					 * All real items.
					 * @protected
					 */
					this._items = [];

					/**
					 * All cloned items.
					 * @protected
					 */
					this._clones = [];

					/**
					 * Merge values of all items.
					 * @todo Maybe this could be part of a plugin.
					 * @protected
					 */
					this._mergers = [];

					/**
					 * Widths of all items.
					 */
					this._widths = [];

					/**
					 * Invalidated parts within the update process.
					 * @protected
					 */
					this._invalidated = {};

					/**
					 * Ordered list of workers for the update process.
					 * @protected
					 */
					this._pipe = [];

					/**
					 * Current state information for the drag operation.
					 * @todo #261
					 * @protected
					 */
					this._drag = {
						time: null,
						target: null,
						pointer: null,
						stage: {
							start: null,
							current: null
						},
						direction: null
					};

					/**
					 * Current state information and their tags.
					 * @type {Object}
					 * @protected
					 */
					this._states = {
						current: {},
						tags: {
							'initializing': ['busy'],
							'animating': ['busy'],
							'dragging': ['interacting']
						}
					};

					$.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {
						this._handlers[handler] = $.proxy(this[handler], this);
					}, this));

					$.each(Owl.Plugins, $.proxy(function (key, plugin) {
						this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
							= new plugin(this);
					}, this));

					$.each(Owl.Workers, $.proxy(function (priority, worker) {
						this._pipe.push({
							'filter': worker.filter,
							'run': $.proxy(worker.run, this)
						});
					}, this));

					this.setup();
					this.initialize();
				}

				/**
				 * Default options for the carousel.
				 * @public
				 */
				Owl.Defaults = {
					items: 3,
					loop: false,
					center: false,
					rewind: false,
					checkVisibility: true,

					mouseDrag: true,
					touchDrag: true,
					pullDrag: true,
					freeDrag: false,

					margin: 0,
					stagePadding: 0,

					merge: false,
					mergeFit: true,
					autoWidth: false,

					startPosition: 0,
					rtl: false,

					smartSpeed: 250,
					fluidSpeed: false,
					dragEndSpeed: false,

					responsive: {},
					responsiveRefreshRate: 200,
					responsiveBaseElement: window,

					fallbackEasing: 'swing',
					slideTransition: '',

					info: false,

					nestedItemSelector: false,
					itemElement: 'div',
					stageElement: 'div',

					refreshClass: 'owl-refresh',
					loadedClass: 'owl-loaded',
					loadingClass: 'owl-loading',
					rtlClass: 'owl-rtl',
					responsiveClass: 'owl-responsive',
					dragClass: 'owl-drag',
					itemClass: 'owl-item',
					stageClass: 'owl-stage',
					stageOuterClass: 'owl-stage-outer',
					grabClass: 'owl-grab'
				};

				/**
				 * Enumeration for width.
				 * @public
				 * @readonly
				 * @enum {String}
				 */
				Owl.Width = {
					Default: 'default',
					Inner: 'inner',
					Outer: 'outer'
				};

				/**
				 * Enumeration for types.
				 * @public
				 * @readonly
				 * @enum {String}
				 */
				Owl.Type = {
					Event: 'event',
					State: 'state'
				};

				/**
				 * Contains all registered plugins.
				 * @public
				 */
				Owl.Plugins = {};

				/**
				 * List of workers involved in the update process.
				 */
				Owl.Workers = [{
					filter: ['width', 'settings'],
					run: function () {
						this._width = this.$element.width();
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function (cache) {
						cache.current = this._items && this._items[this.relative(this._current)];
					}
				}, {
					filter: ['items', 'settings'],
					run: function () {
						this.$stage.children('.cloned').remove();
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function (cache) {
						var margin = this.settings.margin || '',
							grid = !this.settings.autoWidth,
							rtl = this.settings.rtl,
							css = {
								'width': 'auto',
								'margin-left': rtl ? margin : '',
								'margin-right': rtl ? '' : margin
							};

						!grid && this.$stage.children().css(css);

						cache.css = css;
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function (cache) {
						var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
							merge = null,
							iterator = this._items.length,
							grid = !this.settings.autoWidth,
							widths = [];

						cache.items = {
							merge: false,
							width: width
						};

						while (iterator--) {
							merge = this._mergers[iterator];
							merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

							cache.items.merge = merge > 1 || cache.items.merge;

							widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
						}

						this._widths = widths;
					}
				}, {
					filter: ['items', 'settings'],
					run: function () {
						var clones = [],
							items = this._items,
							settings = this.settings,
							// TODO: Should be computed from number of min width items in stage
							view = Math.max(settings.items * 2, 4),
							size = Math.ceil(items.length / 2) * 2,
							repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
							append = '',
							prepend = '';

						repeat /= 2;

						while (repeat > 0) {
							// Switch to only using appended clones
							clones.push(this.normalize(clones.length / 2, true));
							append = append + items[clones[clones.length - 1]][0].outerHTML;
							clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
							prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
							repeat -= 1;
						}

						this._clones = clones;

						$(append).addClass('cloned').appendTo(this.$stage);
						$(prepend).addClass('cloned').prependTo(this.$stage);
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function () {
						var rtl = this.settings.rtl ? 1 : -1,
							size = this._clones.length + this._items.length,
							iterator = -1,
							previous = 0,
							current = 0,
							coordinates = [];

						while (++iterator < size) {
							previous = coordinates[iterator - 1] || 0;
							current = this._widths[this.relative(iterator)] + this.settings.margin;
							coordinates.push(previous + current * rtl);
						}

						this._coordinates = coordinates;
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function () {
						var padding = this.settings.stagePadding,
							coordinates = this._coordinates,
							css = {
								'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
								'padding-left': padding || '',
								'padding-right': padding || ''
							};

						this.$stage.css(css);
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function (cache) {
						var iterator = this._coordinates.length,
							grid = !this.settings.autoWidth,
							items = this.$stage.children();

						if (grid && cache.items.merge) {
							while (iterator--) {
								cache.css.width = this._widths[this.relative(iterator)];
								items.eq(iterator).css(cache.css);
							}
						} else if (grid) {
							cache.css.width = cache.items.width;
							items.css(cache.css);
						}
					}
				}, {
					filter: ['items'],
					run: function () {
						this._coordinates.length < 1 && this.$stage.removeAttr('style');
					}
				}, {
					filter: ['width', 'items', 'settings'],
					run: function (cache) {
						cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
						cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
						this.reset(cache.current);
					}
				}, {
					filter: ['position'],
					run: function () {
						this.animate(this.coordinates(this._current));
					}
				}, {
					filter: ['width', 'position', 'items', 'settings'],
					run: function () {
						var rtl = this.settings.rtl ? 1 : -1,
							padding = this.settings.stagePadding * 2,
							begin = this.coordinates(this.current()) + padding,
							end = begin + this.width() * rtl,
							inner, outer, matches = [], i, n;

						for (i = 0, n = this._coordinates.length; i < n; i++) {
							inner = this._coordinates[i - 1] || 0;
							outer = Math.abs(this._coordinates[i]) + padding * rtl;

							if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
								|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
								matches.push(i);
							}
						}

						this.$stage.children('.active').removeClass('active');
						this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

						this.$stage.children('.center').removeClass('center');
						if (this.settings.center) {
							this.$stage.children().eq(this.current()).addClass('center');
						}
					}
				}];

				/**
				 * Create the stage DOM element
				 */
				Owl.prototype.initializeStage = function () {
					this.$stage = this.$element.find('.' + this.settings.stageClass);

					// if the stage is already in the DOM, grab it and skip stage initialization
					if (this.$stage.length) {
						return;
					}

					this.$element.addClass(this.options.loadingClass);

					// create stage
					this.$stage = $('<' + this.settings.stageElement + '>', {
						"class": this.settings.stageClass
					}).wrap($('<div/>', {
						"class": this.settings.stageOuterClass
					}));

					// append stage
					this.$element.append(this.$stage.parent());
				};

				/**
				 * Create item DOM elements
				 */
				Owl.prototype.initializeItems = function () {
					var $items = this.$element.find('.owl-item');

					// if the items are already in the DOM, grab them and skip item initialization
					if ($items.length) {
						this._items = $items.get().map(function (item) {
							return $(item);
						});

						this._mergers = this._items.map(function () {
							return 1;
						});

						this.refresh();

						return;
					}

					// append content
					this.replace(this.$element.children().not(this.$stage.parent()));

					// check visibility
					if (this.isVisible()) {
						// update view
						this.refresh();
					} else {
						// invalidate width
						this.invalidate('width');
					}

					this.$element
						.removeClass(this.options.loadingClass)
						.addClass(this.options.loadedClass);
				};

				/**
				 * Initializes the carousel.
				 * @protected
				 */
				Owl.prototype.initialize = function () {
					this.enter('initializing');
					this.trigger('initialize');

					this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

					if (this.settings.autoWidth && !this.is('pre-loading')) {
						var imgs, nestedSelector, width;
						imgs = this.$element.find('img');
						nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
						width = this.$element.children(nestedSelector).width();

						if (imgs.length && width <= 0) {
							this.preloadAutoWidthImages(imgs);
						}
					}

					this.initializeStage();
					this.initializeItems();

					// register event handlers
					this.registerEventHandlers();

					this.leave('initializing');
					this.trigger('initialized');
				};

				/**
				 * @returns {Boolean} visibility of $element
				 *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
				 *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
				 */
				Owl.prototype.isVisible = function () {
					return this.settings.checkVisibility
						? this.$element.is(':visible')
						: true;
				};

				/**
				 * Setups the current settings.
				 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
				 * @todo Support for media queries by using `matchMedia` would be nice.
				 * @public
				 */
				Owl.prototype.setup = function () {
					var viewport = this.viewport(),
						overwrites = this.options.responsive,
						match = -1,
						settings = null;

					if (!overwrites) {
						settings = $.extend({}, this.options);
					} else {
						$.each(overwrites, function (breakpoint) {
							if (breakpoint <= viewport && breakpoint > match) {
								match = Number(breakpoint);
							}
						});

						settings = $.extend({}, this.options, overwrites[match]);
						if (typeof settings.stagePadding === 'function') {
							settings.stagePadding = settings.stagePadding();
						}
						delete settings.responsive;

						// responsive class
						if (settings.responsiveClass) {
							this.$element.attr('class',
								this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
							);
						}
					}

					this.trigger('change', { property: { name: 'settings', value: settings } });
					this._breakpoint = match;
					this.settings = settings;
					this.invalidate('settings');
					this.trigger('changed', { property: { name: 'settings', value: this.settings } });
				};

				/**
				 * Updates option logic if necessery.
				 * @protected
				 */
				Owl.prototype.optionsLogic = function () {
					if (this.settings.autoWidth) {
						this.settings.stagePadding = false;
						this.settings.merge = false;
					}
				};

				/**
				 * Prepares an item before add.
				 * @todo Rename event parameter `content` to `item`.
				 * @protected
				 * @returns {jQuery|HTMLElement} - The item container.
				 */
				Owl.prototype.prepare = function (item) {
					var event = this.trigger('prepare', { content: item });

					if (!event.data) {
						event.data = $('<' + this.settings.itemElement + '/>')
							.addClass(this.options.itemClass).append(item)
					}

					this.trigger('prepared', { content: event.data });

					return event.data;
				};

				/**
				 * Updates the view.
				 * @public
				 */
				Owl.prototype.update = function () {
					var i = 0,
						n = this._pipe.length,
						filter = $.proxy(function (p) { return this[p] }, this._invalidated),
						cache = {};

					while (i < n) {
						if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
							this._pipe[i].run(cache);
						}
						i++;
					}

					this._invalidated = {};

					!this.is('valid') && this.enter('valid');
				};

				/**
				 * Gets the width of the view.
				 * @public
				 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
				 * @returns {Number} - The width of the view in pixel.
				 */
				Owl.prototype.width = function (dimension) {
					dimension = dimension || Owl.Width.Default;
					switch (dimension) {
						case Owl.Width.Inner:
						case Owl.Width.Outer:
							return this._width;
						default:
							return this._width - this.settings.stagePadding * 2 + this.settings.margin;
					}
				};

				/**
				 * Refreshes the carousel primarily for adaptive purposes.
				 * @public
				 */
				Owl.prototype.refresh = function () {
					this.enter('refreshing');
					this.trigger('refresh');

					this.setup();

					this.optionsLogic();

					this.$element.addClass(this.options.refreshClass);

					this.update();

					this.$element.removeClass(this.options.refreshClass);

					this.leave('refreshing');
					this.trigger('refreshed');
				};

				/**
				 * Checks window `resize` event.
				 * @protected
				 */
				Owl.prototype.onThrottledResize = function () {
					window.clearTimeout(this.resizeTimer);
					this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
				};

				/**
				 * Checks window `resize` event.
				 * @protected
				 */
				Owl.prototype.onResize = function () {
					if (!this._items.length) {
						return false;
					}

					if (this._width === this.$element.width()) {
						return false;
					}

					if (!this.isVisible()) {
						return false;
					}

					this.enter('resizing');

					if (this.trigger('resize').isDefaultPrevented()) {
						this.leave('resizing');
						return false;
					}

					this.invalidate('width');

					this.refresh();

					this.leave('resizing');
					this.trigger('resized');
				};

				/**
				 * Registers event handlers.
				 * @todo Check `msPointerEnabled`
				 * @todo #261
				 * @protected
				 */
				Owl.prototype.registerEventHandlers = function () {
					if ($.support.transition) {
						this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
					}

					if (this.settings.responsive !== false) {
						this.on(window, 'resize', this._handlers.onThrottledResize);
					}

					if (this.settings.mouseDrag) {
						this.$element.addClass(this.options.dragClass);
						this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
						this.$stage.on('dragstart.owl.core selectstart.owl.core', function () { return false });
					}

					if (this.settings.touchDrag) {
						this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
						this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
					}
				};

				/**
				 * Handles `touchstart` and `mousedown` events.
				 * @todo Horizontal swipe threshold as option
				 * @todo #261
				 * @protected
				 * @param {Event} event - The event arguments.
				 */
				Owl.prototype.onDragStart = function (event) {
					var stage = null;

					if (event.which === 3) {
						return;
					}

					if ($.support.transform) {
						stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
						stage = {
							x: stage[stage.length === 16 ? 12 : 4],
							y: stage[stage.length === 16 ? 13 : 5]
						};
					} else {
						stage = this.$stage.position();
						stage = {
							x: this.settings.rtl ?
								stage.left + this.$stage.width() - this.width() + this.settings.margin :
								stage.left,
							y: stage.top
						};
					}

					if (this.is('animating')) {
						$.support.transform ? this.animate(stage.x) : this.$stage.stop()
						this.invalidate('position');
					}

					this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

					this.speed(0);

					this._drag.time = new Date().getTime();
					this._drag.target = $(event.target);
					this._drag.stage.start = stage;
					this._drag.stage.current = stage;
					this._drag.pointer = this.pointer(event);

					$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

					$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {
						var delta = this.difference(this._drag.pointer, this.pointer(event));

						$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

						if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
							return;
						}

						event.preventDefault();

						this.enter('dragging');
						this.trigger('drag');
					}, this));
				};

				/**
				 * Handles the `touchmove` and `mousemove` events.
				 * @todo #261
				 * @protected
				 * @param {Event} event - The event arguments.
				 */
				Owl.prototype.onDragMove = function (event) {
					var minimum = null,
						maximum = null,
						pull = null,
						delta = this.difference(this._drag.pointer, this.pointer(event)),
						stage = this.difference(this._drag.stage.start, delta);

					if (!this.is('dragging')) {
						return;
					}

					event.preventDefault();

					if (this.settings.loop) {
						minimum = this.coordinates(this.minimum());
						maximum = this.coordinates(this.maximum() + 1) - minimum;
						stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
					} else {
						minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
						maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
						pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
						stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
					}

					this._drag.stage.current = stage;

					this.animate(stage.x);
				};

				/**
				 * Handles the `touchend` and `mouseup` events.
				 * @todo #261
				 * @todo Threshold for click event
				 * @protected
				 * @param {Event} event - The event arguments.
				 */
				Owl.prototype.onDragEnd = function (event) {
					var delta = this.difference(this._drag.pointer, this.pointer(event)),
						stage = this._drag.stage.current,
						direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

					$(document).off('.owl.core');

					this.$element.removeClass(this.options.grabClass);

					if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
						this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
						this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
						this.invalidate('position');
						this.update();

						this._drag.direction = direction;

						if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
							this._drag.target.one('click.owl.core', function () { return false; });
						}
					}

					if (!this.is('dragging')) {
						return;
					}

					this.leave('dragging');
					this.trigger('dragged');
				};

				/**
				 * Gets absolute position of the closest item for a coordinate.
				 * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
				 * @protected
				 * @param {Number} coordinate - The coordinate in pixel.
				 * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
				 * @return {Number} - The absolute position of the closest item.
				 */
				Owl.prototype.closest = function (coordinate, direction) {
					var position = -1,
						pull = 30,
						width = this.width(),
						coordinates = this.coordinates();

					if (!this.settings.freeDrag) {
						// check closest item
						$.each(coordinates, $.proxy(function (index, value) {
							// on a left pull, check on current index
							if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
								position = index;
								// on a right pull, check on previous index
								// to do so, subtract width from value and set position = index + 1
							} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
								position = index + 1;
							} else if (this.op(coordinate, '<', value)
								&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
								position = direction === 'left' ? index + 1 : index;
							}
							return position === -1;
						}, this));
					}

					if (!this.settings.loop) {
						// non loop boundries
						if (this.op(coordinate, '>', coordinates[this.minimum()])) {
							position = coordinate = this.minimum();
						} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
							position = coordinate = this.maximum();
						}
					}

					return position;
				};

				/**
				 * Animates the stage.
				 * @todo #270
				 * @public
				 * @param {Number} coordinate - The coordinate in pixels.
				 */
				Owl.prototype.animate = function (coordinate) {
					var animate = this.speed() > 0;

					this.is('animating') && this.onTransitionEnd();

					if (animate) {
						this.enter('animating');
						this.trigger('translate');
					}

					if ($.support.transform3d && $.support.transition) {
						this.$stage.css({
							transform: 'translate3d(' + coordinate + 'px,0px,0px)',
							transition: (this.speed() / 1000) + 's' + (
								this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''
							)
						});
					} else if (animate) {
						this.$stage.animate({
							left: coordinate + 'px'
						}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
					} else {
						this.$stage.css({
							left: coordinate + 'px'
						});
					}
				};

				/**
				 * Checks whether the carousel is in a specific state or not.
				 * @param {String} state - The state to check.
				 * @returns {Boolean} - The flag which indicates if the carousel is busy.
				 */
				Owl.prototype.is = function (state) {
					return this._states.current[state] && this._states.current[state] > 0;
				};

				/**
				 * Sets the absolute position of the current item.
				 * @public
				 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
				 * @returns {Number} - The absolute position of the current item.
				 */
				Owl.prototype.current = function (position) {
					if (position === undefined) {
						return this._current;
					}

					if (this._items.length === 0) {
						return undefined;
					}

					position = this.normalize(position);

					if (this._current !== position) {
						var event = this.trigger('change', { property: { name: 'position', value: position } });

						if (event.data !== undefined) {
							position = this.normalize(event.data);
						}

						this._current = position;

						this.invalidate('position');

						this.trigger('changed', { property: { name: 'position', value: this._current } });
					}

					return this._current;
				};

				/**
				 * Invalidates the given part of the update routine.
				 * @param {String} [part] - The part to invalidate.
				 * @returns {Array.<String>} - The invalidated parts.
				 */
				Owl.prototype.invalidate = function (part) {
					if ($.type(part) === 'string') {
						this._invalidated[part] = true;
						this.is('valid') && this.leave('valid');
					}
					return $.map(this._invalidated, function (v, i) { return i });
				};

				/**
				 * Resets the absolute position of the current item.
				 * @public
				 * @param {Number} position - The absolute position of the new item.
				 */
				Owl.prototype.reset = function (position) {
					position = this.normalize(position);

					if (position === undefined) {
						return;
					}

					this._speed = 0;
					this._current = position;

					this.suppress(['translate', 'translated']);

					this.animate(this.coordinates(position));

					this.release(['translate', 'translated']);
				};

				/**
				 * Normalizes an absolute or a relative position of an item.
				 * @public
				 * @param {Number} position - The absolute or relative position to normalize.
				 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
				 * @returns {Number} - The normalized position.
				 */
				Owl.prototype.normalize = function (position, relative) {
					var n = this._items.length,
						m = relative ? 0 : this._clones.length;

					if (!this.isNumeric(position) || n < 1) {
						position = undefined;
					} else if (position < 0 || position >= n + m) {
						position = ((position - m / 2) % n + n) % n + m / 2;
					}

					return position;
				};

				/**
				 * Converts an absolute position of an item into a relative one.
				 * @public
				 * @param {Number} position - The absolute position to convert.
				 * @returns {Number} - The converted position.
				 */
				Owl.prototype.relative = function (position) {
					position -= this._clones.length / 2;
					return this.normalize(position, true);
				};

				/**
				 * Gets the maximum position for the current item.
				 * @public
				 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
				 * @returns {Number}
				 */
				Owl.prototype.maximum = function (relative) {
					var settings = this.settings,
						maximum = this._coordinates.length,
						iterator,
						reciprocalItemsWidth,
						elementWidth;

					if (settings.loop) {
						maximum = this._clones.length / 2 + this._items.length - 1;
					} else if (settings.autoWidth || settings.merge) {
						iterator = this._items.length;
						if (iterator) {
							reciprocalItemsWidth = this._items[--iterator].width();
							elementWidth = this.$element.width();
							while (iterator--) {
								reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
								if (reciprocalItemsWidth > elementWidth) {
									break;
								}
							}
						}
						maximum = iterator + 1;
					} else if (settings.center) {
						maximum = this._items.length - 1;
					} else {
						maximum = this._items.length - settings.items;
					}

					if (relative) {
						maximum -= this._clones.length / 2;
					}

					return Math.max(maximum, 0);
				};

				/**
				 * Gets the minimum position for the current item.
				 * @public
				 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
				 * @returns {Number}
				 */
				Owl.prototype.minimum = function (relative) {
					return relative ? 0 : this._clones.length / 2;
				};

				/**
				 * Gets an item at the specified relative position.
				 * @public
				 * @param {Number} [position] - The relative position of the item.
				 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
				 */
				Owl.prototype.items = function (position) {
					if (position === undefined) {
						return this._items.slice();
					}

					position = this.normalize(position, true);
					return this._items[position];
				};

				/**
				 * Gets an item at the specified relative position.
				 * @public
				 * @param {Number} [position] - The relative position of the item.
				 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
				 */
				Owl.prototype.mergers = function (position) {
					if (position === undefined) {
						return this._mergers.slice();
					}

					position = this.normalize(position, true);
					return this._mergers[position];
				};

				/**
				 * Gets the absolute positions of clones for an item.
				 * @public
				 * @param {Number} [position] - The relative position of the item.
				 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
				 */
				Owl.prototype.clones = function (position) {
					var odd = this._clones.length / 2,
						even = odd + this._items.length,
						map = function (index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

					if (position === undefined) {
						return $.map(this._clones, function (v, i) { return map(i) });
					}

					return $.map(this._clones, function (v, i) { return v === position ? map(i) : null });
				};

				/**
				 * Sets the current animation speed.
				 * @public
				 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
				 * @returns {Number} - The current animation speed in milliseconds.
				 */
				Owl.prototype.speed = function (speed) {
					if (speed !== undefined) {
						this._speed = speed;
					}

					return this._speed;
				};

				/**
				 * Gets the coordinate of an item.
				 * @todo The name of this method is missleanding.
				 * @public
				 * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
				 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
				 */
				Owl.prototype.coordinates = function (position) {
					var multiplier = 1,
						newPosition = position - 1,
						coordinate;

					if (position === undefined) {
						return $.map(this._coordinates, $.proxy(function (coordinate, index) {
							return this.coordinates(index);
						}, this));
					}

					if (this.settings.center) {
						if (this.settings.rtl) {
							multiplier = -1;
							newPosition = position + 1;
						}

						coordinate = this._coordinates[position];
						coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
					} else {
						coordinate = this._coordinates[newPosition] || 0;
					}

					coordinate = Math.ceil(coordinate);

					return coordinate;
				};

				/**
				 * Calculates the speed for a translation.
				 * @protected
				 * @param {Number} from - The absolute position of the start item.
				 * @param {Number} to - The absolute position of the target item.
				 * @param {Number} [factor=undefined] - The time factor in milliseconds.
				 * @returns {Number} - The time in milliseconds for the translation.
				 */
				Owl.prototype.duration = function (from, to, factor) {
					if (factor === 0) {
						return 0;
					}

					return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
				};

				/**
				 * Slides to the specified item.
				 * @public
				 * @param {Number} position - The position of the item.
				 * @param {Number} [speed] - The time in milliseconds for the transition.
				 */
				Owl.prototype.to = function (position, speed) {
					var current = this.current(),
						revert = null,
						distance = position - this.relative(current),
						direction = (distance > 0) - (distance < 0),
						items = this._items.length,
						minimum = this.minimum(),
						maximum = this.maximum();

					if (this.settings.loop) {
						if (!this.settings.rewind && Math.abs(distance) > items / 2) {
							distance += direction * -1 * items;
						}

						position = current + distance;
						revert = ((position - minimum) % items + items) % items + minimum;

						if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
							current = revert - distance;
							position = revert;
							this.reset(current);
						}
					} else if (this.settings.rewind) {
						maximum += 1;
						position = (position % maximum + maximum) % maximum;
					} else {
						position = Math.max(minimum, Math.min(maximum, position));
					}

					this.speed(this.duration(current, position, speed));
					this.current(position);

					if (this.isVisible()) {
						this.update();
					}
				};

				/**
				 * Slides to the next item.
				 * @public
				 * @param {Number} [speed] - The time in milliseconds for the transition.
				 */
				Owl.prototype.next = function (speed) {
					speed = speed || false;
					this.to(this.relative(this.current()) + 1, speed);
				};

				/**
				 * Slides to the previous item.
				 * @public
				 * @param {Number} [speed] - The time in milliseconds for the transition.
				 */
				Owl.prototype.prev = function (speed) {
					speed = speed || false;
					this.to(this.relative(this.current()) - 1, speed);
				};

				/**
				 * Handles the end of an animation.
				 * @protected
				 * @param {Event} event - The event arguments.
				 */
				Owl.prototype.onTransitionEnd = function (event) {

					// if css2 animation then event object is undefined
					if (event !== undefined) {
						event.stopPropagation();

						// Catch only owl-stage transitionEnd event
						if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
							return false;
						}
					}

					this.leave('animating');
					this.trigger('translated');
				};

				/**
				 * Gets viewport width.
				 * @protected
				 * @return {Number} - The width in pixel.
				 */
				Owl.prototype.viewport = function () {
					var width;
					if (this.options.responsiveBaseElement !== window) {
						width = $(this.options.responsiveBaseElement).width();
					} else if (window.innerWidth) {
						width = window.innerWidth;
					} else if (document.documentElement && document.documentElement.clientWidth) {
						width = document.documentElement.clientWidth;
					} else {
						console.warn('Can not detect viewport width.');
					}
					return width;
				};

				/**
				 * Replaces the current content.
				 * @public
				 * @param {HTMLElement|jQuery|String} content - The new content.
				 */
				Owl.prototype.replace = function (content) {
					this.$stage.empty();
					this._items = [];

					if (content) {
						content = (content instanceof jQuery) ? content : $(content);
					}

					if (this.settings.nestedItemSelector) {
						content = content.find('.' + this.settings.nestedItemSelector);
					}

					content.filter(function () {
						return this.nodeType === 1;
					}).each($.proxy(function (index, item) {
						item = this.prepare(item);
						this.$stage.append(item);
						this._items.push(item);
						this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
					}, this));

					this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

					this.invalidate('items');
				};

				/**
				 * Adds an item.
				 * @todo Use `item` instead of `content` for the event arguments.
				 * @public
				 * @param {HTMLElement|jQuery|String} content - The item content to add.
				 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
				 */
				Owl.prototype.add = function (content, position) {
					var current = this.relative(this._current);

					position = position === undefined ? this._items.length : this.normalize(position, true);
					content = content instanceof jQuery ? content : $(content);

					this.trigger('add', { content: content, position: position });

					content = this.prepare(content);

					if (this._items.length === 0 || position === this._items.length) {
						this._items.length === 0 && this.$stage.append(content);
						this._items.length !== 0 && this._items[position - 1].after(content);
						this._items.push(content);
						this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
					} else {
						this._items[position].before(content);
						this._items.splice(position, 0, content);
						this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
					}

					this._items[current] && this.reset(this._items[current].index());

					this.invalidate('items');

					this.trigger('added', { content: content, position: position });
				};

				/**
				 * Removes an item by its position.
				 * @todo Use `item` instead of `content` for the event arguments.
				 * @public
				 * @param {Number} position - The relative position of the item to remove.
				 */
				Owl.prototype.remove = function (position) {
					position = this.normalize(position, true);

					if (position === undefined) {
						return;
					}

					this.trigger('remove', { content: this._items[position], position: position });

					this._items[position].remove();
					this._items.splice(position, 1);
					this._mergers.splice(position, 1);

					this.invalidate('items');

					this.trigger('removed', { content: null, position: position });
				};

				/**
				 * Preloads images with auto width.
				 * @todo Replace by a more generic approach
				 * @protected
				 */
				Owl.prototype.preloadAutoWidthImages = function (images) {
					images.each($.proxy(function (i, element) {
						this.enter('pre-loading');
						element = $(element);
						$(new Image()).one('load', $.proxy(function (e) {
							element.attr('src', e.target.src);
							element.css('opacity', 1);
							this.leave('pre-loading');
							!this.is('pre-loading') && !this.is('initializing') && this.refresh();
						}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
					}, this));
				};

				/**
				 * Destroys the carousel.
				 * @public
				 */
				Owl.prototype.destroy = function () {

					this.$element.off('.owl.core');
					this.$stage.off('.owl.core');
					$(document).off('.owl.core');

					if (this.settings.responsive !== false) {
						window.clearTimeout(this.resizeTimer);
						this.off(window, 'resize', this._handlers.onThrottledResize);
					}

					for (var i in this._plugins) {
						this._plugins[i].destroy();
					}

					this.$stage.children('.cloned').remove();

					this.$stage.unwrap();
					this.$stage.children().contents().unwrap();
					this.$stage.children().unwrap();
					this.$stage.remove();
					this.$element
						.removeClass(this.options.refreshClass)
						.removeClass(this.options.loadingClass)
						.removeClass(this.options.loadedClass)
						.removeClass(this.options.rtlClass)
						.removeClass(this.options.dragClass)
						.removeClass(this.options.grabClass)
						.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
						.removeData('owl.carousel');
				};

				/**
				 * Operators to calculate right-to-left and left-to-right.
				 * @protected
				 * @param {Number} [a] - The left side operand.
				 * @param {String} [o] - The operator.
				 * @param {Number} [b] - The right side operand.
				 */
				Owl.prototype.op = function (a, o, b) {
					var rtl = this.settings.rtl;
					switch (o) {
						case '<':
							return rtl ? a > b : a < b;
						case '>':
							return rtl ? a < b : a > b;
						case '>=':
							return rtl ? a <= b : a >= b;
						case '<=':
							return rtl ? a >= b : a <= b;
						default:
							break;
					}
				};

				/**
				 * Attaches to an internal event.
				 * @protected
				 * @param {HTMLElement} element - The event source.
				 * @param {String} event - The event name.
				 * @param {Function} listener - The event handler to attach.
				 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
				 */
				Owl.prototype.on = function (element, event, listener, capture) {
					if (element.addEventListener) {
						element.addEventListener(event, listener, capture);
					} else if (element.attachEvent) {
						element.attachEvent('on' + event, listener);
					}
				};

				/**
				 * Detaches from an internal event.
				 * @protected
				 * @param {HTMLElement} element - The event source.
				 * @param {String} event - The event name.
				 * @param {Function} listener - The attached event handler to detach.
				 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
				 */
				Owl.prototype.off = function (element, event, listener, capture) {
					if (element.removeEventListener) {
						element.removeEventListener(event, listener, capture);
					} else if (element.detachEvent) {
						element.detachEvent('on' + event, listener);
					}
				};

				/**
				 * Triggers a public event.
				 * @todo Remove `status`, `relatedTarget` should be used instead.
				 * @protected
				 * @param {String} name - The event name.
				 * @param {*} [data=null] - The event data.
				 * @param {String} [namespace=carousel] - The event namespace.
				 * @param {String} [state] - The state which is associated with the event.
				 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
				 * @returns {Event} - The event arguments.
				 */
				Owl.prototype.trigger = function (name, data, namespace, state, enter) {
					var status = {
						item: { count: this._items.length, index: this.current() }
					}, handler = $.camelCase(
						$.grep(['on', name, namespace], function (v) { return v })
							.join('-').toLowerCase()
					), event = $.Event(
						[name, 'owl', namespace || 'carousel'].join('.').toLowerCase(),
						$.extend({ relatedTarget: this }, status, data)
					);

					if (!this._supress[name]) {
						$.each(this._plugins, function (name, plugin) {
							if (plugin.onTrigger) {
								plugin.onTrigger(event);
							}
						});

						this.register({ type: Owl.Type.Event, name: name });
						this.$element.trigger(event);

						if (this.settings && typeof this.settings[handler] === 'function') {
							this.settings[handler].call(this, event);
						}
					}

					return event;
				};

				/**
				 * Enters a state.
				 * @param name - The state name.
				 */
				Owl.prototype.enter = function (name) {
					$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
						if (this._states.current[name] === undefined) {
							this._states.current[name] = 0;
						}

						this._states.current[name]++;
					}, this));
				};

				/**
				 * Leaves a state.
				 * @param name - The state name.
				 */
				Owl.prototype.leave = function (name) {
					$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
						this._states.current[name]--;
					}, this));
				};

				/**
				 * Registers an event or state.
				 * @public
				 * @param {Object} object - The event or state to register.
				 */
				Owl.prototype.register = function (object) {
					if (object.type === Owl.Type.Event) {
						if (!$.event.special[object.name]) {
							$.event.special[object.name] = {};
						}

						if (!$.event.special[object.name].owl) {
							var _default = $.event.special[object.name]._default;
							$.event.special[object.name]._default = function (e) {
								if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
									return _default.apply(this, arguments);
								}
								return e.namespace && e.namespace.indexOf('owl') > -1;
							};
							$.event.special[object.name].owl = true;
						}
					} else if (object.type === Owl.Type.State) {
						if (!this._states.tags[object.name]) {
							this._states.tags[object.name] = object.tags;
						} else {
							this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
						}

						this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
							return $.inArray(tag, this._states.tags[object.name]) === i;
						}, this));
					}
				};

				/**
				 * Suppresses events.
				 * @protected
				 * @param {Array.<String>} events - The events to suppress.
				 */
				Owl.prototype.suppress = function (events) {
					$.each(events, $.proxy(function (index, event) {
						this._supress[event] = true;
					}, this));
				};

				/**
				 * Releases suppressed events.
				 * @protected
				 * @param {Array.<String>} events - The events to release.
				 */
				Owl.prototype.release = function (events) {
					$.each(events, $.proxy(function (index, event) {
						delete this._supress[event];
					}, this));
				};

				/**
				 * Gets unified pointer coordinates from event.
				 * @todo #261
				 * @protected
				 * @param {Event} - The `mousedown` or `touchstart` event.
				 * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
				 */
				Owl.prototype.pointer = function (event) {
					var result = { x: null, y: null };

					event = event.originalEvent || event || window.event;

					event = event.touches && event.touches.length ?
						event.touches[0] : event.changedTouches && event.changedTouches.length ?
							event.changedTouches[0] : event;

					if (event.pageX) {
						result.x = event.pageX;
						result.y = event.pageY;
					} else {
						result.x = event.clientX;
						result.y = event.clientY;
					}

					return result;
				};

				/**
				 * Determines if the input is a Number or something that can be coerced to a Number
				 * @protected
				 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
				 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
				 */
				Owl.prototype.isNumeric = function (number) {
					return !isNaN(parseFloat(number));
				};

				/**
				 * Gets the difference of two vectors.
				 * @todo #261
				 * @protected
				 * @param {Object} - The first vector.
				 * @param {Object} - The second vector.
				 * @returns {Object} - The difference.
				 */
				Owl.prototype.difference = function (first, second) {
					return {
						x: first.x - second.x,
						y: first.y - second.y
					};
				};

				/**
				 * The jQuery Plugin for the Owl Carousel
				 * @todo Navigation plugin `next` and `prev`
				 * @public
				 */
				$.fn.owlCarousel = function (option) {
					var args = Array.prototype.slice.call(arguments, 1);

					return this.each(function () {
						var $this = $(this),
							data = $this.data('owl.carousel');

						if (!data) {
							data = new Owl(this, typeof option == 'object' && option);
							$this.data('owl.carousel', data);

							$.each([
								'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
							], function (i, event) {
								data.register({ type: Owl.Type.Event, name: event });
								data.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {
									if (e.namespace && e.relatedTarget !== this) {
										this.suppress([event]);
										data[event].apply(this, [].slice.call(arguments, 1));
										this.release([event]);
									}
								}, data));
							});
						}

						if (typeof option == 'string' && option.charAt(0) !== '_') {
							data[option].apply(data, args);
						}
					});
				};

				/**
				 * The constructor for the jQuery Plugin
				 * @public
				 */
				$.fn.owlCarousel.Constructor = Owl;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * AutoRefresh Plugin
			 * @version 2.3.4
			 * @author Artus Kolanowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the auto refresh plugin.
				 * @class The Auto Refresh Plugin
				 * @param {Owl} carousel - The Owl Carousel
				 */
				var AutoRefresh = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * Refresh interval.
					 * @protected
					 * @type {number}
					 */
					this._interval = null;

					/**
					 * Whether the element is currently visible or not.
					 * @protected
					 * @type {Boolean}
					 */
					this._visible = null;

					/**
					 * All event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'initialized.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.autoRefresh) {
								this.watch();
							}
						}, this)
					};

					// set default options
					this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

					// register event handlers
					this._core.$element.on(this._handlers);
				};

				/**
				 * Default options.
				 * @public
				 */
				AutoRefresh.Defaults = {
					autoRefresh: true,
					autoRefreshInterval: 500
				};

				/**
				 * Watches the element.
				 */
				AutoRefresh.prototype.watch = function () {
					if (this._interval) {
						return;
					}

					this._visible = this._core.isVisible();
					this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
				};

				/**
				 * Refreshes the element.
				 */
				AutoRefresh.prototype.refresh = function () {
					if (this._core.isVisible() === this._visible) {
						return;
					}

					this._visible = !this._visible;

					this._core.$element.toggleClass('owl-hidden', !this._visible);

					this._visible && (this._core.invalidate('width') && this._core.refresh());
				};

				/**
				 * Destroys the plugin.
				 */
				AutoRefresh.prototype.destroy = function () {
					var handler, property;

					window.clearInterval(this._interval);

					for (handler in this._handlers) {
						this._core.$element.off(handler, this._handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Lazy Plugin
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the lazy plugin.
				 * @class The Lazy Plugin
				 * @param {Owl} carousel - The Owl Carousel
				 */
				var Lazy = function (carousel) {

					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * Already loaded items.
					 * @protected
					 * @type {Array.<jQuery>}
					 */
					this._loaded = [];

					/**
					 * Event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {
							if (!e.namespace) {
								return;
							}

							if (!this._core.settings || !this._core.settings.lazyLoad) {
								return;
							}

							if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
								var settings = this._core.settings,
									n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
									i = ((settings.center && n * -1) || 0),
									position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
									clones = this._core.clones().length,
									load = $.proxy(function (i, v) { this.load(v) }, this);
								//TODO: Need documentation for this new option
								if (settings.lazyLoadEager > 0) {
									n += settings.lazyLoadEager;
									// If the carousel is looping also preload images that are to the "left"
									if (settings.loop) {
										position -= settings.lazyLoadEager;
										n++;
									}
								}

								while (i++ < n) {
									this.load(clones / 2 + this._core.relative(position));
									clones && $.each(this._core.clones(this._core.relative(position)), load);
									position++;
								}
							}
						}, this)
					};

					// set the default options
					this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

					// register event handler
					this._core.$element.on(this._handlers);
				};

				/**
				 * Default options.
				 * @public
				 */
				Lazy.Defaults = {
					lazyLoad: false,
					lazyLoadEager: 0
				};

				/**
				 * Loads all resources of an item at the specified position.
				 * @param {Number} position - The absolute position of the item.
				 * @protected
				 */
				Lazy.prototype.load = function (position) {
					var $item = this._core.$stage.children().eq(position),
						$elements = $item && $item.find('.owl-lazy');

					if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
						return;
					}

					$elements.each($.proxy(function (index, element) {
						var $element = $(element), image,
							url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');

						this._core.trigger('load', { element: $element, url: url }, 'lazy');

						if ($element.is('img')) {
							$element.one('load.owl.lazy', $.proxy(function () {
								$element.css('opacity', 1);
								this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
							}, this)).attr('src', url);
						} else if ($element.is('source')) {
							$element.one('load.owl.lazy', $.proxy(function () {
								this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
							}, this)).attr('srcset', url);
						} else {
							image = new Image();
							image.onload = $.proxy(function () {
								$element.css({
									'background-image': 'url("' + url + '")',
									'opacity': '1'
								});
								this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
							}, this);
							image.src = url;
						}
					}, this));

					this._loaded.push($item.get(0));
				};

				/**
				 * Destroys the plugin.
				 * @public
				 */
				Lazy.prototype.destroy = function () {
					var handler, property;

					for (handler in this.handlers) {
						this._core.$element.off(handler, this.handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * AutoHeight Plugin
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the auto height plugin.
				 * @class The Auto Height Plugin
				 * @param {Owl} carousel - The Owl Carousel
				 */
				var AutoHeight = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					this._previousHeight = null;

					/**
					 * All event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.autoHeight) {
								this.update();
							}
						}, this),
						'changed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {
								this.update();
							}
						}, this),
						'loaded.owl.lazy': $.proxy(function (e) {
							if (e.namespace && this._core.settings.autoHeight
								&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
								this.update();
							}
						}, this)
					};

					// set default options
					this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

					// register event handlers
					this._core.$element.on(this._handlers);
					this._intervalId = null;
					var refThis = this;

					// These changes have been taken from a PR by gavrochelegnou proposed in #1575
					// and have been made compatible with the latest jQuery version
					$(window).on('load', function () {
						if (refThis._core.settings.autoHeight) {
							refThis.update();
						}
					});

					// Autoresize the height of the carousel when window is resized
					// When carousel has images, the height is dependent on the width
					// and should also change on resize
					$(window).resize(function () {
						if (refThis._core.settings.autoHeight) {
							if (refThis._intervalId != null) {
								clearTimeout(refThis._intervalId);
							}

							refThis._intervalId = setTimeout(function () {
								refThis.update();
							}, 250);
						}
					});

				};

				/**
				 * Default options.
				 * @public
				 */
				AutoHeight.Defaults = {
					autoHeight: false,
					autoHeightClass: 'owl-height'
				};

				/**
				 * Updates the view.
				 */
				AutoHeight.prototype.update = function () {
					var start = this._core._current,
						end = start + this._core.settings.items,
						lazyLoadEnabled = this._core.settings.lazyLoad,
						visible = this._core.$stage.children().toArray().slice(start, end),
						heights = [],
						maxheight = 0;

					$.each(visible, function (index, item) {
						heights.push($(item).height());
					});

					maxheight = Math.max.apply(null, heights);

					if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
						maxheight = this._previousHeight;
					}

					this._previousHeight = maxheight;

					this._core.$stage.parent()
						.height(maxheight)
						.addClass(this._core.settings.autoHeightClass);
				};

				AutoHeight.prototype.destroy = function () {
					var handler, property;

					for (handler in this._handlers) {
						this._core.$element.off(handler, this._handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] !== 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Video Plugin
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the video plugin.
				 * @class The Video Plugin
				 * @param {Owl} carousel - The Owl Carousel
				 */
				var Video = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * Cache all video URLs.
					 * @protected
					 * @type {Object}
					 */
					this._videos = {};

					/**
					 * Current playing item.
					 * @protected
					 * @type {jQuery}
					 */
					this._playing = null;

					/**
					 * All event handlers.
					 * @todo The cloned content removale is too late
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'initialized.owl.carousel': $.proxy(function (e) {
							if (e.namespace) {
								this._core.register({ type: 'state', name: 'playing', tags: ['interacting'] });
							}
						}, this),
						'resize.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
								e.preventDefault();
							}
						}, this),
						'refreshed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.is('resizing')) {
								this._core.$stage.find('.cloned .owl-video-frame').remove();
							}
						}, this),
						'changed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && e.property.name === 'position' && this._playing) {
								this.stop();
							}
						}, this),
						'prepared.owl.carousel': $.proxy(function (e) {
							if (!e.namespace) {
								return;
							}

							var $element = $(e.content).find('.owl-video');

							if ($element.length) {
								$element.css('display', 'none');
								this.fetch($element, $(e.content));
							}
						}, this)
					};

					// set default options
					this._core.options = $.extend({}, Video.Defaults, this._core.options);

					// register event handlers
					this._core.$element.on(this._handlers);

					this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {
						this.play(e);
					}, this));
				};

				/**
				 * Default options.
				 * @public
				 */
				Video.Defaults = {
					video: false,
					videoHeight: false,
					videoWidth: false
				};

				/**
				 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
				 * @protected
				 * @param {jQuery} target - The target containing the video data.
				 * @param {jQuery} item - The item containing the video.
				 */
				Video.prototype.fetch = function (target, item) {
					var type = (function () {
						if (target.attr('data-vimeo-id')) {
							return 'vimeo';
						} else if (target.attr('data-vzaar-id')) {
							return 'vzaar'
						} else {
							return 'youtube';
						}
					})(),
						id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
						width = target.attr('data-width') || this._core.settings.videoWidth,
						height = target.attr('data-height') || this._core.settings.videoHeight,
						url = target.attr('href');

					if (url) {

						/*
								Parses the id's out of the following urls (and probably more):
								https://www.youtube.com/watch?v=:id
								https://youtu.be/:id
								https://vimeo.com/:id
								https://vimeo.com/channels/:channel/:id
								https://vimeo.com/groups/:group/videos/:id
								https://app.vzaar.com/videos/:id
			
								Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
						*/

						id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

						if (id[3].indexOf('youtu') > -1) {
							type = 'youtube';
						} else if (id[3].indexOf('vimeo') > -1) {
							type = 'vimeo';
						} else if (id[3].indexOf('vzaar') > -1) {
							type = 'vzaar';
						} else {
							throw new Error('Video URL not supported.');
						}
						id = id[6];
					} else {
						throw new Error('Missing video URL.');
					}

					this._videos[url] = {
						type: type,
						id: id,
						width: width,
						height: height
					};

					item.attr('data-video', url);

					this.thumbnail(target, this._videos[url]);
				};

				/**
				 * Creates video thumbnail.
				 * @protected
				 * @param {jQuery} target - The target containing the video data.
				 * @param {Object} info - The video info object.
				 * @see `fetch`
				 */
				Video.prototype.thumbnail = function (target, video) {
					var tnLink,
						icon,
						path,
						dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
						customTn = target.find('img'),
						srcType = 'src',
						lazyClass = '',
						settings = this._core.settings,
						create = function (path) {
							icon = '<div class="owl-video-play-icon"></div>';

							if (settings.lazyLoad) {
								tnLink = $('<div/>', {
									"class": 'owl-video-tn ' + lazyClass,
									"srcType": path
								});
							} else {
								tnLink = $('<div/>', {
									"class": "owl-video-tn",
									"style": 'opacity:1;background-image:url(' + path + ')'
								});
							}
							target.after(tnLink);
							target.after(icon);
						};

					// wrap video content into owl-video-wrapper div
					target.wrap($('<div/>', {
						"class": "owl-video-wrapper",
						"style": dimensions
					}));

					if (this._core.settings.lazyLoad) {
						srcType = 'data-src';
						lazyClass = 'owl-lazy';
					}

					// custom thumbnail
					if (customTn.length) {
						create(customTn.attr(srcType));
						customTn.remove();
						return false;
					}

					if (video.type === 'youtube') {
						path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
						create(path);
					} else if (video.type === 'vimeo') {
						$.ajax({
							type: 'GET',
							url: '//vimeo.com/api/v2/video/' + video.id + '.json',
							jsonp: 'callback',
							dataType: 'jsonp',
							success: function (data) {
								path = data[0].thumbnail_large;
								create(path);
							}
						});
					} else if (video.type === 'vzaar') {
						$.ajax({
							type: 'GET',
							url: '//vzaar.com/api/videos/' + video.id + '.json',
							jsonp: 'callback',
							dataType: 'jsonp',
							success: function (data) {
								path = data.framegrab_url;
								create(path);
							}
						});
					}
				};

				/**
				 * Stops the current video.
				 * @public
				 */
				Video.prototype.stop = function () {
					this._core.trigger('stop', null, 'video');
					this._playing.find('.owl-video-frame').remove();
					this._playing.removeClass('owl-video-playing');
					this._playing = null;
					this._core.leave('playing');
					this._core.trigger('stopped', null, 'video');
				};

				/**
				 * Starts the current video.
				 * @public
				 * @param {Event} event - The event arguments.
				 */
				Video.prototype.play = function (event) {
					var target = $(event.target),
						item = target.closest('.' + this._core.settings.itemClass),
						video = this._videos[item.attr('data-video')],
						width = video.width || '100%',
						height = video.height || this._core.$stage.height(),
						html,
						iframe;

					if (this._playing) {
						return;
					}

					this._core.enter('playing');
					this._core.trigger('play', null, 'video');

					item = this._core.items(this._core.relative(item.index()));

					this._core.reset(item.index());

					html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
					html.attr('height', height);
					html.attr('width', width);
					if (video.type === 'youtube') {
						html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);
					} else if (video.type === 'vimeo') {
						html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');
					} else if (video.type === 'vzaar') {
						html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');
					}

					iframe = $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find('.owl-video'));

					this._playing = item.addClass('owl-video-playing');
				};

				/**
				 * Checks whether an video is currently in full screen mode or not.
				 * @todo Bad style because looks like a readonly method but changes members.
				 * @protected
				 * @returns {Boolean}
				 */
				Video.prototype.isInFullScreen = function () {
					var element = document.fullscreenElement || document.mozFullScreenElement ||
						document.webkitFullscreenElement;

					return element && $(element).parent().hasClass('owl-video-frame');
				};

				/**
				 * Destroys the plugin.
				 */
				Video.prototype.destroy = function () {
					var handler, property;

					this._core.$element.off('click.owl.video');

					for (handler in this._handlers) {
						this._core.$element.off(handler, this._handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.Video = Video;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Animate Plugin
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the animate plugin.
				 * @class The Navigation Plugin
				 * @param {Owl} scope - The Owl Carousel
				 */
				var Animate = function (scope) {
					this.core = scope;
					this.core.options = $.extend({}, Animate.Defaults, this.core.options);
					this.swapping = true;
					this.previous = undefined;
					this.next = undefined;

					this.handlers = {
						'change.owl.carousel': $.proxy(function (e) {
							if (e.namespace && e.property.name == 'position') {
								this.previous = this.core.current();
								this.next = e.property.value;
							}
						}, this),
						'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {
							if (e.namespace) {
								this.swapping = e.type == 'translated';
							}
						}, this),
						'translate.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
								this.swap();
							}
						}, this)
					};

					this.core.$element.on(this.handlers);
				};

				/**
				 * Default options.
				 * @public
				 */
				Animate.Defaults = {
					animateOut: false,
					animateIn: false
				};

				/**
				 * Toggles the animation classes whenever an translations starts.
				 * @protected
				 * @returns {Boolean|undefined}
				 */
				Animate.prototype.swap = function () {

					if (this.core.settings.items !== 1) {
						return;
					}

					if (!$.support.animation || !$.support.transition) {
						return;
					}

					this.core.speed(0);

					var left,
						clear = $.proxy(this.clear, this),
						previous = this.core.$stage.children().eq(this.previous),
						next = this.core.$stage.children().eq(this.next),
						incoming = this.core.settings.animateIn,
						outgoing = this.core.settings.animateOut;

					if (this.core.current() === this.previous) {
						return;
					}

					if (outgoing) {
						left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
						previous.one($.support.animation.end, clear)
							.css({ 'left': left + 'px' })
							.addClass('animated owl-animated-out')
							.addClass(outgoing);
					}

					if (incoming) {
						next.one($.support.animation.end, clear)
							.addClass('animated owl-animated-in')
							.addClass(incoming);
					}
				};

				Animate.prototype.clear = function (e) {
					$(e.target).css({ 'left': '' })
						.removeClass('animated owl-animated-out owl-animated-in')
						.removeClass(this.core.settings.animateIn)
						.removeClass(this.core.settings.animateOut);
					this.core.onTransitionEnd();
				};

				/**
				 * Destroys the plugin.
				 * @public
				 */
				Animate.prototype.destroy = function () {
					var handler, property;

					for (handler in this.handlers) {
						this.core.$element.off(handler, this.handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Autoplay Plugin
			 * @version 2.3.4
			 * @author Bartosz Wojciechowski
			 * @author Artus Kolanowski
			 * @author David Deutsch
			 * @author Tom De Caluw
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				/**
				 * Creates the autoplay plugin.
				 * @class The Autoplay Plugin
				 * @param {Owl} scope - The Owl Carousel
				 */
				var Autoplay = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * The autoplay timeout id.
					 * @type {Number}
					 */
					this._call = null;

					/**
					 * Depending on the state of the plugin, this variable contains either
					 * the start time of the timer or the current timer value if it's
					 * paused. Since we start in a paused state we initialize the timer
					 * value.
					 * @type {Number}
					 */
					this._time = 0;

					/**
					 * Stores the timeout currently used.
					 * @type {Number}
					 */
					this._timeout = 0;

					/**
					 * Indicates whenever the autoplay is paused.
					 * @type {Boolean}
					 */
					this._paused = true;

					/**
					 * All event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'changed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && e.property.name === 'settings') {
								if (this._core.settings.autoplay) {
									this.play();
								} else {
									this.stop();
								}
							} else if (e.namespace && e.property.name === 'position' && this._paused) {
								// Reset the timer. This code is triggered when the position
								// of the carousel was changed through user interaction.
								this._time = 0;
							}
						}, this),
						'initialized.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.autoplay) {
								this.play();
							}
						}, this),
						'play.owl.autoplay': $.proxy(function (e, t, s) {
							if (e.namespace) {
								this.play(t, s);
							}
						}, this),
						'stop.owl.autoplay': $.proxy(function (e) {
							if (e.namespace) {
								this.stop();
							}
						}, this),
						'mouseover.owl.autoplay': $.proxy(function () {
							if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
								this.pause();
							}
						}, this),
						'mouseleave.owl.autoplay': $.proxy(function () {
							if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
								this.play();
							}
						}, this),
						'touchstart.owl.core': $.proxy(function () {
							if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
								this.pause();
							}
						}, this),
						'touchend.owl.core': $.proxy(function () {
							if (this._core.settings.autoplayHoverPause) {
								this.play();
							}
						}, this)
					};

					// register event handlers
					this._core.$element.on(this._handlers);

					// set default options
					this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
				};

				/**
				 * Default options.
				 * @public
				 */
				Autoplay.Defaults = {
					autoplay: false,
					autoplayTimeout: 5000,
					autoplayHoverPause: false,
					autoplaySpeed: false
				};

				/**
				 * Transition to the next slide and set a timeout for the next transition.
				 * @private
				 * @param {Number} [speed] - The animation speed for the animations.
				 */
				Autoplay.prototype._next = function (speed) {
					this._call = window.setTimeout(
						$.proxy(this._next, this, speed),
						this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
					);

					if (this._core.is('interacting') || document.hidden) {
						return;
					}
					this._core.next(speed || this._core.settings.autoplaySpeed);
				}

				/**
				 * Reads the current timer value when the timer is playing.
				 * @public
				 */
				Autoplay.prototype.read = function () {
					return new Date().getTime() - this._time;
				};

				/**
				 * Starts the autoplay.
				 * @public
				 * @param {Number} [timeout] - The interval before the next animation starts.
				 * @param {Number} [speed] - The animation speed for the animations.
				 */
				Autoplay.prototype.play = function (timeout, speed) {
					var elapsed;

					if (!this._core.is('rotating')) {
						this._core.enter('rotating');
					}

					timeout = timeout || this._core.settings.autoplayTimeout;

					// Calculate the elapsed time since the last transition. If the carousel
					// wasn't playing this calculation will yield zero.
					elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

					if (this._paused) {
						// Start the clock.
						this._time = this.read();
						this._paused = false;
					} else {
						// Clear the active timeout to allow replacement.
						window.clearTimeout(this._call);
					}

					// Adjust the origin of the timer to match the new timeout value.
					this._time += this.read() % timeout - elapsed;

					this._timeout = timeout;
					this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
				};

				/**
				 * Stops the autoplay.
				 * @public
				 */
				Autoplay.prototype.stop = function () {
					if (this._core.is('rotating')) {
						// Reset the clock.
						this._time = 0;
						this._paused = true;

						window.clearTimeout(this._call);
						this._core.leave('rotating');
					}
				};

				/**
				 * Pauses the autoplay.
				 * @public
				 */
				Autoplay.prototype.pause = function () {
					if (this._core.is('rotating') && !this._paused) {
						// Pause the clock.
						this._time = this.read();
						this._paused = true;

						window.clearTimeout(this._call);
					}
				};

				/**
				 * Destroys the plugin.
				 */
				Autoplay.prototype.destroy = function () {
					var handler, property;

					this.stop();

					for (handler in this._handlers) {
						this._core.$element.off(handler, this._handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Navigation Plugin
			 * @version 2.3.4
			 * @author Artus Kolanowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {
				'use strict';

				/**
				 * Creates the navigation plugin.
				 * @class The Navigation Plugin
				 * @param {Owl} carousel - The Owl Carousel.
				 */
				var Navigation = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * Indicates whether the plugin is initialized or not.
					 * @protected
					 * @type {Boolean}
					 */
					this._initialized = false;

					/**
					 * The current paging indexes.
					 * @protected
					 * @type {Array}
					 */
					this._pages = [];

					/**
					 * All DOM elements of the user interface.
					 * @protected
					 * @type {Object}
					 */
					this._controls = {};

					/**
					 * Markup for an indicator.
					 * @protected
					 * @type {Array.<String>}
					 */
					this._templates = [];

					/**
					 * The carousel element.
					 * @type {jQuery}
					 */
					this.$element = this._core.$element;

					/**
					 * Overridden methods of the carousel.
					 * @protected
					 * @type {Object}
					 */
					this._overrides = {
						next: this._core.next,
						prev: this._core.prev,
						to: this._core.to
					};

					/**
					 * All event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'prepared.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.dotsData) {
								this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
									$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
							}
						}, this),
						'added.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.dotsData) {
								this._templates.splice(e.position, 0, this._templates.pop());
							}
						}, this),
						'remove.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.dotsData) {
								this._templates.splice(e.position, 1);
							}
						}, this),
						'changed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && e.property.name == 'position') {
								this.draw();
							}
						}, this),
						'initialized.owl.carousel': $.proxy(function (e) {
							if (e.namespace && !this._initialized) {
								this._core.trigger('initialize', null, 'navigation');
								this.initialize();
								this.update();
								this.draw();
								this._initialized = true;
								this._core.trigger('initialized', null, 'navigation');
							}
						}, this),
						'refreshed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._initialized) {
								this._core.trigger('refresh', null, 'navigation');
								this.update();
								this.draw();
								this._core.trigger('refreshed', null, 'navigation');
							}
						}, this)
					};

					// set default options
					this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

					// register event handlers
					this.$element.on(this._handlers);
				};

				/**
				 * Default options.
				 * @public
				 * @todo Rename `slideBy` to `navBy`
				 */
				Navigation.Defaults = {
					nav: false,
					navText: [
						'<span aria-label="' + 'Previous' + '">&#x2039;</span>',
						'<span aria-label="' + 'Next' + '">&#x203a;</span>'
					],
					navSpeed: false,
					navElement: 'button type="button" role="presentation"',
					navContainer: false,
					navContainerClass: 'owl-nav',
					navClass: [
						'owl-prev',
						'owl-next'
					],
					slideBy: 1,
					dotClass: 'owl-dot',
					dotsClass: 'owl-dots',
					dots: true,
					dotsEach: false,
					dotsData: false,
					dotsSpeed: false,
					dotsContainer: false
				};

				/**
				 * Initializes the layout of the plugin and extends the carousel.
				 * @protected
				 */
				Navigation.prototype.initialize = function () {
					var override,
						settings = this._core.settings;

					// create DOM structure for relative navigation
					this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
						: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

					this._controls.$previous = $('<' + settings.navElement + '>')
						.addClass(settings.navClass[0])
						.html(settings.navText[0])
						.prependTo(this._controls.$relative)
						.on('click', $.proxy(function (e) {
							this.prev(settings.navSpeed);
						}, this));
					this._controls.$next = $('<' + settings.navElement + '>')
						.addClass(settings.navClass[1])
						.html(settings.navText[1])
						.appendTo(this._controls.$relative)
						.on('click', $.proxy(function (e) {
							this.next(settings.navSpeed);
						}, this));

					// create DOM structure for absolute navigation
					if (!settings.dotsData) {
						this._templates = [$('<button role="button">')
							.addClass(settings.dotClass)
							.append($('<span>'))
							.prop('outerHTML')];
					}

					this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
						: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

					this._controls.$absolute.on('click', 'button', $.proxy(function (e) {
						var index = $(e.target).parent().is(this._controls.$absolute)
							? $(e.target).index() : $(e.target).parent().index();

						e.preventDefault();

						this.to(index, settings.dotsSpeed);
					}, this));

					/*$el.on('focusin', function() {
						$(document).off(".carousel");
			
						$(document).on('keydown.carousel', function(e) {
							if(e.keyCode == 37) {
								$el.trigger('prev.owl')
							}
							if(e.keyCode == 39) {
								$el.trigger('next.owl')
							}
						});
					});*/

					// override public methods of the carousel
					for (override in this._overrides) {
						this._core[override] = $.proxy(this[override], this);
					}
				};

				/**
				 * Destroys the plugin.
				 * @protected
				 */
				Navigation.prototype.destroy = function () {
					var handler, control, property, override, settings;
					settings = this._core.settings;

					for (handler in this._handlers) {
						this.$element.off(handler, this._handlers[handler]);
					}
					for (control in this._controls) {
						if (control === '$relative' && settings.navContainer) {
							this._controls[control].html('');
						} else {
							this._controls[control].remove();
						}
					}
					for (override in this.overides) {
						this._core[override] = this._overrides[override];
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				/**
				 * Updates the internal state.
				 * @protected
				 */
				Navigation.prototype.update = function () {
					var i, j, k,
						lower = this._core.clones().length / 2,
						upper = lower + this._core.items().length,
						maximum = this._core.maximum(true),
						settings = this._core.settings,
						size = settings.center || settings.autoWidth || settings.dotsData
							? 1 : settings.dotsEach || settings.items;

					if (settings.slideBy !== 'page') {
						settings.slideBy = Math.min(settings.slideBy, settings.items);
					}

					if (settings.dots || settings.slideBy == 'page') {
						this._pages = [];

						for (i = lower, j = 0, k = 0; i < upper; i++) {
							if (j >= size || j === 0) {
								this._pages.push({
									start: Math.min(maximum, i - lower),
									end: i - lower + size - 1
								});
								if (Math.min(maximum, i - lower) === maximum) {
									break;
								}
								j = 0, ++k;
							}
							j += this._core.mergers(this._core.relative(i));
						}
					}
				};

				/**
				 * Draws the user interface.
				 * @todo The option `dotsData` wont work.
				 * @protected
				 */
				Navigation.prototype.draw = function () {
					var difference,
						settings = this._core.settings,
						disabled = this._core.items().length <= settings.items,
						index = this._core.relative(this._core.current()),
						loop = settings.loop || settings.rewind;

					this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

					if (settings.nav) {
						this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
						this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
					}

					this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

					if (settings.dots) {
						difference = this._pages.length - this._controls.$absolute.children().length;

						if (settings.dotsData && difference !== 0) {
							this._controls.$absolute.html(this._templates.join(''));
						} else if (difference > 0) {
							this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
						} else if (difference < 0) {
							this._controls.$absolute.children().slice(difference).remove();
						}

						this._controls.$absolute.find('.active').removeClass('active');
						this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
					}
				};

				/**
				 * Extends event data.
				 * @protected
				 * @param {Event} event - The event object which gets thrown.
				 */
				Navigation.prototype.onTrigger = function (event) {
					var settings = this._core.settings;

					event.page = {
						index: $.inArray(this.current(), this._pages),
						count: this._pages.length,
						size: settings && (settings.center || settings.autoWidth || settings.dotsData
							? 1 : settings.dotsEach || settings.items)
					};
				};

				/**
				 * Gets the current page position of the carousel.
				 * @protected
				 * @returns {Number}
				 */
				Navigation.prototype.current = function () {
					var current = this._core.relative(this._core.current());
					return $.grep(this._pages, $.proxy(function (page, index) {
						return page.start <= current && page.end >= current;
					}, this)).pop();
				};

				/**
				 * Gets the current succesor/predecessor position.
				 * @protected
				 * @returns {Number}
				 */
				Navigation.prototype.getPosition = function (successor) {
					var position, length,
						settings = this._core.settings;

					if (settings.slideBy == 'page') {
						position = $.inArray(this.current(), this._pages);
						length = this._pages.length;
						successor ? ++position : --position;
						position = this._pages[((position % length) + length) % length].start;
					} else {
						position = this._core.relative(this._core.current());
						length = this._core.items().length;
						successor ? position += settings.slideBy : position -= settings.slideBy;
					}

					return position;
				};

				/**
				 * Slides to the next item or page.
				 * @public
				 * @param {Number} [speed=false] - The time in milliseconds for the transition.
				 */
				Navigation.prototype.next = function (speed) {
					$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
				};

				/**
				 * Slides to the previous item or page.
				 * @public
				 * @param {Number} [speed=false] - The time in milliseconds for the transition.
				 */
				Navigation.prototype.prev = function (speed) {
					$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
				};

				/**
				 * Slides to the specified item or page.
				 * @public
				 * @param {Number} position - The position of the item or page.
				 * @param {Number} [speed] - The time in milliseconds for the transition.
				 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
				 */
				Navigation.prototype.to = function (position, speed, standard) {
					var length;

					if (!standard && this._pages.length) {
						length = this._pages.length;
						$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
					} else {
						$.proxy(this._overrides.to, this._core)(position, speed);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Hash Plugin
			 * @version 2.3.4
			 * @author Artus Kolanowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {
				'use strict';

				/**
				 * Creates the hash plugin.
				 * @class The Hash Plugin
				 * @param {Owl} carousel - The Owl Carousel
				 */
				var Hash = function (carousel) {
					/**
					 * Reference to the core.
					 * @protected
					 * @type {Owl}
					 */
					this._core = carousel;

					/**
					 * Hash index for the items.
					 * @protected
					 * @type {Object}
					 */
					this._hashes = {};

					/**
					 * The carousel element.
					 * @type {jQuery}
					 */
					this.$element = this._core.$element;

					/**
					 * All event handlers.
					 * @protected
					 * @type {Object}
					 */
					this._handlers = {
						'initialized.owl.carousel': $.proxy(function (e) {
							if (e.namespace && this._core.settings.startPosition === 'URLHash') {
								$(window).trigger('hashchange.owl.navigation');
							}
						}, this),
						'prepared.owl.carousel': $.proxy(function (e) {
							if (e.namespace) {
								var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

								if (!hash) {
									return;
								}

								this._hashes[hash] = e.content;
							}
						}, this),
						'changed.owl.carousel': $.proxy(function (e) {
							if (e.namespace && e.property.name === 'position') {
								var current = this._core.items(this._core.relative(this._core.current())),
									hash = $.map(this._hashes, function (item, hash) {
										return item === current ? hash : null;
									}).join();

								if (!hash || window.location.hash.slice(1) === hash) {
									return;
								}

								window.location.hash = hash;
							}
						}, this)
					};

					// set default options
					this._core.options = $.extend({}, Hash.Defaults, this._core.options);

					// register the event handlers
					this.$element.on(this._handlers);

					// register event listener for hash navigation
					$(window).on('hashchange.owl.navigation', $.proxy(function (e) {
						var hash = window.location.hash.substring(1),
							items = this._core.$stage.children(),
							position = this._hashes[hash] && items.index(this._hashes[hash]);

						if (position === undefined || position === this._core.current()) {
							return;
						}

						this._core.to(this._core.relative(position), false, true);
					}, this));
				};

				/**
				 * Default options.
				 * @public
				 */
				Hash.Defaults = {
					URLhashListener: false
				};

				/**
				 * Destroys the plugin.
				 * @public
				 */
				Hash.prototype.destroy = function () {
					var handler, property;

					$(window).off('hashchange.owl.navigation');

					for (handler in this._handlers) {
						this._core.$element.off(handler, this._handlers[handler]);
					}
					for (property in Object.getOwnPropertyNames(this)) {
						typeof this[property] != 'function' && (this[property] = null);
					}
				};

				$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

			})(window.Zepto || window.jQuery, window, document);

			/**
			 * Support Plugin
			 *
			 * @version 2.3.4
			 * @author Vivid Planet Software GmbH
			 * @author Artus Kolanowski
			 * @author David Deutsch
			 * @license The MIT License (MIT)
			 */
			; (function ($, window, document, undefined) {

				var style = $('<support>').get(0).style,
					prefixes = 'Webkit Moz O ms'.split(' '),
					events = {
						transition: {
							end: {
								WebkitTransition: 'webkitTransitionEnd',
								MozTransition: 'transitionend',
								OTransition: 'oTransitionEnd',
								transition: 'transitionend'
							}
						},
						animation: {
							end: {
								WebkitAnimation: 'webkitAnimationEnd',
								MozAnimation: 'animationend',
								OAnimation: 'oAnimationEnd',
								animation: 'animationend'
							}
						}
					},
					tests = {
						csstransforms: function () {
							return !!test('transform');
						},
						csstransforms3d: function () {
							return !!test('perspective');
						},
						csstransitions: function () {
							return !!test('transition');
						},
						cssanimations: function () {
							return !!test('animation');
						}
					};

				function test(property, prefixed) {
					var result = false,
						upper = property.charAt(0).toUpperCase() + property.slice(1);

					$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {
						if (style[property] !== undefined) {
							result = prefixed ? property : true;
							return false;
						}
					});

					return result;
				}

				function prefixed(property) {
					return test(property, true);
				}

				if (tests.csstransitions()) {
					/* jshint -W053 */
					$.support.transition = new String(prefixed('transition'))
					$.support.transition.end = events.transition.end[$.support.transition];
				}

				if (tests.cssanimations()) {
					/* jshint -W053 */
					$.support.animation = new String(prefixed('animation'))
					$.support.animation.end = events.animation.end[$.support.animation];
				}

				if (tests.csstransforms()) {
					/* jshint -W053 */
					$.support.transform = new String(prefixed('transform'));
					$.support.transform3d = tests.csstransforms3d();
				}

			})(window.Zepto || window.jQuery, window, document);


			/***/
		}),

/***/ "./node_modules/slick-carousel/slick/slick.js":
/*!****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
			/* global window, document, define, jQuery, setInterval, clearInterval */
			; (function (factory) {
				'use strict';
				if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { }

			}(function ($) {
				'use strict';
				var Slick = window.Slick || {};

				Slick = (function () {

					var instanceUid = 0;

					function Slick(element, settings) {

						var _ = this, dataSettings;

						_.defaults = {
							accessibility: true,
							adaptiveHeight: false,
							appendArrows: $(element),
							appendDots: $(element),
							arrows: true,
							asNavFor: null,
							prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
							nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
							autoplay: false,
							autoplaySpeed: 3000,
							centerMode: false,
							centerPadding: '50px',
							cssEase: 'ease',
							customPaging: function (slider, i) {
								return $('<button type="button" />').text(i + 1);
							},
							dots: false,
							dotsClass: 'slick-dots',
							draggable: true,
							easing: 'linear',
							edgeFriction: 0.35,
							fade: false,
							focusOnSelect: false,
							focusOnChange: false,
							infinite: true,
							initialSlide: 0,
							lazyLoad: 'ondemand',
							mobileFirst: false,
							pauseOnHover: true,
							pauseOnFocus: true,
							pauseOnDotsHover: false,
							respondTo: 'window',
							responsive: null,
							rows: 1,
							rtl: false,
							slide: '',
							slidesPerRow: 1,
							slidesToShow: 1,
							slidesToScroll: 1,
							speed: 500,
							swipe: true,
							swipeToSlide: false,
							touchMove: true,
							touchThreshold: 5,
							useCSS: true,
							useTransform: true,
							variableWidth: false,
							vertical: false,
							verticalSwiping: false,
							waitForAnimate: true,
							zIndex: 1000
						};

						_.initials = {
							animating: false,
							dragging: false,
							autoPlayTimer: null,
							currentDirection: 0,
							currentLeft: null,
							currentSlide: 0,
							direction: 1,
							$dots: null,
							listWidth: null,
							listHeight: null,
							loadIndex: 0,
							$nextArrow: null,
							$prevArrow: null,
							scrolling: false,
							slideCount: null,
							slideWidth: null,
							$slideTrack: null,
							$slides: null,
							sliding: false,
							slideOffset: 0,
							swipeLeft: null,
							swiping: false,
							$list: null,
							touchObject: {},
							transformsEnabled: false,
							unslicked: false
						};

						$.extend(_, _.initials);

						_.activeBreakpoint = null;
						_.animType = null;
						_.animProp = null;
						_.breakpoints = [];
						_.breakpointSettings = [];
						_.cssTransitions = false;
						_.focussed = false;
						_.interrupted = false;
						_.hidden = 'hidden';
						_.paused = true;
						_.positionProp = null;
						_.respondTo = null;
						_.rowCount = 1;
						_.shouldClick = true;
						_.$slider = $(element);
						_.$slidesCache = null;
						_.transformType = null;
						_.transitionType = null;
						_.visibilityChange = 'visibilitychange';
						_.windowWidth = 0;
						_.windowTimer = null;

						dataSettings = $(element).data('slick') || {};

						_.options = $.extend({}, _.defaults, settings, dataSettings);

						_.currentSlide = _.options.initialSlide;

						_.originalSettings = _.options;

						if (typeof document.mozHidden !== 'undefined') {
							_.hidden = 'mozHidden';
							_.visibilityChange = 'mozvisibilitychange';
						} else if (typeof document.webkitHidden !== 'undefined') {
							_.hidden = 'webkitHidden';
							_.visibilityChange = 'webkitvisibilitychange';
						}

						_.autoPlay = $.proxy(_.autoPlay, _);
						_.autoPlayClear = $.proxy(_.autoPlayClear, _);
						_.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
						_.changeSlide = $.proxy(_.changeSlide, _);
						_.clickHandler = $.proxy(_.clickHandler, _);
						_.selectHandler = $.proxy(_.selectHandler, _);
						_.setPosition = $.proxy(_.setPosition, _);
						_.swipeHandler = $.proxy(_.swipeHandler, _);
						_.dragHandler = $.proxy(_.dragHandler, _);
						_.keyHandler = $.proxy(_.keyHandler, _);

						_.instanceUid = instanceUid++;

						// A simple way to check for HTML strings
						// Strict HTML recognition (must start with <)
						// Extracted from jQuery v1.11 source
						_.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


						_.registerBreakpoints();
						_.init(true);

					}

					return Slick;

				}());

				Slick.prototype.activateADA = function () {
					var _ = this;

					_.$slideTrack.find('.slick-active').attr({
						'aria-hidden': 'false'
					}).find('a, input, button, select').attr({
						'tabindex': '0'
					});

				};

				Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {

					var _ = this;

					if (typeof (index) === 'boolean') {
						addBefore = index;
						index = null;
					} else if (index < 0 || (index >= _.slideCount)) {
						return false;
					}

					_.unload();

					if (typeof (index) === 'number') {
						if (index === 0 && _.$slides.length === 0) {
							$(markup).appendTo(_.$slideTrack);
						} else if (addBefore) {
							$(markup).insertBefore(_.$slides.eq(index));
						} else {
							$(markup).insertAfter(_.$slides.eq(index));
						}
					} else {
						if (addBefore === true) {
							$(markup).prependTo(_.$slideTrack);
						} else {
							$(markup).appendTo(_.$slideTrack);
						}
					}

					_.$slides = _.$slideTrack.children(this.options.slide);

					_.$slideTrack.children(this.options.slide).detach();

					_.$slideTrack.append(_.$slides);

					_.$slides.each(function (index, element) {
						$(element).attr('data-slick-index', index);
					});

					_.$slidesCache = _.$slides;

					_.reinit();

				};

				Slick.prototype.animateHeight = function () {
					var _ = this;
					if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
						var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
						_.$list.animate({
							height: targetHeight
						}, _.options.speed);
					}
				};

				Slick.prototype.animateSlide = function (targetLeft, callback) {

					var animProps = {},
						_ = this;

					_.animateHeight();

					if (_.options.rtl === true && _.options.vertical === false) {
						targetLeft = -targetLeft;
					}
					if (_.transformsEnabled === false) {
						if (_.options.vertical === false) {
							_.$slideTrack.animate({
								left: targetLeft
							}, _.options.speed, _.options.easing, callback);
						} else {
							_.$slideTrack.animate({
								top: targetLeft
							}, _.options.speed, _.options.easing, callback);
						}

					} else {

						if (_.cssTransitions === false) {
							if (_.options.rtl === true) {
								_.currentLeft = -(_.currentLeft);
							}
							$({
								animStart: _.currentLeft
							}).animate({
								animStart: targetLeft
							}, {
								duration: _.options.speed,
								easing: _.options.easing,
								step: function (now) {
									now = Math.ceil(now);
									if (_.options.vertical === false) {
										animProps[_.animType] = 'translate(' +
											now + 'px, 0px)';
										_.$slideTrack.css(animProps);
									} else {
										animProps[_.animType] = 'translate(0px,' +
											now + 'px)';
										_.$slideTrack.css(animProps);
									}
								},
								complete: function () {
									if (callback) {
										callback.call();
									}
								}
							});

						} else {

							_.applyTransition();
							targetLeft = Math.ceil(targetLeft);

							if (_.options.vertical === false) {
								animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
							} else {
								animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
							}
							_.$slideTrack.css(animProps);

							if (callback) {
								setTimeout(function () {

									_.disableTransition();

									callback.call();
								}, _.options.speed);
							}

						}

					}

				};

				Slick.prototype.getNavTarget = function () {

					var _ = this,
						asNavFor = _.options.asNavFor;

					if (asNavFor && asNavFor !== null) {
						asNavFor = $(asNavFor).not(_.$slider);
					}

					return asNavFor;

				};

				Slick.prototype.asNavFor = function (index) {

					var _ = this,
						asNavFor = _.getNavTarget();

					if (asNavFor !== null && typeof asNavFor === 'object') {
						asNavFor.each(function () {
							var target = $(this).slick('getSlick');
							if (!target.unslicked) {
								target.slideHandler(index, true);
							}
						});
					}

				};

				Slick.prototype.applyTransition = function (slide) {

					var _ = this,
						transition = {};

					if (_.options.fade === false) {
						transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
					} else {
						transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
					}

					if (_.options.fade === false) {
						_.$slideTrack.css(transition);
					} else {
						_.$slides.eq(slide).css(transition);
					}

				};

				Slick.prototype.autoPlay = function () {

					var _ = this;

					_.autoPlayClear();

					if (_.slideCount > _.options.slidesToShow) {
						_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
					}

				};

				Slick.prototype.autoPlayClear = function () {

					var _ = this;

					if (_.autoPlayTimer) {
						clearInterval(_.autoPlayTimer);
					}

				};

				Slick.prototype.autoPlayIterator = function () {

					var _ = this,
						slideTo = _.currentSlide + _.options.slidesToScroll;

					if (!_.paused && !_.interrupted && !_.focussed) {

						if (_.options.infinite === false) {

							if (_.direction === 1 && (_.currentSlide + 1) === (_.slideCount - 1)) {
								_.direction = 0;
							}

							else if (_.direction === 0) {

								slideTo = _.currentSlide - _.options.slidesToScroll;

								if (_.currentSlide - 1 === 0) {
									_.direction = 1;
								}

							}

						}

						_.slideHandler(slideTo);

					}

				};

				Slick.prototype.buildArrows = function () {

					var _ = this;

					if (_.options.arrows === true) {

						_.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
						_.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

						if (_.slideCount > _.options.slidesToShow) {

							_.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
							_.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

							if (_.htmlExpr.test(_.options.prevArrow)) {
								_.$prevArrow.prependTo(_.options.appendArrows);
							}

							if (_.htmlExpr.test(_.options.nextArrow)) {
								_.$nextArrow.appendTo(_.options.appendArrows);
							}

							if (_.options.infinite !== true) {
								_.$prevArrow
									.addClass('slick-disabled')
									.attr('aria-disabled', 'true');
							}

						} else {

							_.$prevArrow.add(_.$nextArrow)

								.addClass('slick-hidden')
								.attr({
									'aria-disabled': 'true',
									'tabindex': '-1'
								});

						}

					}

				};

				Slick.prototype.buildDots = function () {

					var _ = this,
						i, dot;

					if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

						_.$slider.addClass('slick-dotted');

						dot = $('<ul />').addClass(_.options.dotsClass);

						for (i = 0; i <= _.getDotCount(); i += 1) {
							dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
						}

						_.$dots = dot.appendTo(_.options.appendDots);

						_.$dots.find('li').first().addClass('slick-active');

					}

				};

				Slick.prototype.buildOut = function () {

					var _ = this;

					_.$slides =
						_.$slider
							.children(_.options.slide + ':not(.slick-cloned)')
							.addClass('slick-slide');

					_.slideCount = _.$slides.length;

					_.$slides.each(function (index, element) {
						$(element)
							.attr('data-slick-index', index)
							.data('originalStyling', $(element).attr('style') || '');
					});

					_.$slider.addClass('slick-slider');

					_.$slideTrack = (_.slideCount === 0) ?
						$('<div class="slick-track"/>').appendTo(_.$slider) :
						_.$slides.wrapAll('<div class="slick-track"/>').parent();

					_.$list = _.$slideTrack.wrap(
						'<div class="slick-list"/>').parent();
					_.$slideTrack.css('opacity', 0);

					if (_.options.centerMode === true || _.options.swipeToSlide === true) {
						_.options.slidesToScroll = 1;
					}

					$('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

					_.setupInfinite();

					_.buildArrows();

					_.buildDots();

					_.updateDots();


					_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

					if (_.options.draggable === true) {
						_.$list.addClass('draggable');
					}

				};

				Slick.prototype.buildRows = function () {

					var _ = this, a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection;

					newSlides = document.createDocumentFragment();
					originalSlides = _.$slider.children();

					if (_.options.rows > 0) {

						slidesPerSection = _.options.slidesPerRow * _.options.rows;
						numOfSlides = Math.ceil(
							originalSlides.length / slidesPerSection
						);

						for (a = 0; a < numOfSlides; a++) {
							var slide = document.createElement('div');
							for (b = 0; b < _.options.rows; b++) {
								var row = document.createElement('div');
								for (c = 0; c < _.options.slidesPerRow; c++) {
									var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
									if (originalSlides.get(target)) {
										row.appendChild(originalSlides.get(target));
									}
								}
								slide.appendChild(row);
							}
							newSlides.appendChild(slide);
						}

						_.$slider.empty().append(newSlides);
						_.$slider.children().children().children()
							.css({
								'width': (100 / _.options.slidesPerRow) + '%',
								'display': 'inline-block'
							});

					}

				};

				Slick.prototype.checkResponsive = function (initial, forceUpdate) {

					var _ = this,
						breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
					var sliderWidth = _.$slider.width();
					var windowWidth = window.innerWidth || $(window).width();

					if (_.respondTo === 'window') {
						respondToWidth = windowWidth;
					} else if (_.respondTo === 'slider') {
						respondToWidth = sliderWidth;
					} else if (_.respondTo === 'min') {
						respondToWidth = Math.min(windowWidth, sliderWidth);
					}

					if (_.options.responsive &&
						_.options.responsive.length &&
						_.options.responsive !== null) {

						targetBreakpoint = null;

						for (breakpoint in _.breakpoints) {
							if (_.breakpoints.hasOwnProperty(breakpoint)) {
								if (_.originalSettings.mobileFirst === false) {
									if (respondToWidth < _.breakpoints[breakpoint]) {
										targetBreakpoint = _.breakpoints[breakpoint];
									}
								} else {
									if (respondToWidth > _.breakpoints[breakpoint]) {
										targetBreakpoint = _.breakpoints[breakpoint];
									}
								}
							}
						}

						if (targetBreakpoint !== null) {
							if (_.activeBreakpoint !== null) {
								if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
									_.activeBreakpoint =
										targetBreakpoint;
									if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
										_.unslick(targetBreakpoint);
									} else {
										_.options = $.extend({}, _.originalSettings,
											_.breakpointSettings[
											targetBreakpoint]);
										if (initial === true) {
											_.currentSlide = _.options.initialSlide;
										}
										_.refresh(initial);
									}
									triggerBreakpoint = targetBreakpoint;
								}
							} else {
								_.activeBreakpoint = targetBreakpoint;
								if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
									_.unslick(targetBreakpoint);
								} else {
									_.options = $.extend({}, _.originalSettings,
										_.breakpointSettings[
										targetBreakpoint]);
									if (initial === true) {
										_.currentSlide = _.options.initialSlide;
									}
									_.refresh(initial);
								}
								triggerBreakpoint = targetBreakpoint;
							}
						} else {
							if (_.activeBreakpoint !== null) {
								_.activeBreakpoint = null;
								_.options = _.originalSettings;
								if (initial === true) {
									_.currentSlide = _.options.initialSlide;
								}
								_.refresh(initial);
								triggerBreakpoint = targetBreakpoint;
							}
						}

						// only trigger breakpoints during an actual break. not on initialize.
						if (!initial && triggerBreakpoint !== false) {
							_.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
						}
					}

				};

				Slick.prototype.changeSlide = function (event, dontAnimate) {

					var _ = this,
						$target = $(event.currentTarget),
						indexOffset, slideOffset, unevenOffset;

					// If target is a link, prevent default action.
					if ($target.is('a')) {
						event.preventDefault();
					}

					// If target is not the <li> element (ie: a child), find the <li>.
					if (!$target.is('li')) {
						$target = $target.closest('li');
					}

					unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
					indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

					switch (event.data.message) {

						case 'previous':
							slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
							if (_.slideCount > _.options.slidesToShow) {
								_.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
							}
							break;

						case 'next':
							slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
							if (_.slideCount > _.options.slidesToShow) {
								_.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
							}
							break;

						case 'index':
							var index = event.data.index === 0 ? 0 :
								event.data.index || $target.index() * _.options.slidesToScroll;

							_.slideHandler(_.checkNavigable(index), false, dontAnimate);
							$target.children().trigger('focus');
							break;

						default:
							return;
					}

				};

				Slick.prototype.checkNavigable = function (index) {

					var _ = this,
						navigables, prevNavigable;

					navigables = _.getNavigableIndexes();
					prevNavigable = 0;
					if (index > navigables[navigables.length - 1]) {
						index = navigables[navigables.length - 1];
					} else {
						for (var n in navigables) {
							if (index < navigables[n]) {
								index = prevNavigable;
								break;
							}
							prevNavigable = navigables[n];
						}
					}

					return index;
				};

				Slick.prototype.cleanUpEvents = function () {

					var _ = this;

					if (_.options.dots && _.$dots !== null) {

						$('li', _.$dots)
							.off('click.slick', _.changeSlide)
							.off('mouseenter.slick', $.proxy(_.interrupt, _, true))
							.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

						if (_.options.accessibility === true) {
							_.$dots.off('keydown.slick', _.keyHandler);
						}
					}

					_.$slider.off('focus.slick blur.slick');

					if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
						_.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
						_.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

						if (_.options.accessibility === true) {
							_.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
							_.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
						}
					}

					_.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
					_.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
					_.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
					_.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

					_.$list.off('click.slick', _.clickHandler);

					$(document).off(_.visibilityChange, _.visibility);

					_.cleanUpSlideEvents();

					if (_.options.accessibility === true) {
						_.$list.off('keydown.slick', _.keyHandler);
					}

					if (_.options.focusOnSelect === true) {
						$(_.$slideTrack).children().off('click.slick', _.selectHandler);
					}

					$(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

					$(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

					$('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

					$(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

				};

				Slick.prototype.cleanUpSlideEvents = function () {

					var _ = this;

					_.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
					_.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

				};

				Slick.prototype.cleanUpRows = function () {

					var _ = this, originalSlides;

					if (_.options.rows > 0) {
						originalSlides = _.$slides.children().children();
						originalSlides.removeAttr('style');
						_.$slider.empty().append(originalSlides);
					}

				};

				Slick.prototype.clickHandler = function (event) {

					var _ = this;

					if (_.shouldClick === false) {
						event.stopImmediatePropagation();
						event.stopPropagation();
						event.preventDefault();
					}

				};

				Slick.prototype.destroy = function (refresh) {

					var _ = this;

					_.autoPlayClear();

					_.touchObject = {};

					_.cleanUpEvents();

					$('.slick-cloned', _.$slider).detach();

					if (_.$dots) {
						_.$dots.remove();
					}

					if (_.$prevArrow && _.$prevArrow.length) {

						_.$prevArrow
							.removeClass('slick-disabled slick-arrow slick-hidden')
							.removeAttr('aria-hidden aria-disabled tabindex')
							.css('display', '');

						if (_.htmlExpr.test(_.options.prevArrow)) {
							_.$prevArrow.remove();
						}
					}

					if (_.$nextArrow && _.$nextArrow.length) {

						_.$nextArrow
							.removeClass('slick-disabled slick-arrow slick-hidden')
							.removeAttr('aria-hidden aria-disabled tabindex')
							.css('display', '');

						if (_.htmlExpr.test(_.options.nextArrow)) {
							_.$nextArrow.remove();
						}
					}


					if (_.$slides) {

						_.$slides
							.removeClass('slick-slide slick-active slick-center slick-visible slick-current')
							.removeAttr('aria-hidden')
							.removeAttr('data-slick-index')
							.each(function () {
								$(this).attr('style', $(this).data('originalStyling'));
							});

						_.$slideTrack.children(this.options.slide).detach();

						_.$slideTrack.detach();

						_.$list.detach();

						_.$slider.append(_.$slides);
					}

					_.cleanUpRows();

					_.$slider.removeClass('slick-slider');
					_.$slider.removeClass('slick-initialized');
					_.$slider.removeClass('slick-dotted');

					_.unslicked = true;

					if (!refresh) {
						_.$slider.trigger('destroy', [_]);
					}

				};

				Slick.prototype.disableTransition = function (slide) {

					var _ = this,
						transition = {};

					transition[_.transitionType] = '';

					if (_.options.fade === false) {
						_.$slideTrack.css(transition);
					} else {
						_.$slides.eq(slide).css(transition);
					}

				};

				Slick.prototype.fadeSlide = function (slideIndex, callback) {

					var _ = this;

					if (_.cssTransitions === false) {

						_.$slides.eq(slideIndex).css({
							zIndex: _.options.zIndex
						});

						_.$slides.eq(slideIndex).animate({
							opacity: 1
						}, _.options.speed, _.options.easing, callback);

					} else {

						_.applyTransition(slideIndex);

						_.$slides.eq(slideIndex).css({
							opacity: 1,
							zIndex: _.options.zIndex
						});

						if (callback) {
							setTimeout(function () {

								_.disableTransition(slideIndex);

								callback.call();
							}, _.options.speed);
						}

					}

				};

				Slick.prototype.fadeSlideOut = function (slideIndex) {

					var _ = this;

					if (_.cssTransitions === false) {

						_.$slides.eq(slideIndex).animate({
							opacity: 0,
							zIndex: _.options.zIndex - 2
						}, _.options.speed, _.options.easing);

					} else {

						_.applyTransition(slideIndex);

						_.$slides.eq(slideIndex).css({
							opacity: 0,
							zIndex: _.options.zIndex - 2
						});

					}

				};

				Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {

					var _ = this;

					if (filter !== null) {

						_.$slidesCache = _.$slides;

						_.unload();

						_.$slideTrack.children(this.options.slide).detach();

						_.$slidesCache.filter(filter).appendTo(_.$slideTrack);

						_.reinit();

					}

				};

				Slick.prototype.focusHandler = function () {

					var _ = this;

					_.$slider
						.off('focus.slick blur.slick')
						.on('focus.slick blur.slick', '*', function (event) {

							event.stopImmediatePropagation();
							var $sf = $(this);

							setTimeout(function () {

								if (_.options.pauseOnFocus) {
									_.focussed = $sf.is(':focus');
									_.autoPlay();
								}

							}, 0);

						});
				};

				Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {

					var _ = this;
					return _.currentSlide;

				};

				Slick.prototype.getDotCount = function () {

					var _ = this;

					var breakPoint = 0;
					var counter = 0;
					var pagerQty = 0;

					if (_.options.infinite === true) {
						if (_.slideCount <= _.options.slidesToShow) {
							++pagerQty;
						} else {
							while (breakPoint < _.slideCount) {
								++pagerQty;
								breakPoint = counter + _.options.slidesToScroll;
								counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
							}
						}
					} else if (_.options.centerMode === true) {
						pagerQty = _.slideCount;
					} else if (!_.options.asNavFor) {
						pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
					} else {
						while (breakPoint < _.slideCount) {
							++pagerQty;
							breakPoint = counter + _.options.slidesToScroll;
							counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
						}
					}

					return pagerQty - 1;

				};

				Slick.prototype.getLeft = function (slideIndex) {

					var _ = this,
						targetLeft,
						verticalHeight,
						verticalOffset = 0,
						targetSlide,
						coef;

					_.slideOffset = 0;
					verticalHeight = _.$slides.first().outerHeight(true);

					if (_.options.infinite === true) {
						if (_.slideCount > _.options.slidesToShow) {
							_.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
							coef = -1

							if (_.options.vertical === true && _.options.centerMode === true) {
								if (_.options.slidesToShow === 2) {
									coef = -1.5;
								} else if (_.options.slidesToShow === 1) {
									coef = -2
								}
							}
							verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
						}
						if (_.slideCount % _.options.slidesToScroll !== 0) {
							if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
								if (slideIndex > _.slideCount) {
									_.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
									verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
								} else {
									_.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
									verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
								}
							}
						}
					} else {
						if (slideIndex + _.options.slidesToShow > _.slideCount) {
							_.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
							verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
						}
					}

					if (_.slideCount <= _.options.slidesToShow) {
						_.slideOffset = 0;
						verticalOffset = 0;
					}

					if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
						_.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
					} else if (_.options.centerMode === true && _.options.infinite === true) {
						_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
					} else if (_.options.centerMode === true) {
						_.slideOffset = 0;
						_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
					}

					if (_.options.vertical === false) {
						targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
					} else {
						targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
					}

					if (_.options.variableWidth === true) {

						if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
						} else {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
						}

						if (_.options.rtl === true) {
							if (targetSlide[0]) {
								targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
							} else {
								targetLeft = 0;
							}
						} else {
							targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
						}

						if (_.options.centerMode === true) {
							if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
								targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
							} else {
								targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
							}

							if (_.options.rtl === true) {
								if (targetSlide[0]) {
									targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
								} else {
									targetLeft = 0;
								}
							} else {
								targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
							}

							targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
						}
					}

					return targetLeft;

				};

				Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {

					var _ = this;

					return _.options[option];

				};

				Slick.prototype.getNavigableIndexes = function () {

					var _ = this,
						breakPoint = 0,
						counter = 0,
						indexes = [],
						max;

					if (_.options.infinite === false) {
						max = _.slideCount;
					} else {
						breakPoint = _.options.slidesToScroll * -1;
						counter = _.options.slidesToScroll * -1;
						max = _.slideCount * 2;
					}

					while (breakPoint < max) {
						indexes.push(breakPoint);
						breakPoint = counter + _.options.slidesToScroll;
						counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
					}

					return indexes;

				};

				Slick.prototype.getSlick = function () {

					return this;

				};

				Slick.prototype.getSlideCount = function () {

					var _ = this,
						slidesTraversed, swipedSlide, centerOffset;

					centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

					if (_.options.swipeToSlide === true) {
						_.$slideTrack.find('.slick-slide').each(function (index, slide) {
							if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
								swipedSlide = slide;
								return false;
							}
						});

						slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

						return slidesTraversed;

					} else {
						return _.options.slidesToScroll;
					}

				};

				Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {

					var _ = this;

					_.changeSlide({
						data: {
							message: 'index',
							index: parseInt(slide)
						}
					}, dontAnimate);

				};

				Slick.prototype.init = function (creation) {

					var _ = this;

					if (!$(_.$slider).hasClass('slick-initialized')) {

						$(_.$slider).addClass('slick-initialized');

						_.buildRows();
						_.buildOut();
						_.setProps();
						_.startLoad();
						_.loadSlider();
						_.initializeEvents();
						_.updateArrows();
						_.updateDots();
						_.checkResponsive(true);
						_.focusHandler();

					}

					if (creation) {
						_.$slider.trigger('init', [_]);
					}

					if (_.options.accessibility === true) {
						_.initADA();
					}

					if (_.options.autoplay) {

						_.paused = false;
						_.autoPlay();

					}

				};

				Slick.prototype.initADA = function () {
					var _ = this,
						numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
						tabControlIndexes = _.getNavigableIndexes().filter(function (val) {
							return (val >= 0) && (val < _.slideCount);
						});

					_.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
						'aria-hidden': 'true',
						'tabindex': '-1'
					}).find('a, input, button, select').attr({
						'tabindex': '-1'
					});

					if (_.$dots !== null) {
						_.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
							var slideControlIndex = tabControlIndexes.indexOf(i);

							$(this).attr({
								'role': 'tabpanel',
								'id': 'slick-slide' + _.instanceUid + i,
								'tabindex': -1
							});

							if (slideControlIndex !== -1) {
								var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
								if ($('#' + ariaButtonControl).length) {
									$(this).attr({
										'aria-describedby': ariaButtonControl
									});
								}
							}
						});

						_.$dots.attr('role', 'tablist').find('li').each(function (i) {
							var mappedSlideIndex = tabControlIndexes[i];

							$(this).attr({
								'role': 'presentation'
							});

							$(this).find('button').first().attr({
								'role': 'tab',
								'id': 'slick-slide-control' + _.instanceUid + i,
								'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
								'aria-label': (i + 1) + ' of ' + numDotGroups,
								'aria-selected': null,
								'tabindex': '-1'
							});

						}).eq(_.currentSlide).find('button').attr({
							'aria-selected': 'true',
							'tabindex': '0'
						}).end();
					}

					for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++) {
						if (_.options.focusOnChange) {
							_.$slides.eq(i).attr({ 'tabindex': '0' });
						} else {
							_.$slides.eq(i).removeAttr('tabindex');
						}
					}

					_.activateADA();

				};

				Slick.prototype.initArrowEvents = function () {

					var _ = this;

					if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
						_.$prevArrow
							.off('click.slick')
							.on('click.slick', {
								message: 'previous'
							}, _.changeSlide);
						_.$nextArrow
							.off('click.slick')
							.on('click.slick', {
								message: 'next'
							}, _.changeSlide);

						if (_.options.accessibility === true) {
							_.$prevArrow.on('keydown.slick', _.keyHandler);
							_.$nextArrow.on('keydown.slick', _.keyHandler);
						}
					}

				};

				Slick.prototype.initDotEvents = function () {

					var _ = this;

					if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
						$('li', _.$dots).on('click.slick', {
							message: 'index'
						}, _.changeSlide);

						if (_.options.accessibility === true) {
							_.$dots.on('keydown.slick', _.keyHandler);
						}
					}

					if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

						$('li', _.$dots)
							.on('mouseenter.slick', $.proxy(_.interrupt, _, true))
							.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

					}

				};

				Slick.prototype.initSlideEvents = function () {

					var _ = this;

					if (_.options.pauseOnHover) {

						_.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
						_.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

					}

				};

				Slick.prototype.initializeEvents = function () {

					var _ = this;

					_.initArrowEvents();

					_.initDotEvents();
					_.initSlideEvents();

					_.$list.on('touchstart.slick mousedown.slick', {
						action: 'start'
					}, _.swipeHandler);
					_.$list.on('touchmove.slick mousemove.slick', {
						action: 'move'
					}, _.swipeHandler);
					_.$list.on('touchend.slick mouseup.slick', {
						action: 'end'
					}, _.swipeHandler);
					_.$list.on('touchcancel.slick mouseleave.slick', {
						action: 'end'
					}, _.swipeHandler);

					_.$list.on('click.slick', _.clickHandler);

					$(document).on(_.visibilityChange, $.proxy(_.visibility, _));

					if (_.options.accessibility === true) {
						_.$list.on('keydown.slick', _.keyHandler);
					}

					if (_.options.focusOnSelect === true) {
						$(_.$slideTrack).children().on('click.slick', _.selectHandler);
					}

					$(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

					$(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

					$('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

					$(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
					$(_.setPosition);

				};

				Slick.prototype.initUI = function () {

					var _ = this;

					if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

						_.$prevArrow.show();
						_.$nextArrow.show();

					}

					if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

						_.$dots.show();

					}

				};

				Slick.prototype.keyHandler = function (event) {

					var _ = this;
					//Dont slide if the cursor is inside the form fields and arrow keys are pressed
					if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
						if (event.keyCode === 37 && _.options.accessibility === true) {
							_.changeSlide({
								data: {
									message: _.options.rtl === true ? 'next' : 'previous'
								}
							});
						} else if (event.keyCode === 39 && _.options.accessibility === true) {
							_.changeSlide({
								data: {
									message: _.options.rtl === true ? 'previous' : 'next'
								}
							});
						}
					}

				};

				Slick.prototype.lazyLoad = function () {

					var _ = this,
						loadRange, cloneRange, rangeStart, rangeEnd;

					function loadImages(imagesScope) {

						$('img[data-lazy]', imagesScope).each(function () {

							var image = $(this),
								imageSource = $(this).attr('data-lazy'),
								imageSrcSet = $(this).attr('data-srcset'),
								imageSizes = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
								imageToLoad = document.createElement('img');

							imageToLoad.onload = function () {

								image
									.animate({ opacity: 0 }, 100, function () {

										if (imageSrcSet) {
											image
												.attr('srcset', imageSrcSet);

											if (imageSizes) {
												image
													.attr('sizes', imageSizes);
											}
										}

										image
											.attr('src', imageSource)
											.animate({ opacity: 1 }, 200, function () {
												image
													.removeAttr('data-lazy data-srcset data-sizes')
													.removeClass('slick-loading');
											});
										_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
									});

							};

							imageToLoad.onerror = function () {

								image
									.removeAttr('data-lazy')
									.removeClass('slick-loading')
									.addClass('slick-lazyload-error');

								_.$slider.trigger('lazyLoadError', [_, image, imageSource]);

							};

							imageToLoad.src = imageSource;

						});

					}

					if (_.options.centerMode === true) {
						if (_.options.infinite === true) {
							rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
							rangeEnd = rangeStart + _.options.slidesToShow + 2;
						} else {
							rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
							rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
						}
					} else {
						rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
						rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
						if (_.options.fade === true) {
							if (rangeStart > 0) rangeStart--;
							if (rangeEnd <= _.slideCount) rangeEnd++;
						}
					}

					loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

					if (_.options.lazyLoad === 'anticipated') {
						var prevSlide = rangeStart - 1,
							nextSlide = rangeEnd,
							$slides = _.$slider.find('.slick-slide');

						for (var i = 0; i < _.options.slidesToScroll; i++) {
							if (prevSlide < 0) prevSlide = _.slideCount - 1;
							loadRange = loadRange.add($slides.eq(prevSlide));
							loadRange = loadRange.add($slides.eq(nextSlide));
							prevSlide--;
							nextSlide++;
						}
					}

					loadImages(loadRange);

					if (_.slideCount <= _.options.slidesToShow) {
						cloneRange = _.$slider.find('.slick-slide');
						loadImages(cloneRange);
					} else
						if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
							cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
							loadImages(cloneRange);
						} else if (_.currentSlide === 0) {
							cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
							loadImages(cloneRange);
						}

				};

				Slick.prototype.loadSlider = function () {

					var _ = this;

					_.setPosition();

					_.$slideTrack.css({
						opacity: 1
					});

					_.$slider.removeClass('slick-loading');

					_.initUI();

					if (_.options.lazyLoad === 'progressive') {
						_.progressiveLazyLoad();
					}

				};

				Slick.prototype.next = Slick.prototype.slickNext = function () {

					var _ = this;

					_.changeSlide({
						data: {
							message: 'next'
						}
					});

				};

				Slick.prototype.orientationChange = function () {

					var _ = this;

					_.checkResponsive();
					_.setPosition();

				};

				Slick.prototype.pause = Slick.prototype.slickPause = function () {

					var _ = this;

					_.autoPlayClear();
					_.paused = true;

				};

				Slick.prototype.play = Slick.prototype.slickPlay = function () {

					var _ = this;

					_.autoPlay();
					_.options.autoplay = true;
					_.paused = false;
					_.focussed = false;
					_.interrupted = false;

				};

				Slick.prototype.postSlide = function (index) {

					var _ = this;

					if (!_.unslicked) {

						_.$slider.trigger('afterChange', [_, index]);

						_.animating = false;

						if (_.slideCount > _.options.slidesToShow) {
							_.setPosition();
						}

						_.swipeLeft = null;

						if (_.options.autoplay) {
							_.autoPlay();
						}

						if (_.options.accessibility === true) {
							_.initADA();

							if (_.options.focusOnChange) {
								var $currentSlide = $(_.$slides.get(_.currentSlide));
								$currentSlide.attr('tabindex', 0).focus();
							}
						}

					}

				};

				Slick.prototype.prev = Slick.prototype.slickPrev = function () {

					var _ = this;

					_.changeSlide({
						data: {
							message: 'previous'
						}
					});

				};

				Slick.prototype.preventDefault = function (event) {

					event.preventDefault();

				};

				Slick.prototype.progressiveLazyLoad = function (tryCount) {

					tryCount = tryCount || 1;

					var _ = this,
						$imgsToLoad = $('img[data-lazy]', _.$slider),
						image,
						imageSource,
						imageSrcSet,
						imageSizes,
						imageToLoad;

					if ($imgsToLoad.length) {

						image = $imgsToLoad.first();
						imageSource = image.attr('data-lazy');
						imageSrcSet = image.attr('data-srcset');
						imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');
						imageToLoad = document.createElement('img');

						imageToLoad.onload = function () {

							if (imageSrcSet) {
								image
									.attr('srcset', imageSrcSet);

								if (imageSizes) {
									image
										.attr('sizes', imageSizes);
								}
							}

							image
								.attr('src', imageSource)
								.removeAttr('data-lazy data-srcset data-sizes')
								.removeClass('slick-loading');

							if (_.options.adaptiveHeight === true) {
								_.setPosition();
							}

							_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
							_.progressiveLazyLoad();

						};

						imageToLoad.onerror = function () {

							if (tryCount < 3) {

								/**
								 * try to load the image 3 times,
								 * leave a slight delay so we don't get
								 * servers blocking the request.
								 */
								setTimeout(function () {
									_.progressiveLazyLoad(tryCount + 1);
								}, 500);

							} else {

								image
									.removeAttr('data-lazy')
									.removeClass('slick-loading')
									.addClass('slick-lazyload-error');

								_.$slider.trigger('lazyLoadError', [_, image, imageSource]);

								_.progressiveLazyLoad();

							}

						};

						imageToLoad.src = imageSource;

					} else {

						_.$slider.trigger('allImagesLoaded', [_]);

					}

				};

				Slick.prototype.refresh = function (initializing) {

					var _ = this, currentSlide, lastVisibleIndex;

					lastVisibleIndex = _.slideCount - _.options.slidesToShow;

					// in non-infinite sliders, we don't want to go past the
					// last visible index.
					if (!_.options.infinite && (_.currentSlide > lastVisibleIndex)) {
						_.currentSlide = lastVisibleIndex;
					}

					// if less slides than to show, go to start.
					if (_.slideCount <= _.options.slidesToShow) {
						_.currentSlide = 0;

					}

					currentSlide = _.currentSlide;

					_.destroy(true);

					$.extend(_, _.initials, { currentSlide: currentSlide });

					_.init();

					if (!initializing) {

						_.changeSlide({
							data: {
								message: 'index',
								index: currentSlide
							}
						}, false);

					}

				};

				Slick.prototype.registerBreakpoints = function () {

					var _ = this, breakpoint, currentBreakpoint, l,
						responsiveSettings = _.options.responsive || null;

					if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

						_.respondTo = _.options.respondTo || 'window';

						for (breakpoint in responsiveSettings) {

							l = _.breakpoints.length - 1;

							if (responsiveSettings.hasOwnProperty(breakpoint)) {
								currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

								// loop through the breakpoints and cut out any existing
								// ones with the same breakpoint number, we don't want dupes.
								while (l >= 0) {
									if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
										_.breakpoints.splice(l, 1);
									}
									l--;
								}

								_.breakpoints.push(currentBreakpoint);
								_.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

							}

						}

						_.breakpoints.sort(function (a, b) {
							return (_.options.mobileFirst) ? a - b : b - a;
						});

					}

				};

				Slick.prototype.reinit = function () {

					var _ = this;

					_.$slides =
						_.$slideTrack
							.children(_.options.slide)
							.addClass('slick-slide');

					_.slideCount = _.$slides.length;

					if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
						_.currentSlide = _.currentSlide - _.options.slidesToScroll;
					}

					if (_.slideCount <= _.options.slidesToShow) {
						_.currentSlide = 0;
					}

					_.registerBreakpoints();

					_.setProps();
					_.setupInfinite();
					_.buildArrows();
					_.updateArrows();
					_.initArrowEvents();
					_.buildDots();
					_.updateDots();
					_.initDotEvents();
					_.cleanUpSlideEvents();
					_.initSlideEvents();

					_.checkResponsive(false, true);

					if (_.options.focusOnSelect === true) {
						$(_.$slideTrack).children().on('click.slick', _.selectHandler);
					}

					_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

					_.setPosition();
					_.focusHandler();

					_.paused = !_.options.autoplay;
					_.autoPlay();

					_.$slider.trigger('reInit', [_]);

				};

				Slick.prototype.resize = function () {

					var _ = this;

					if ($(window).width() !== _.windowWidth) {
						clearTimeout(_.windowDelay);
						_.windowDelay = window.setTimeout(function () {
							_.windowWidth = $(window).width();
							_.checkResponsive();
							if (!_.unslicked) { _.setPosition(); }
						}, 50);
					}
				};

				Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {

					var _ = this;

					if (typeof (index) === 'boolean') {
						removeBefore = index;
						index = removeBefore === true ? 0 : _.slideCount - 1;
					} else {
						index = removeBefore === true ? --index : index;
					}

					if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
						return false;
					}

					_.unload();

					if (removeAll === true) {
						_.$slideTrack.children().remove();
					} else {
						_.$slideTrack.children(this.options.slide).eq(index).remove();
					}

					_.$slides = _.$slideTrack.children(this.options.slide);

					_.$slideTrack.children(this.options.slide).detach();

					_.$slideTrack.append(_.$slides);

					_.$slidesCache = _.$slides;

					_.reinit();

				};

				Slick.prototype.setCSS = function (position) {

					var _ = this,
						positionProps = {},
						x, y;

					if (_.options.rtl === true) {
						position = -position;
					}
					x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
					y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

					positionProps[_.positionProp] = position;

					if (_.transformsEnabled === false) {
						_.$slideTrack.css(positionProps);
					} else {
						positionProps = {};
						if (_.cssTransitions === false) {
							positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
							_.$slideTrack.css(positionProps);
						} else {
							positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
							_.$slideTrack.css(positionProps);
						}
					}

				};

				Slick.prototype.setDimensions = function () {

					var _ = this;

					if (_.options.vertical === false) {
						if (_.options.centerMode === true) {
							_.$list.css({
								padding: ('0px ' + _.options.centerPadding)
							});
						}
					} else {
						_.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
						if (_.options.centerMode === true) {
							_.$list.css({
								padding: (_.options.centerPadding + ' 0px')
							});
						}
					}

					_.listWidth = _.$list.width();
					_.listHeight = _.$list.height();


					if (_.options.vertical === false && _.options.variableWidth === false) {
						_.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
						_.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

					} else if (_.options.variableWidth === true) {
						_.$slideTrack.width(5000 * _.slideCount);
					} else {
						_.slideWidth = Math.ceil(_.listWidth);
						_.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
					}

					var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
					if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

				};

				Slick.prototype.setFade = function () {

					var _ = this,
						targetLeft;

					_.$slides.each(function (index, element) {
						targetLeft = (_.slideWidth * index) * -1;
						if (_.options.rtl === true) {
							$(element).css({
								position: 'relative',
								right: targetLeft,
								top: 0,
								zIndex: _.options.zIndex - 2,
								opacity: 0
							});
						} else {
							$(element).css({
								position: 'relative',
								left: targetLeft,
								top: 0,
								zIndex: _.options.zIndex - 2,
								opacity: 0
							});
						}
					});

					_.$slides.eq(_.currentSlide).css({
						zIndex: _.options.zIndex - 1,
						opacity: 1
					});

				};

				Slick.prototype.setHeight = function () {

					var _ = this;

					if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
						var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
						_.$list.css('height', targetHeight);
					}

				};

				Slick.prototype.setOption =
					Slick.prototype.slickSetOption = function () {

						/**
						 * accepts arguments in format of:
						 *
						 *  - for changing a single option's value:
						 *     .slick("setOption", option, value, refresh )
						 *
						 *  - for changing a set of responsive options:
						 *     .slick("setOption", 'responsive', [{}, ...], refresh )
						 *
						 *  - for updating multiple values at once (not responsive)
						 *     .slick("setOption", { 'option': value, ... }, refresh )
						 */

						var _ = this, l, item, option, value, refresh = false, type;

						if ($.type(arguments[0]) === 'object') {

							option = arguments[0];
							refresh = arguments[1];
							type = 'multiple';

						} else if ($.type(arguments[0]) === 'string') {

							option = arguments[0];
							value = arguments[1];
							refresh = arguments[2];

							if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {

								type = 'responsive';

							} else if (typeof arguments[1] !== 'undefined') {

								type = 'single';

							}

						}

						if (type === 'single') {

							_.options[option] = value;


						} else if (type === 'multiple') {

							$.each(option, function (opt, val) {

								_.options[opt] = val;

							});


						} else if (type === 'responsive') {

							for (item in value) {

								if ($.type(_.options.responsive) !== 'array') {

									_.options.responsive = [value[item]];

								} else {

									l = _.options.responsive.length - 1;

									// loop through the responsive object and splice out duplicates.
									while (l >= 0) {

										if (_.options.responsive[l].breakpoint === value[item].breakpoint) {

											_.options.responsive.splice(l, 1);

										}

										l--;

									}

									_.options.responsive.push(value[item]);

								}

							}

						}

						if (refresh) {

							_.unload();
							_.reinit();

						}

					};

				Slick.prototype.setPosition = function () {

					var _ = this;

					_.setDimensions();

					_.setHeight();

					if (_.options.fade === false) {
						_.setCSS(_.getLeft(_.currentSlide));
					} else {
						_.setFade();
					}

					_.$slider.trigger('setPosition', [_]);

				};

				Slick.prototype.setProps = function () {

					var _ = this,
						bodyStyle = document.body.style;

					_.positionProp = _.options.vertical === true ? 'top' : 'left';

					if (_.positionProp === 'top') {
						_.$slider.addClass('slick-vertical');
					} else {
						_.$slider.removeClass('slick-vertical');
					}

					if (bodyStyle.WebkitTransition !== undefined ||
						bodyStyle.MozTransition !== undefined ||
						bodyStyle.msTransition !== undefined) {
						if (_.options.useCSS === true) {
							_.cssTransitions = true;
						}
					}

					if (_.options.fade) {
						if (typeof _.options.zIndex === 'number') {
							if (_.options.zIndex < 3) {
								_.options.zIndex = 3;
							}
						} else {
							_.options.zIndex = _.defaults.zIndex;
						}
					}

					if (bodyStyle.OTransform !== undefined) {
						_.animType = 'OTransform';
						_.transformType = '-o-transform';
						_.transitionType = 'OTransition';
						if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
					}
					if (bodyStyle.MozTransform !== undefined) {
						_.animType = 'MozTransform';
						_.transformType = '-moz-transform';
						_.transitionType = 'MozTransition';
						if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
					}
					if (bodyStyle.webkitTransform !== undefined) {
						_.animType = 'webkitTransform';
						_.transformType = '-webkit-transform';
						_.transitionType = 'webkitTransition';
						if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
					}
					if (bodyStyle.msTransform !== undefined) {
						_.animType = 'msTransform';
						_.transformType = '-ms-transform';
						_.transitionType = 'msTransition';
						if (bodyStyle.msTransform === undefined) _.animType = false;
					}
					if (bodyStyle.transform !== undefined && _.animType !== false) {
						_.animType = 'transform';
						_.transformType = 'transform';
						_.transitionType = 'transition';
					}
					_.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
				};


				Slick.prototype.setSlideClasses = function (index) {

					var _ = this,
						centerOffset, allSlides, indexOffset, remainder;

					allSlides = _.$slider
						.find('.slick-slide')
						.removeClass('slick-active slick-center slick-current')
						.attr('aria-hidden', 'true');

					_.$slides
						.eq(index)
						.addClass('slick-current');

					if (_.options.centerMode === true) {

						var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

						centerOffset = Math.floor(_.options.slidesToShow / 2);

						if (_.options.infinite === true) {

							if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
								_.$slides
									.slice(index - centerOffset + evenCoef, index + centerOffset + 1)
									.addClass('slick-active')
									.attr('aria-hidden', 'false');

							} else {

								indexOffset = _.options.slidesToShow + index;
								allSlides
									.slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
									.addClass('slick-active')
									.attr('aria-hidden', 'false');

							}

							if (index === 0) {

								allSlides
									.eq(allSlides.length - 1 - _.options.slidesToShow)
									.addClass('slick-center');

							} else if (index === _.slideCount - 1) {

								allSlides
									.eq(_.options.slidesToShow)
									.addClass('slick-center');

							}

						}

						_.$slides
							.eq(index)
							.addClass('slick-center');

					} else {

						if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

							_.$slides
								.slice(index, index + _.options.slidesToShow)
								.addClass('slick-active')
								.attr('aria-hidden', 'false');

						} else if (allSlides.length <= _.options.slidesToShow) {

							allSlides
								.addClass('slick-active')
								.attr('aria-hidden', 'false');

						} else {

							remainder = _.slideCount % _.options.slidesToShow;
							indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

							if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

								allSlides
									.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
									.addClass('slick-active')
									.attr('aria-hidden', 'false');

							} else {

								allSlides
									.slice(indexOffset, indexOffset + _.options.slidesToShow)
									.addClass('slick-active')
									.attr('aria-hidden', 'false');

							}

						}

					}

					if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
						_.lazyLoad();
					}
				};

				Slick.prototype.setupInfinite = function () {

					var _ = this,
						i, slideIndex, infiniteCount;

					if (_.options.fade === true) {
						_.options.centerMode = false;
					}

					if (_.options.infinite === true && _.options.fade === false) {

						slideIndex = null;

						if (_.slideCount > _.options.slidesToShow) {

							if (_.options.centerMode === true) {
								infiniteCount = _.options.slidesToShow + 1;
							} else {
								infiniteCount = _.options.slidesToShow;
							}

							for (i = _.slideCount; i > (_.slideCount -
								infiniteCount); i -= 1) {
								slideIndex = i - 1;
								$(_.$slides[slideIndex]).clone(true).attr('id', '')
									.attr('data-slick-index', slideIndex - _.slideCount)
									.prependTo(_.$slideTrack).addClass('slick-cloned');
							}
							for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
								slideIndex = i;
								$(_.$slides[slideIndex]).clone(true).attr('id', '')
									.attr('data-slick-index', slideIndex + _.slideCount)
									.appendTo(_.$slideTrack).addClass('slick-cloned');
							}
							_.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
								$(this).attr('id', '');
							});

						}

					}

				};

				Slick.prototype.interrupt = function (toggle) {

					var _ = this;

					if (!toggle) {
						_.autoPlay();
					}
					_.interrupted = toggle;

				};

				Slick.prototype.selectHandler = function (event) {

					var _ = this;

					var targetElement =
						$(event.target).is('.slick-slide') ?
							$(event.target) :
							$(event.target).parents('.slick-slide');

					var index = parseInt(targetElement.attr('data-slick-index'));

					if (!index) index = 0;

					if (_.slideCount <= _.options.slidesToShow) {

						_.slideHandler(index, false, true);
						return;

					}

					_.slideHandler(index);

				};

				Slick.prototype.slideHandler = function (index, sync, dontAnimate) {

					var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
						_ = this, navTarget;

					sync = sync || false;

					if (_.animating === true && _.options.waitForAnimate === true) {
						return;
					}

					if (_.options.fade === true && _.currentSlide === index) {
						return;
					}

					if (sync === false) {
						_.asNavFor(index);
					}

					targetSlide = index;
					targetLeft = _.getLeft(targetSlide);
					slideLeft = _.getLeft(_.currentSlide);

					_.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

					if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
						if (_.options.fade === false) {
							targetSlide = _.currentSlide;
							if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
								_.animateSlide(slideLeft, function () {
									_.postSlide(targetSlide);
								});
							} else {
								_.postSlide(targetSlide);
							}
						}
						return;
					} else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
						if (_.options.fade === false) {
							targetSlide = _.currentSlide;
							if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
								_.animateSlide(slideLeft, function () {
									_.postSlide(targetSlide);
								});
							} else {
								_.postSlide(targetSlide);
							}
						}
						return;
					}

					if (_.options.autoplay) {
						clearInterval(_.autoPlayTimer);
					}

					if (targetSlide < 0) {
						if (_.slideCount % _.options.slidesToScroll !== 0) {
							animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
						} else {
							animSlide = _.slideCount + targetSlide;
						}
					} else if (targetSlide >= _.slideCount) {
						if (_.slideCount % _.options.slidesToScroll !== 0) {
							animSlide = 0;
						} else {
							animSlide = targetSlide - _.slideCount;
						}
					} else {
						animSlide = targetSlide;
					}

					_.animating = true;

					_.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

					oldSlide = _.currentSlide;
					_.currentSlide = animSlide;

					_.setSlideClasses(_.currentSlide);

					if (_.options.asNavFor) {

						navTarget = _.getNavTarget();
						navTarget = navTarget.slick('getSlick');

						if (navTarget.slideCount <= navTarget.options.slidesToShow) {
							navTarget.setSlideClasses(_.currentSlide);
						}

					}

					_.updateDots();
					_.updateArrows();

					if (_.options.fade === true) {
						if (dontAnimate !== true) {

							_.fadeSlideOut(oldSlide);

							_.fadeSlide(animSlide, function () {
								_.postSlide(animSlide);
							});

						} else {
							_.postSlide(animSlide);
						}
						_.animateHeight();
						return;
					}

					if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
						_.animateSlide(targetLeft, function () {
							_.postSlide(animSlide);
						});
					} else {
						_.postSlide(animSlide);
					}

				};

				Slick.prototype.startLoad = function () {

					var _ = this;

					if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

						_.$prevArrow.hide();
						_.$nextArrow.hide();

					}

					if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

						_.$dots.hide();

					}

					_.$slider.addClass('slick-loading');

				};

				Slick.prototype.swipeDirection = function () {

					var xDist, yDist, r, swipeAngle, _ = this;

					xDist = _.touchObject.startX - _.touchObject.curX;
					yDist = _.touchObject.startY - _.touchObject.curY;
					r = Math.atan2(yDist, xDist);

					swipeAngle = Math.round(r * 180 / Math.PI);
					if (swipeAngle < 0) {
						swipeAngle = 360 - Math.abs(swipeAngle);
					}

					if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
						return (_.options.rtl === false ? 'left' : 'right');
					}
					if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
						return (_.options.rtl === false ? 'left' : 'right');
					}
					if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
						return (_.options.rtl === false ? 'right' : 'left');
					}
					if (_.options.verticalSwiping === true) {
						if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
							return 'down';
						} else {
							return 'up';
						}
					}

					return 'vertical';

				};

				Slick.prototype.swipeEnd = function (event) {

					var _ = this,
						slideCount,
						direction;

					_.dragging = false;
					_.swiping = false;

					if (_.scrolling) {
						_.scrolling = false;
						return false;
					}

					_.interrupted = false;
					_.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

					if (_.touchObject.curX === undefined) {
						return false;
					}

					if (_.touchObject.edgeHit === true) {
						_.$slider.trigger('edge', [_, _.swipeDirection()]);
					}

					if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

						direction = _.swipeDirection();

						switch (direction) {

							case 'left':
							case 'down':

								slideCount =
									_.options.swipeToSlide ?
										_.checkNavigable(_.currentSlide + _.getSlideCount()) :
										_.currentSlide + _.getSlideCount();

								_.currentDirection = 0;

								break;

							case 'right':
							case 'up':

								slideCount =
									_.options.swipeToSlide ?
										_.checkNavigable(_.currentSlide - _.getSlideCount()) :
										_.currentSlide - _.getSlideCount();

								_.currentDirection = 1;

								break;

							default:


						}

						if (direction != 'vertical') {

							_.slideHandler(slideCount);
							_.touchObject = {};
							_.$slider.trigger('swipe', [_, direction]);

						}

					} else {

						if (_.touchObject.startX !== _.touchObject.curX) {

							_.slideHandler(_.currentSlide);
							_.touchObject = {};

						}

					}

				};

				Slick.prototype.swipeHandler = function (event) {

					var _ = this;

					if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
						return;
					} else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
						return;
					}

					_.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
						event.originalEvent.touches.length : 1;

					_.touchObject.minSwipe = _.listWidth / _.options
						.touchThreshold;

					if (_.options.verticalSwiping === true) {
						_.touchObject.minSwipe = _.listHeight / _.options
							.touchThreshold;
					}

					switch (event.data.action) {

						case 'start':
							_.swipeStart(event);
							break;

						case 'move':
							_.swipeMove(event);
							break;

						case 'end':
							_.swipeEnd(event);
							break;

					}

				};

				Slick.prototype.swipeMove = function (event) {

					var _ = this,
						edgeWasHit = false,
						curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

					touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

					if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
						return false;
					}

					curLeft = _.getLeft(_.currentSlide);

					_.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
					_.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

					_.touchObject.swipeLength = Math.round(Math.sqrt(
						Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

					verticalSwipeLength = Math.round(Math.sqrt(
						Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

					if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
						_.scrolling = true;
						return false;
					}

					if (_.options.verticalSwiping === true) {
						_.touchObject.swipeLength = verticalSwipeLength;
					}

					swipeDirection = _.swipeDirection();

					if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
						_.swiping = true;
						event.preventDefault();
					}

					positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
					if (_.options.verticalSwiping === true) {
						positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
					}


					swipeLength = _.touchObject.swipeLength;

					_.touchObject.edgeHit = false;

					if (_.options.infinite === false) {
						if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
							swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
							_.touchObject.edgeHit = true;
						}
					}

					if (_.options.vertical === false) {
						_.swipeLeft = curLeft + swipeLength * positionOffset;
					} else {
						_.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
					}
					if (_.options.verticalSwiping === true) {
						_.swipeLeft = curLeft + swipeLength * positionOffset;
					}

					if (_.options.fade === true || _.options.touchMove === false) {
						return false;
					}

					if (_.animating === true) {
						_.swipeLeft = null;
						return false;
					}

					_.setCSS(_.swipeLeft);

				};

				Slick.prototype.swipeStart = function (event) {

					var _ = this,
						touches;

					_.interrupted = true;

					if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
						_.touchObject = {};
						return false;
					}

					if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
						touches = event.originalEvent.touches[0];
					}

					_.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
					_.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

					_.dragging = true;

				};

				Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {

					var _ = this;

					if (_.$slidesCache !== null) {

						_.unload();

						_.$slideTrack.children(this.options.slide).detach();

						_.$slidesCache.appendTo(_.$slideTrack);

						_.reinit();

					}

				};

				Slick.prototype.unload = function () {

					var _ = this;

					$('.slick-cloned', _.$slider).remove();

					if (_.$dots) {
						_.$dots.remove();
					}

					if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
						_.$prevArrow.remove();
					}

					if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
						_.$nextArrow.remove();
					}

					_.$slides
						.removeClass('slick-slide slick-active slick-visible slick-current')
						.attr('aria-hidden', 'true')
						.css('width', '');

				};

				Slick.prototype.unslick = function (fromBreakpoint) {

					var _ = this;
					_.$slider.trigger('unslick', [_, fromBreakpoint]);
					_.destroy();

				};

				Slick.prototype.updateArrows = function () {

					var _ = this,
						centerOffset;

					centerOffset = Math.floor(_.options.slidesToShow / 2);

					if (_.options.arrows === true &&
						_.slideCount > _.options.slidesToShow &&
						!_.options.infinite) {

						_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
						_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

						if (_.currentSlide === 0) {

							_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
							_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

						} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

							_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
							_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

						} else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

							_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
							_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

						}

					}

				};

				Slick.prototype.updateDots = function () {

					var _ = this;

					if (_.$dots !== null) {

						_.$dots
							.find('li')
							.removeClass('slick-active')
							.end();

						_.$dots
							.find('li')
							.eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
							.addClass('slick-active');

					}

				};

				Slick.prototype.visibility = function () {

					var _ = this;

					if (_.options.autoplay) {

						if (document[_.hidden]) {

							_.interrupted = true;

						} else {

							_.interrupted = false;

						}

					}

				};

				$.fn.slick = function () {
					var _ = this,
						opt = arguments[0],
						args = Array.prototype.slice.call(arguments, 1),
						l = _.length,
						i,
						ret;
					for (i = 0; i < l; i++) {
						if (typeof opt == 'object' || typeof opt == 'undefined')
							_[i].slick = new Slick(_[i], opt);
						else
							ret = _[i].slick[opt].apply(_[i].slick, args);
						if (typeof ret != 'undefined') return ret;
					}
					return _;
				};

			}));


			/***/
		}),

/***/ "./node_modules/typed.js/lib/typed.js":
/*!********************************************!*\
  !*** ./node_modules/typed.js/lib/typed.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			/*!
			 * 
			 *   typed.js - A JavaScript Typing Animation Library
			 *   Author: Matt Boldt <me@mattboldt.com>
			 *   Version: v2.0.11
			 *   Url: https://github.com/mattboldt/typed.js
			 *   License(s): MIT
			 * 
			 */
			(function webpackUniversalModuleDefinition(root, factory) {
				if (true)
					module.exports = factory();
				else { }
			})(this, function () {
				return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
							/******/
						};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
						/******/
					}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
					/******/
				})
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, exports, __webpack_require__) {

						'use strict';

						Object.defineProperty(exports, '__esModule', {
							value: true
						});

						var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						var _initializerJs = __webpack_require__(1);

						var _htmlParserJs = __webpack_require__(3);

						/**
						 * Welcome to Typed.js!
						 * @param {string} elementId HTML element ID _OR_ HTML element
						 * @param {object} options options object
						 * @returns {object} a new Typed object
						 */

						var Typed = (function () {
							function Typed(elementId, options) {
								_classCallCheck(this, Typed);

								// Initialize it up
								_initializerJs.initializer.load(this, options, elementId);
								// All systems go!
								this.begin();
							}

							/**
							 * Toggle start() and stop() of the Typed instance
							 * @public
							 */

							_createClass(Typed, [{
								key: 'toggle',
								value: function toggle() {
									this.pause.status ? this.start() : this.stop();
								}

								/**
								 * Stop typing / backspacing and enable cursor blinking
								 * @public
								 */
							}, {
								key: 'stop',
								value: function stop() {
									if (this.typingComplete) return;
									if (this.pause.status) return;
									this.toggleBlinking(true);
									this.pause.status = true;
									this.options.onStop(this.arrayPos, this);
								}

								/**
								 * Start typing / backspacing after being stopped
								 * @public
								 */
							}, {
								key: 'start',
								value: function start() {
									if (this.typingComplete) return;
									if (!this.pause.status) return;
									this.pause.status = false;
									if (this.pause.typewrite) {
										this.typewrite(this.pause.curString, this.pause.curStrPos);
									} else {
										this.backspace(this.pause.curString, this.pause.curStrPos);
									}
									this.options.onStart(this.arrayPos, this);
								}

								/**
								 * Destroy this instance of Typed
								 * @public
								 */
							}, {
								key: 'destroy',
								value: function destroy() {
									this.reset(false);
									this.options.onDestroy(this);
								}

								/**
								 * Reset Typed and optionally restarts
								 * @param {boolean} restart
								 * @public
								 */
							}, {
								key: 'reset',
								value: function reset() {
									var restart = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

									clearInterval(this.timeout);
									this.replaceText('');
									if (this.cursor && this.cursor.parentNode) {
										this.cursor.parentNode.removeChild(this.cursor);
										this.cursor = null;
									}
									this.strPos = 0;
									this.arrayPos = 0;
									this.curLoop = 0;
									if (restart) {
										this.insertCursor();
										this.options.onReset(this);
										this.begin();
									}
								}

								/**
								 * Begins the typing animation
								 * @private
								 */
							}, {
								key: 'begin',
								value: function begin() {
									var _this = this;

									this.options.onBegin(this);
									this.typingComplete = false;
									this.shuffleStringsIfNeeded(this);
									this.insertCursor();
									if (this.bindInputFocusEvents) this.bindFocusEvents();
									this.timeout = setTimeout(function () {
										// Check if there is some text in the element, if yes start by backspacing the default message
										if (!_this.currentElContent || _this.currentElContent.length === 0) {
											_this.typewrite(_this.strings[_this.sequence[_this.arrayPos]], _this.strPos);
										} else {
											// Start typing
											_this.backspace(_this.currentElContent, _this.currentElContent.length);
										}
									}, this.startDelay);
								}

								/**
								 * Called for each character typed
								 * @param {string} curString the current string in the strings array
								 * @param {number} curStrPos the current position in the curString
								 * @private
								 */
							}, {
								key: 'typewrite',
								value: function typewrite(curString, curStrPos) {
									var _this2 = this;

									if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {
										this.el.classList.remove(this.fadeOutClass);
										if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);
									}

									var humanize = this.humanizer(this.typeSpeed);
									var numChars = 1;

									if (this.pause.status === true) {
										this.setPauseStatus(curString, curStrPos, true);
										return;
									}

									// contain typing function in a timeout humanize'd delay
									this.timeout = setTimeout(function () {
										// skip over any HTML chars
										curStrPos = _htmlParserJs.htmlParser.typeHtmlChars(curString, curStrPos, _this2);

										var pauseTime = 0;
										var substr = curString.substr(curStrPos);
										// check for an escape character before a pause value
										// format: \^\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^
										// single ^ are removed from string
										if (substr.charAt(0) === '^') {
											if (/^\^\d+/.test(substr)) {
												var skip = 1; // skip at least 1
												substr = /\d+/.exec(substr)[0];
												skip += substr.length;
												pauseTime = parseInt(substr);
												_this2.temporaryPause = true;
												_this2.options.onTypingPaused(_this2.arrayPos, _this2);
												// strip out the escape character and pause value so they're not printed
												curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);
												_this2.toggleBlinking(true);
											}
										}

										// check for skip characters formatted as
										// "this is a `string to print NOW` ..."
										if (substr.charAt(0) === '`') {
											while (curString.substr(curStrPos + numChars).charAt(0) !== '`') {
												numChars++;
												if (curStrPos + numChars > curString.length) break;
											}
											// strip out the escape characters and append all the string in between
											var stringBeforeSkip = curString.substring(0, curStrPos);
											var stringSkipped = curString.substring(stringBeforeSkip.length + 1, curStrPos + numChars);
											var stringAfterSkip = curString.substring(curStrPos + numChars + 1);
											curString = stringBeforeSkip + stringSkipped + stringAfterSkip;
											numChars--;
										}

										// timeout for any pause after a character
										_this2.timeout = setTimeout(function () {
											// Accounts for blinking while paused
											_this2.toggleBlinking(false);

											// We're done with this sentence!
											if (curStrPos >= curString.length) {
												_this2.doneTyping(curString, curStrPos);
											} else {
												_this2.keepTyping(curString, curStrPos, numChars);
											}
											// end of character pause
											if (_this2.temporaryPause) {
												_this2.temporaryPause = false;
												_this2.options.onTypingResumed(_this2.arrayPos, _this2);
											}
										}, pauseTime);

										// humanized value for typing
									}, humanize);
								}

								/**
								 * Continue to the next string & begin typing
								 * @param {string} curString the current string in the strings array
								 * @param {number} curStrPos the current position in the curString
								 * @private
								 */
							}, {
								key: 'keepTyping',
								value: function keepTyping(curString, curStrPos, numChars) {
									// call before functions if applicable
									if (curStrPos === 0) {
										this.toggleBlinking(false);
										this.options.preStringTyped(this.arrayPos, this);
									}
									// start typing each new char into existing string
									// curString: arg, this.el.html: original text inside element
									curStrPos += numChars;
									var nextString = curString.substr(0, curStrPos);
									this.replaceText(nextString);
									// loop the function
									this.typewrite(curString, curStrPos);
								}

								/**
								 * We're done typing the current string
								 * @param {string} curString the current string in the strings array
								 * @param {number} curStrPos the current position in the curString
								 * @private
								 */
							}, {
								key: 'doneTyping',
								value: function doneTyping(curString, curStrPos) {
									var _this3 = this;

									// fires callback function
									this.options.onStringTyped(this.arrayPos, this);
									this.toggleBlinking(true);
									// is this the final string
									if (this.arrayPos === this.strings.length - 1) {
										// callback that occurs on the last typed string
										this.complete();
										// quit if we wont loop back
										if (this.loop === false || this.curLoop === this.loopCount) {
											return;
										}
									}
									this.timeout = setTimeout(function () {
										_this3.backspace(curString, curStrPos);
									}, this.backDelay);
								}

								/**
								 * Backspaces 1 character at a time
								 * @param {string} curString the current string in the strings array
								 * @param {number} curStrPos the current position in the curString
								 * @private
								 */
							}, {
								key: 'backspace',
								value: function backspace(curString, curStrPos) {
									var _this4 = this;

									if (this.pause.status === true) {
										this.setPauseStatus(curString, curStrPos, true);
										return;
									}
									if (this.fadeOut) return this.initFadeOut();

									this.toggleBlinking(false);
									var humanize = this.humanizer(this.backSpeed);

									this.timeout = setTimeout(function () {
										curStrPos = _htmlParserJs.htmlParser.backSpaceHtmlChars(curString, curStrPos, _this4);
										// replace text with base text + typed characters
										var curStringAtPosition = curString.substr(0, curStrPos);
										_this4.replaceText(curStringAtPosition);

										// if smartBack is enabled
										if (_this4.smartBackspace) {
											// the remaining part of the current string is equal of the same part of the new string
											var nextString = _this4.strings[_this4.arrayPos + 1];
											if (nextString && curStringAtPosition === nextString.substr(0, curStrPos)) {
												_this4.stopNum = curStrPos;
											} else {
												_this4.stopNum = 0;
											}
										}

										// if the number (id of character in current string) is
										// less than the stop number, keep going
										if (curStrPos > _this4.stopNum) {
											// subtract characters one by one
											curStrPos--;
											// loop the function
											_this4.backspace(curString, curStrPos);
										} else if (curStrPos <= _this4.stopNum) {
											// if the stop number has been reached, increase
											// array position to next string
											_this4.arrayPos++;
											// When looping, begin at the beginning after backspace complete
											if (_this4.arrayPos === _this4.strings.length) {
												_this4.arrayPos = 0;
												_this4.options.onLastStringBackspaced();
												_this4.shuffleStringsIfNeeded();
												_this4.begin();
											} else {
												_this4.typewrite(_this4.strings[_this4.sequence[_this4.arrayPos]], curStrPos);
											}
										}
										// humanized value for typing
									}, humanize);
								}

								/**
								 * Full animation is complete
								 * @private
								 */
							}, {
								key: 'complete',
								value: function complete() {
									this.options.onComplete(this);
									if (this.loop) {
										this.curLoop++;
									} else {
										this.typingComplete = true;
									}
								}

								/**
								 * Has the typing been stopped
								 * @param {string} curString the current string in the strings array
								 * @param {number} curStrPos the current position in the curString
								 * @param {boolean} isTyping
								 * @private
								 */
							}, {
								key: 'setPauseStatus',
								value: function setPauseStatus(curString, curStrPos, isTyping) {
									this.pause.typewrite = isTyping;
									this.pause.curString = curString;
									this.pause.curStrPos = curStrPos;
								}

								/**
								 * Toggle the blinking cursor
								 * @param {boolean} isBlinking
								 * @private
								 */
							}, {
								key: 'toggleBlinking',
								value: function toggleBlinking(isBlinking) {
									if (!this.cursor) return;
									// if in paused state, don't toggle blinking a 2nd time
									if (this.pause.status) return;
									if (this.cursorBlinking === isBlinking) return;
									this.cursorBlinking = isBlinking;
									if (isBlinking) {
										this.cursor.classList.add('typed-cursor--blink');
									} else {
										this.cursor.classList.remove('typed-cursor--blink');
									}
								}

								/**
								 * Speed in MS to type
								 * @param {number} speed
								 * @private
								 */
							}, {
								key: 'humanizer',
								value: function humanizer(speed) {
									return Math.round(Math.random() * speed / 2) + speed;
								}

								/**
								 * Shuffle the sequence of the strings array
								 * @private
								 */
							}, {
								key: 'shuffleStringsIfNeeded',
								value: function shuffleStringsIfNeeded() {
									if (!this.shuffle) return;
									this.sequence = this.sequence.sort(function () {
										return Math.random() - 0.5;
									});
								}

								/**
								 * Adds a CSS class to fade out current string
								 * @private
								 */
							}, {
								key: 'initFadeOut',
								value: function initFadeOut() {
									var _this5 = this;

									this.el.className += ' ' + this.fadeOutClass;
									if (this.cursor) this.cursor.className += ' ' + this.fadeOutClass;
									return setTimeout(function () {
										_this5.arrayPos++;
										_this5.replaceText('');

										// Resets current string if end of loop reached
										if (_this5.strings.length > _this5.arrayPos) {
											_this5.typewrite(_this5.strings[_this5.sequence[_this5.arrayPos]], 0);
										} else {
											_this5.typewrite(_this5.strings[0], 0);
											_this5.arrayPos = 0;
										}
									}, this.fadeOutDelay);
								}

								/**
								 * Replaces current text in the HTML element
								 * depending on element type
								 * @param {string} str
								 * @private
								 */
							}, {
								key: 'replaceText',
								value: function replaceText(str) {
									if (this.attr) {
										this.el.setAttribute(this.attr, str);
									} else {
										if (this.isInput) {
											this.el.value = str;
										} else if (this.contentType === 'html') {
											this.el.innerHTML = str;
										} else {
											this.el.textContent = str;
										}
									}
								}

								/**
								 * If using input elements, bind focus in order to
								 * start and stop the animation
								 * @private
								 */
							}, {
								key: 'bindFocusEvents',
								value: function bindFocusEvents() {
									var _this6 = this;

									if (!this.isInput) return;
									this.el.addEventListener('focus', function (e) {
										_this6.stop();
									});
									this.el.addEventListener('blur', function (e) {
										if (_this6.el.value && _this6.el.value.length !== 0) {
											return;
										}
										_this6.start();
									});
								}

								/**
								 * On init, insert the cursor element
								 * @private
								 */
							}, {
								key: 'insertCursor',
								value: function insertCursor() {
									if (!this.showCursor) return;
									if (this.cursor) return;
									this.cursor = document.createElement('span');
									this.cursor.className = 'typed-cursor';
									this.cursor.innerHTML = this.cursorChar;
									this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);
								}
							}]);

							return Typed;
						})();

						exports['default'] = Typed;
						module.exports = exports['default'];

						/***/
					}),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

						'use strict';

						Object.defineProperty(exports, '__esModule', {
							value: true
						});

						var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

						var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						var _defaultsJs = __webpack_require__(2);

						var _defaultsJs2 = _interopRequireDefault(_defaultsJs);

						/**
						 * Initialize the Typed object
						 */

						var Initializer = (function () {
							function Initializer() {
								_classCallCheck(this, Initializer);
							}

							_createClass(Initializer, [{
								key: 'load',

								/**
								 * Load up defaults & options on the Typed instance
								 * @param {Typed} self instance of Typed
								 * @param {object} options options object
								 * @param {string} elementId HTML element ID _OR_ instance of HTML element
								 * @private
								 */

								value: function load(self, options, elementId) {
									// chosen element to manipulate text
									if (typeof elementId === 'string') {
										self.el = document.querySelector(elementId);
									} else {
										self.el = elementId;
									}

									self.options = _extends({}, _defaultsJs2['default'], options);

									// attribute to type into
									self.isInput = self.el.tagName.toLowerCase() === 'input';
									self.attr = self.options.attr;
									self.bindInputFocusEvents = self.options.bindInputFocusEvents;

									// show cursor
									self.showCursor = self.isInput ? false : self.options.showCursor;

									// custom cursor
									self.cursorChar = self.options.cursorChar;

									// Is the cursor blinking
									self.cursorBlinking = true;

									// text content of element
									self.elContent = self.attr ? self.el.getAttribute(self.attr) : self.el.textContent;

									// html or plain text
									self.contentType = self.options.contentType;

									// typing speed
									self.typeSpeed = self.options.typeSpeed;

									// add a delay before typing starts
									self.startDelay = self.options.startDelay;

									// backspacing speed
									self.backSpeed = self.options.backSpeed;

									// only backspace what doesn't match the previous string
									self.smartBackspace = self.options.smartBackspace;

									// amount of time to wait before backspacing
									self.backDelay = self.options.backDelay;

									// Fade out instead of backspace
									self.fadeOut = self.options.fadeOut;
									self.fadeOutClass = self.options.fadeOutClass;
									self.fadeOutDelay = self.options.fadeOutDelay;

									// variable to check whether typing is currently paused
									self.isPaused = false;

									// input strings of text
									self.strings = self.options.strings.map(function (s) {
										return s.trim();
									});

									// div containing strings
									if (typeof self.options.stringsElement === 'string') {
										self.stringsElement = document.querySelector(self.options.stringsElement);
									} else {
										self.stringsElement = self.options.stringsElement;
									}

									if (self.stringsElement) {
										self.strings = [];
										self.stringsElement.style.display = 'none';
										var strings = Array.prototype.slice.apply(self.stringsElement.children);
										var stringsLength = strings.length;

										if (stringsLength) {
											for (var i = 0; i < stringsLength; i += 1) {
												var stringEl = strings[i];
												self.strings.push(stringEl.innerHTML.trim());
											}
										}
									}

									// character number position of current string
									self.strPos = 0;

									// current array position
									self.arrayPos = 0;

									// index of string to stop backspacing on
									self.stopNum = 0;

									// Looping logic
									self.loop = self.options.loop;
									self.loopCount = self.options.loopCount;
									self.curLoop = 0;

									// shuffle the strings
									self.shuffle = self.options.shuffle;
									// the order of strings
									self.sequence = [];

									self.pause = {
										status: false,
										typewrite: true,
										curString: '',
										curStrPos: 0
									};

									// When the typing is complete (when not looped)
									self.typingComplete = false;

									// Set the order in which the strings are typed
									for (var i in self.strings) {
										self.sequence[i] = i;
									}

									// If there is some text in the element
									self.currentElContent = this.getCurrentElContent(self);

									self.autoInsertCss = self.options.autoInsertCss;

									this.appendAnimationCss(self);
								}
							}, {
								key: 'getCurrentElContent',
								value: function getCurrentElContent(self) {
									var elContent = '';
									if (self.attr) {
										elContent = self.el.getAttribute(self.attr);
									} else if (self.isInput) {
										elContent = self.el.value;
									} else if (self.contentType === 'html') {
										elContent = self.el.innerHTML;
									} else {
										elContent = self.el.textContent;
									}
									return elContent;
								}
							}, {
								key: 'appendAnimationCss',
								value: function appendAnimationCss(self) {
									var cssDataName = 'data-typed-js-css';
									if (!self.autoInsertCss) {
										return;
									}
									if (!self.showCursor && !self.fadeOut) {
										return;
									}
									if (document.querySelector('[' + cssDataName + ']')) {
										return;
									}

									var css = document.createElement('style');
									css.type = 'text/css';
									css.setAttribute(cssDataName, true);

									var innerCss = '';
									if (self.showCursor) {
										innerCss += '\n        .typed-cursor{\n          opacity: 1;\n        }\n        .typed-cursor.typed-cursor--blink{\n          animation: typedjsBlink 0.7s infinite;\n          -webkit-animation: typedjsBlink 0.7s infinite;\n                  animation: typedjsBlink 0.7s infinite;\n        }\n        @keyframes typedjsBlink{\n          50% { opacity: 0.0; }\n        }\n        @-webkit-keyframes typedjsBlink{\n          0% { opacity: 1; }\n          50% { opacity: 0.0; }\n          100% { opacity: 1; }\n        }\n      ';
									}
									if (self.fadeOut) {
										innerCss += '\n        .typed-fade-out{\n          opacity: 0;\n          transition: opacity .25s;\n        }\n        .typed-cursor.typed-cursor--blink.typed-fade-out{\n          -webkit-animation: 0;\n          animation: 0;\n        }\n      ';
									}
									if (css.length === 0) {
										return;
									}
									css.innerHTML = innerCss;
									document.body.appendChild(css);
								}
							}]);

							return Initializer;
						})();

						exports['default'] = Initializer;
						var initializer = new Initializer();
						exports.initializer = initializer;

						/***/
					}),
/* 2 */
/***/ (function (module, exports) {

						/**
						 * Defaults & options
						 * @returns {object} Typed defaults & options
						 * @public
						 */

						'use strict';

						Object.defineProperty(exports, '__esModule', {
							value: true
						});
						var defaults = {
							/**
							 * @property {array} strings strings to be typed
							 * @property {string} stringsElement ID of element containing string children
							 */
							strings: ['These are the default values...', 'You know what you should do?', 'Use your own!', 'Have a great day!'],
							stringsElement: null,

							/**
							 * @property {number} typeSpeed type speed in milliseconds
							 */
							typeSpeed: 0,

							/**
							 * @property {number} startDelay time before typing starts in milliseconds
							 */
							startDelay: 0,

							/**
							 * @property {number} backSpeed backspacing speed in milliseconds
							 */
							backSpeed: 0,

							/**
							 * @property {boolean} smartBackspace only backspace what doesn't match the previous string
							 */
							smartBackspace: true,

							/**
							 * @property {boolean} shuffle shuffle the strings
							 */
							shuffle: false,

							/**
							 * @property {number} backDelay time before backspacing in milliseconds
							 */
							backDelay: 700,

							/**
							 * @property {boolean} fadeOut Fade out instead of backspace
							 * @property {string} fadeOutClass css class for fade animation
							 * @property {boolean} fadeOutDelay Fade out delay in milliseconds
							 */
							fadeOut: false,
							fadeOutClass: 'typed-fade-out',
							fadeOutDelay: 500,

							/**
							 * @property {boolean} loop loop strings
							 * @property {number} loopCount amount of loops
							 */
							loop: false,
							loopCount: Infinity,

							/**
							 * @property {boolean} showCursor show cursor
							 * @property {string} cursorChar character for cursor
							 * @property {boolean} autoInsertCss insert CSS for cursor and fadeOut into HTML <head>
							 */
							showCursor: true,
							cursorChar: '|',
							autoInsertCss: true,

							/**
							 * @property {string} attr attribute for typing
							 * Ex: input placeholder, value, or just HTML text
							 */
							attr: null,

							/**
							 * @property {boolean} bindInputFocusEvents bind to focus and blur if el is text input
							 */
							bindInputFocusEvents: false,

							/**
							 * @property {string} contentType 'html' or 'null' for plaintext
							 */
							contentType: 'html',

							/**
							 * Before it begins typing
							 * @param {Typed} self
							 */
							onBegin: function onBegin(self) { },

							/**
							 * All typing is complete
							 * @param {Typed} self
							 */
							onComplete: function onComplete(self) { },

							/**
							 * Before each string is typed
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							preStringTyped: function preStringTyped(arrayPos, self) { },

							/**
							 * After each string is typed
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							onStringTyped: function onStringTyped(arrayPos, self) { },

							/**
							 * During looping, after last string is typed
							 * @param {Typed} self
							 */
							onLastStringBackspaced: function onLastStringBackspaced(self) { },

							/**
							 * Typing has been stopped
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							onTypingPaused: function onTypingPaused(arrayPos, self) { },

							/**
							 * Typing has been started after being stopped
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							onTypingResumed: function onTypingResumed(arrayPos, self) { },

							/**
							 * After reset
							 * @param {Typed} self
							 */
							onReset: function onReset(self) { },

							/**
							 * After stop
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							onStop: function onStop(arrayPos, self) { },

							/**
							 * After start
							 * @param {number} arrayPos
							 * @param {Typed} self
							 */
							onStart: function onStart(arrayPos, self) { },

							/**
							 * After destroy
							 * @param {Typed} self
							 */
							onDestroy: function onDestroy(self) { }
						};

						exports['default'] = defaults;
						module.exports = exports['default'];

						/***/
					}),
/* 3 */
/***/ (function (module, exports) {

						/**
						 * TODO: These methods can probably be combined somehow
						 * Parse HTML tags & HTML Characters
						 */

						'use strict';

						Object.defineProperty(exports, '__esModule', {
							value: true
						});

						var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						var HTMLParser = (function () {
							function HTMLParser() {
								_classCallCheck(this, HTMLParser);
							}

							_createClass(HTMLParser, [{
								key: 'typeHtmlChars',

								/**
								 * Type HTML tags & HTML Characters
								 * @param {string} curString Current string
								 * @param {number} curStrPos Position in current string
								 * @param {Typed} self instance of Typed
								 * @returns {number} a new string position
								 * @private
								 */

								value: function typeHtmlChars(curString, curStrPos, self) {
									if (self.contentType !== 'html') return curStrPos;
									var curChar = curString.substr(curStrPos).charAt(0);
									if (curChar === '<' || curChar === '&') {
										var endTag = '';
										if (curChar === '<') {
											endTag = '>';
										} else {
											endTag = ';';
										}
										while (curString.substr(curStrPos + 1).charAt(0) !== endTag) {
											curStrPos++;
											if (curStrPos + 1 > curString.length) {
												break;
											}
										}
										curStrPos++;
									}
									return curStrPos;
								}

								/**
								 * Backspace HTML tags and HTML Characters
								 * @param {string} curString Current string
								 * @param {number} curStrPos Position in current string
								 * @param {Typed} self instance of Typed
								 * @returns {number} a new string position
								 * @private
								 */
							}, {
								key: 'backSpaceHtmlChars',
								value: function backSpaceHtmlChars(curString, curStrPos, self) {
									if (self.contentType !== 'html') return curStrPos;
									var curChar = curString.substr(curStrPos).charAt(0);
									if (curChar === '>' || curChar === ';') {
										var endTag = '';
										if (curChar === '>') {
											endTag = '<';
										} else {
											endTag = '&';
										}
										while (curString.substr(curStrPos - 1).charAt(0) !== endTag) {
											curStrPos--;
											if (curStrPos < 0) {
												break;
											}
										}
										curStrPos--;
									}
									return curStrPos;
								}
							}]);

							return HTMLParser;
						})();

						exports['default'] = HTMLParser;
						var htmlParser = new HTMLParser();
						exports.htmlParser = htmlParser;

						/***/
					})
/******/])
			});
			;

			/***/
		}),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function (module, exports) {

/* WEBPACK VAR INJECTION */(function (__webpack_amd_options__) {/* globals __webpack_amd_options__ */
				module.exports = __webpack_amd_options__;

				/* WEBPACK VAR INJECTION */
			}.call(this, {}))

			/***/
		}),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function (module, exports) {

			var g;

			// This works in non-strict mode
			g = (function () {
				return this;
			})();

			try {
				// This works if eval is allowed (see CSP)
				g = g || new Function("return this")();
			} catch (e) {
				// This works if the window reference is available
				if (typeof window === "object") g = window;
			}

			// g can still be undefined, but nothing to do about it...
			// We return undefined, instead of nothing here, so it's
			// easier to handle this case. if(!global) { ...}

			module.exports = g;


			/***/
		}),

/***/ "./node_modules/wow.js/dist/wow.js":
/*!*****************************************!*\
  !*** ./node_modules/wow.js/dist/wow.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; (function (global, factory) {
				if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
						__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
							(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				} else { var mod; }
			})(this, function (module, exports) {
				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _class, _temp;

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];
							descriptor.enumerable = descriptor.enumerable || false;
							descriptor.configurable = true;
							if ("value" in descriptor) descriptor.writable = true;
							Object.defineProperty(target, descriptor.key, descriptor);
						}
					}

					return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);
						if (staticProps) defineProperties(Constructor, staticProps);
						return Constructor;
					};
				}();

				function isIn(needle, haystack) {
					return haystack.indexOf(needle) >= 0;
				}

				function extend(custom, defaults) {
					for (var key in defaults) {
						if (custom[key] == null) {
							var value = defaults[key];
							custom[key] = value;
						}
					}
					return custom;
				}

				function isMobile(agent) {
					return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent)
					);
				}

				function createEvent(event) {
					var bubble = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
					var cancel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
					var detail = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

					var customEvent = void 0;
					if (document.createEvent != null) {
						// W3C DOM
						customEvent = document.createEvent('CustomEvent');
						customEvent.initCustomEvent(event, bubble, cancel, detail);
					} else if (document.createEventObject != null) {
						// IE DOM < 9
						customEvent = document.createEventObject();
						customEvent.eventType = event;
					} else {
						customEvent.eventName = event;
					}

					return customEvent;
				}

				function emitEvent(elem, event) {
					if (elem.dispatchEvent != null) {
						// W3C DOM
						elem.dispatchEvent(event);
					} else if (event in (elem != null)) {
						elem[event]();
					} else if ('on' + event in (elem != null)) {
						elem['on' + event]();
					}
				}

				function addEvent(elem, event, fn) {
					if (elem.addEventListener != null) {
						// W3C DOM
						elem.addEventListener(event, fn, false);
					} else if (elem.attachEvent != null) {
						// IE DOM
						elem.attachEvent('on' + event, fn);
					} else {
						// fallback
						elem[event] = fn;
					}
				}

				function removeEvent(elem, event, fn) {
					if (elem.removeEventListener != null) {
						// W3C DOM
						elem.removeEventListener(event, fn, false);
					} else if (elem.detachEvent != null) {
						// IE DOM
						elem.detachEvent('on' + event, fn);
					} else {
						// fallback
						delete elem[event];
					}
				}

				function getInnerHeight() {
					if ('innerHeight' in window) {
						return window.innerHeight;
					}

					return document.documentElement.clientHeight;
				}

				// Minimalistic WeakMap shim, just in case.
				var WeakMap = window.WeakMap || window.MozWeakMap || function () {
					function WeakMap() {
						_classCallCheck(this, WeakMap);

						this.keys = [];
						this.values = [];
					}

					_createClass(WeakMap, [{
						key: 'get',
						value: function get(key) {
							for (var i = 0; i < this.keys.length; i++) {
								var item = this.keys[i];
								if (item === key) {
									return this.values[i];
								}
							}
							return undefined;
						}
					}, {
						key: 'set',
						value: function set(key, value) {
							for (var i = 0; i < this.keys.length; i++) {
								var item = this.keys[i];
								if (item === key) {
									this.values[i] = value;
									return this;
								}
							}
							this.keys.push(key);
							this.values.push(value);
							return this;
						}
					}]);

					return WeakMap;
				}();

				// Dummy MutationObserver, to avoid raising exceptions.
				var MutationObserver = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (_temp = _class = function () {
					function MutationObserver() {
						_classCallCheck(this, MutationObserver);

						if (typeof console !== 'undefined' && console !== null) {
							console.warn('MutationObserver is not supported by your browser.');
							console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');
						}
					}

					_createClass(MutationObserver, [{
						key: 'observe',
						value: function observe() { }
					}]);

					return MutationObserver;
				}(), _class.notSupported = true, _temp);

				// getComputedStyle shim, from http://stackoverflow.com/a/21797294
				var getComputedStyle = window.getComputedStyle || function getComputedStyle(el) {
					var getComputedStyleRX = /(\-([a-z]){1})/g;
					return {
						getPropertyValue: function getPropertyValue(prop) {
							if (prop === 'float') {
								prop = 'styleFloat';
							}
							if (getComputedStyleRX.test(prop)) {
								prop.replace(getComputedStyleRX, function (_, _char) {
									return _char.toUpperCase();
								});
							}
							var currentStyle = el.currentStyle;

							return (currentStyle != null ? currentStyle[prop] : void 0) || null;
						}
					};
				};

				var WOW = function () {
					function WOW() {
						var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

						_classCallCheck(this, WOW);

						this.defaults = {
							boxClass: 'wow',
							animateClass: 'animated',
							offset: 0,
							mobile: true,
							live: true,
							callback: null,
							scrollContainer: null
						};

						this.animate = function animateFactory() {
							if ('requestAnimationFrame' in window) {
								return function (callback) {
									return window.requestAnimationFrame(callback);
								};
							}
							return function (callback) {
								return callback();
							};
						}();

						this.vendors = ['moz', 'webkit'];

						this.start = this.start.bind(this);
						this.resetAnimation = this.resetAnimation.bind(this);
						this.scrollHandler = this.scrollHandler.bind(this);
						this.scrollCallback = this.scrollCallback.bind(this);
						this.scrolled = true;
						this.config = extend(options, this.defaults);
						if (options.scrollContainer != null) {
							this.config.scrollContainer = document.querySelector(options.scrollContainer);
						}
						// Map of elements to animation names:
						this.animationNameCache = new WeakMap();
						this.wowEvent = createEvent(this.config.boxClass);
					}

					_createClass(WOW, [{
						key: 'init',
						value: function init() {
							this.element = window.document.documentElement;
							if (isIn(document.readyState, ['interactive', 'complete'])) {
								this.start();
							} else {
								addEvent(document, 'DOMContentLoaded', this.start);
							}
							this.finished = [];
						}
					}, {
						key: 'start',
						value: function start() {
							var _this = this;

							this.stopped = false;
							this.boxes = [].slice.call(this.element.querySelectorAll('.' + this.config.boxClass));
							this.all = this.boxes.slice(0);
							if (this.boxes.length) {
								if (this.disabled()) {
									this.resetStyle();
								} else {
									for (var i = 0; i < this.boxes.length; i++) {
										var box = this.boxes[i];
										this.applyStyle(box, true);
									}
								}
							}
							if (!this.disabled()) {
								addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
								addEvent(window, 'resize', this.scrollHandler);
								this.interval = setInterval(this.scrollCallback, 50);
							}
							if (this.config.live) {
								var mut = new MutationObserver(function (records) {
									for (var j = 0; j < records.length; j++) {
										var record = records[j];
										for (var k = 0; k < record.addedNodes.length; k++) {
											var node = record.addedNodes[k];
											_this.doSync(node);
										}
									}
									return undefined;
								});
								mut.observe(document.body, {
									childList: true,
									subtree: true
								});
							}
						}
					}, {
						key: 'stop',
						value: function stop() {
							this.stopped = true;
							removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
							removeEvent(window, 'resize', this.scrollHandler);
							if (this.interval != null) {
								clearInterval(this.interval);
							}
						}
					}, {
						key: 'sync',
						value: function sync() {
							if (MutationObserver.notSupported) {
								this.doSync(this.element);
							}
						}
					}, {
						key: 'doSync',
						value: function doSync(element) {
							if (typeof element === 'undefined' || element === null) {
								element = this.element;
							}
							if (element.nodeType !== 1) {
								return;
							}
							element = element.parentNode || element;
							var iterable = element.querySelectorAll('.' + this.config.boxClass);
							for (var i = 0; i < iterable.length; i++) {
								var box = iterable[i];
								if (!isIn(box, this.all)) {
									this.boxes.push(box);
									this.all.push(box);
									if (this.stopped || this.disabled()) {
										this.resetStyle();
									} else {
										this.applyStyle(box, true);
									}
									this.scrolled = true;
								}
							}
						}
					}, {
						key: 'show',
						value: function show(box) {
							this.applyStyle(box);
							box.className = box.className + ' ' + this.config.animateClass;
							if (this.config.callback != null) {
								this.config.callback(box);
							}
							emitEvent(box, this.wowEvent);

							addEvent(box, 'animationend', this.resetAnimation);
							addEvent(box, 'oanimationend', this.resetAnimation);
							addEvent(box, 'webkitAnimationEnd', this.resetAnimation);
							addEvent(box, 'MSAnimationEnd', this.resetAnimation);

							return box;
						}
					}, {
						key: 'applyStyle',
						value: function applyStyle(box, hidden) {
							var _this2 = this;

							var duration = box.getAttribute('data-wow-duration');
							var delay = box.getAttribute('data-wow-delay');
							var iteration = box.getAttribute('data-wow-iteration');

							return this.animate(function () {
								return _this2.customStyle(box, hidden, duration, delay, iteration);
							});
						}
					}, {
						key: 'resetStyle',
						value: function resetStyle() {
							for (var i = 0; i < this.boxes.length; i++) {
								var box = this.boxes[i];
								box.style.visibility = 'visible';
							}
							return undefined;
						}
					}, {
						key: 'resetAnimation',
						value: function resetAnimation(event) {
							if (event.type.toLowerCase().indexOf('animationend') >= 0) {
								var target = event.target || event.srcElement;
								target.className = target.className.replace(this.config.animateClass, '').trim();
							}
						}
					}, {
						key: 'customStyle',
						value: function customStyle(box, hidden, duration, delay, iteration) {
							if (hidden) {
								this.cacheAnimationName(box);
							}
							box.style.visibility = hidden ? 'hidden' : 'visible';

							if (duration) {
								this.vendorSet(box.style, { animationDuration: duration });
							}
							if (delay) {
								this.vendorSet(box.style, { animationDelay: delay });
							}
							if (iteration) {
								this.vendorSet(box.style, { animationIterationCount: iteration });
							}
							this.vendorSet(box.style, { animationName: hidden ? 'none' : this.cachedAnimationName(box) });

							return box;
						}
					}, {
						key: 'vendorSet',
						value: function vendorSet(elem, properties) {
							for (var name in properties) {
								if (properties.hasOwnProperty(name)) {
									var value = properties[name];
									elem['' + name] = value;
									for (var i = 0; i < this.vendors.length; i++) {
										var vendor = this.vendors[i];
										elem['' + vendor + name.charAt(0).toUpperCase() + name.substr(1)] = value;
									}
								}
							}
						}
					}, {
						key: 'vendorCSS',
						value: function vendorCSS(elem, property) {
							var style = getComputedStyle(elem);
							var result = style.getPropertyCSSValue(property);
							for (var i = 0; i < this.vendors.length; i++) {
								var vendor = this.vendors[i];
								result = result || style.getPropertyCSSValue('-' + vendor + '-' + property);
							}
							return result;
						}
					}, {
						key: 'animationName',
						value: function animationName(box) {
							var aName = void 0;
							try {
								aName = this.vendorCSS(box, 'animation-name').cssText;
							} catch (error) {
								// Opera, fall back to plain property value
								aName = getComputedStyle(box).getPropertyValue('animation-name');
							}

							if (aName === 'none') {
								return ''; // SVG/Firefox, unable to get animation name?
							}

							return aName;
						}
					}, {
						key: 'cacheAnimationName',
						value: function cacheAnimationName(box) {
							// https://bugzilla.mozilla.org/show_bug.cgi?id=921834
							// box.dataset is not supported for SVG elements in Firefox
							return this.animationNameCache.set(box, this.animationName(box));
						}
					}, {
						key: 'cachedAnimationName',
						value: function cachedAnimationName(box) {
							return this.animationNameCache.get(box);
						}
					}, {
						key: 'scrollHandler',
						value: function scrollHandler() {
							this.scrolled = true;
						}
					}, {
						key: 'scrollCallback',
						value: function scrollCallback() {
							if (this.scrolled) {
								this.scrolled = false;
								var results = [];
								for (var i = 0; i < this.boxes.length; i++) {
									var box = this.boxes[i];
									if (box) {
										if (this.isVisible(box)) {
											this.show(box);
											continue;
										}
										results.push(box);
									}
								}
								this.boxes = results;
								if (!this.boxes.length && !this.config.live) {
									this.stop();
								}
							}
						}
					}, {
						key: 'offsetTop',
						value: function offsetTop(element) {
							// SVG elements don't have an offsetTop in Firefox.
							// This will use their nearest parent that has an offsetTop.
							// Also, using ('offsetTop' of element) causes an exception in Firefox.
							while (element.offsetTop === undefined) {
								element = element.parentNode;
							}
							var top = element.offsetTop;
							while (element.offsetParent) {
								element = element.offsetParent;
								top += element.offsetTop;
							}
							return top;
						}
					}, {
						key: 'isVisible',
						value: function isVisible(box) {
							var offset = box.getAttribute('data-wow-offset') || this.config.offset;
							var viewTop = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset;
							var viewBottom = viewTop + Math.min(this.element.clientHeight, getInnerHeight()) - offset;
							var top = this.offsetTop(box);
							var bottom = top + box.clientHeight;

							return top <= viewBottom && bottom >= viewTop;
						}
					}, {
						key: 'disabled',
						value: function disabled() {
							return !this.config.mobile && isMobile(navigator.userAgent);
						}
					}]);

					return WOW;
				}();

				exports.default = WOW;
				module.exports = exports['default'];
			});


			/***/
		}),

/***/ "./src/assets/js/index.js":
/*!********************************!*\
  !*** ./src/assets/js/index.js ***!
  \********************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function (global) {/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.number.to-fixed */ "./node_modules/core-js/modules/es.number.to-fixed.js");
/* harmony import */ var core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var wow_js_dist_wow_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wow.js/dist/wow.js */ "./node_modules/wow.js/dist/wow.js");
/* harmony import */ var wow_js_dist_wow_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(wow_js_dist_wow_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var custom_select__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! custom-select */ "./node_modules/custom-select/build/index.js");
/* harmony import */ var custom_select__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(custom_select__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _modules_utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/utilities */ "./src/assets/js/modules/utilities.js");






				undefined;
				global.jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
				var $ = global.jQuery;
				window.$ = $; // basics imports



				var Typed = __webpack_require__(/*! typed.js */ "./node_modules/typed.js/lib/typed.js");

				__webpack_require__(/*! lightbox2 */ "./node_modules/lightbox2/dist/js/lightbox.js");



				__webpack_require__(/*! ./libs/jquery.countTo.js */ "./src/assets/js/libs/jquery.countTo.js");
				/* =====================================
						UTILITIES
				/* =====================================*/



				/* =====================================
						WINDOW ON LOAD
				/* =====================================*/

				window.addEventListener("load", function () {
					// document.querySelector("body").classList.remove("loading");
					// document.querySelector("body").classList.add("loaded");
					// console.log("window loaded");
				});

				document.addEventListener("DOMContentLoaded", function () {
					console.log("document loaded");
					var delayInMilliseconds = 400; //1 second


					setTimeout(function() {
						console.log("removed animation");
						document.querySelector("body").classList.remove("loading");
						document.querySelector("body").classList.add("loaded");
					}, delayInMilliseconds);
				});

				$(window).on("load", function () {
					// Add class fade to each of sidebar widget
					$(".sidebar-widget").each(function (key, el) {
						$(el).addClass("fade-effect");
					}); // General fade in effect for content

					Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["fadeEffectForContent"])();
				});
				/* =====================================
						WINDOW ON SCROLL
				/* =====================================*/

				/* =====================================
						DOCUMENT ON READY
				/* =====================================*/

				$(document).on("ready", function () {
					// Include module for carousels
					__webpack_require__(/*! ./modules/carousel-module */ "./src/assets/js/modules/carousel-module.js"); // Include module for popups window


					__webpack_require__(/*! ./modules/popup-module */ "./src/assets/js/modules/popup-module.js"); // Include module tabs


					__webpack_require__(/*! ./modules/tabs-module */ "./src/assets/js/modules/tabs-module.js"); // Include module accordion


					__webpack_require__(/*! ./modules/accordion-module */ "./src/assets/js/modules/accordion-module.js"); // Include module masonry grid


					__webpack_require__(/*! ./modules/masonry-grid-module */ "./src/assets/js/modules/masonry-grid-module.js"); // Include module navigation


					__webpack_require__(/*! ./modules/nav-module */ "./src/assets/js/modules/nav-module.js");

					$('.counter').countTo({
						refreshInterval: 50,
						formatter: function formatter(value, options) {
							value = value.toFixed(options.decimals);
							value = value.replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
							return value;
						}
					});
					$(window).scroll(function () {
						if ($(window).scrollTop() > topHeight) {
							$("#scrollTop").addClass("active");
						} else {
							$("#scrollTop").removeClass("active");
						}
					}); // Custom select

					custom_select__WEBPACK_IMPORTED_MODULE_5___default()(".material-custom-select"); // Typed string at model-overview-widget

					if ($(".typed").length && $("#typed-strings").length) {
						new Typed(".typed", {
							stringsElement: "#typed-strings",
							loop: true,
							typeSpeed: 60,
							backSpeed: 60,
							startDelay: 1200,
							backDelay: 1500
						});
					} // Init toggleDisableFormButton


					Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["toggleDisableFormButton"])([" .test-drive-form", "#call-now-inner .call-now-form", "#order-consultation-inner .order-consultation-form"]); // Scroll to top

					var topHeight = $("#header").outerHeight();
					$("#scrollTop").on("click", function () {
						$("html, body").animate({
							scrollTop: "0px"
						}, 200);
					}); // init setModelParams when widget model-builder-widget loaded

					if ($(".model-builder-widget .model-image").length) {
						// set model parms to car main image
						Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["setModelParams"])();
					} // Model engine changing active tab


					$(document).on("click", ".engines-list li", function (event) {
						event.preventDefault();
						$(".engines-list li").removeClass("active");
						$(this).closest("li").addClass("active"); // set model parms to car main image

						Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["setModelParams"])();
					}); // Advantages box change active item

					$(document).on("click", ".advantage-item", function (event) {
						event.preventDefault();
						$(".advantage-item").removeClass("active");
						$(this).addClass("active");
					}); // Model wheel changing active tab

					$(document).on("click", ".wheels-list li", function (event) {
						$(".wheels-list li").removeClass("active");
						$(this).closest("li").addClass("active"); // set model parms to car main image

						Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["setModelParams"])();
					}); // Add animation for comments

					Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["animationsForComments"])(".comment"); // Wrap all tables with class table in post-content for mobile responsive

					$(".post-content .table").wrap('<div class="table-responsive"></div>'); // Start close alert messages

					Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["closeAlertMessages"])(); //init wow.js

					new wow_js_dist_wow_js__WEBPACK_IMPORTED_MODULE_4___default.a().init();
					$(".posts-categories-list li a").click(function (e) {
						$(".posts-categories-list li a.active").removeClass("active");
						$(this).addClass("active");
						e.preventDefault();
					}); // responsive iframe

					if ($("iframe").length) {
						$("iframe").wrap('<div class="responsive-iframe"></div>').removeAttr("width height");
					} // full width p for p > img just only for desktop


					if (window.matchMedia("(min-width: 992px)").matches) {
						$("p:has(img:first)").css({
							"max-width": "100%"
						});
					} // writing number for ol li


					$(".ordered-list > li").each(function () {
						$(this).prepend("<span class='list-number'>" + ($(this).index() + 1) + "." + "</span>");
					}); // No click

					$(".no-click").on("click", function (e) {
						e.preventDefault();
					}); // init containerToContainerFluid

					Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["containerToContainerFluid"])("#contact-map-wrap"); // containerToContainerFluid on resize event

					window.onresize = function () {
						Object(_modules_utilities__WEBPACK_IMPORTED_MODULE_6__["containerToContainerFluid"])("#contact-map-wrap");
					};
				});
				/**
				 * Replace all SVG images with inline SVG
				 */

				jQuery("img.svg").each(function () {
					var $img = jQuery(this);
					var imgID = $img.attr("id");
					var imgClass = $img.attr("class");
					var imgURL = $img.attr("src");
					jQuery.get(imgURL, function (data) {
						// Get the SVG tag, ignore the rest
						var $svg = jQuery(data).find("svg"); // Add replaced image's ID to the new SVG

						if (typeof imgID !== "undefined") {
							$svg = $svg.attr("id", imgID);
						} // Add replaced image's classes to the new SVG


						if (typeof imgClass !== "undefined") {
							$svg = $svg.attr("class", imgClass + " replaced-svg");
						} // Remove any invalid XML tags as per http://validator.w3.org


						$svg = $svg.removeAttr("xmlns:a"); // Replace image with new SVG

						$img.replaceWith($svg);
					}, "xml");
				});
				/* WEBPACK VAR INJECTION */
			}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

			/***/
		}),

/***/ "./src/assets/js/libs/jquery.countTo.js":
/*!**********************************************!*\
  !*** ./src/assets/js/libs/jquery.countTo.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.number.to-fixed */ "./node_modules/core-js/modules/es.number.to-fixed.js");
/* harmony import */ var core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_to_fixed__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");
/* harmony import */ var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_8__);










			function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

			(function (factory) {
				if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
					// AMD
					define(['jquery'], factory);
				} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
					// CommonJS
					factory(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
				} else {
					// Browser globals
					factory(jQuery);
				}
			})(function ($) {
				var CountTo = function CountTo(element, options) {
					this.$element = $(element);
					this.options = $.extend({}, CountTo.DEFAULTS, this.dataOptions(), options);
					this.init();
				};

				CountTo.DEFAULTS = {
					from: 0,
					// the number the element should start at
					to: 0,
					// the number the element should end at
					speed: 1000,
					// how long it should take to count between the target numbers
					refreshInterval: 100,
					// how often the element should be updated
					decimals: 0,
					// the number of decimal places to show
					formatter: formatter,
					// handler for formatting the value before rendering
					onUpdate: null,
					// callback method for every time the element is updated
					onComplete: null // callback method for when the element finishes updating

				};

				CountTo.prototype.init = function () {
					this.value = this.options.from;
					this.loops = Math.ceil(this.options.speed / this.options.refreshInterval);
					this.loopCount = 0;
					this.increment = (this.options.to - this.options.from) / this.loops;
				};

				CountTo.prototype.dataOptions = function () {
					var options = {
						from: this.$element.data('from'),
						to: this.$element.data('to'),
						speed: this.$element.data('speed'),
						refreshInterval: this.$element.data('refresh-interval'),
						decimals: this.$element.data('decimals')
					};
					var keys = Object.keys(options);

					for (var i in keys) {
						var key = keys[i];

						if (typeof options[key] === 'undefined') {
							delete options[key];
						}
					}

					return options;
				};

				CountTo.prototype.update = function () {
					this.value += this.increment;
					this.loopCount++;
					this.render();

					if (typeof this.options.onUpdate == 'function') {
						this.options.onUpdate.call(this.$element, this.value);
					}

					if (this.loopCount >= this.loops) {
						clearInterval(this.interval);
						this.value = this.options.to;

						if (typeof this.options.onComplete == 'function') {
							this.options.onComplete.call(this.$element, this.value);
						}
					}
				};

				CountTo.prototype.render = function () {
					var formattedValue = this.options.formatter.call(this.$element, this.value, this.options);
					this.$element.text(formattedValue);
				};

				CountTo.prototype.restart = function () {
					this.stop();
					this.init();
					this.start();
				};

				CountTo.prototype.start = function () {
					this.stop();
					this.render();
					this.interval = setInterval(this.update.bind(this), this.options.refreshInterval);
				};

				CountTo.prototype.stop = function () {
					if (this.interval) {
						clearInterval(this.interval);
					}
				};

				CountTo.prototype.toggle = function () {
					if (this.interval) {
						this.stop();
					} else {
						this.start();
					}
				};

				function formatter(value, options) {
					return value.toFixed(options.decimals);
				}

				$.fn.countTo = function (option) {
					return this.each(function () {
						var $this = $(this);
						var data = $this.data('countTo');
						var init = !data || _typeof(option) === 'object';
						var options = _typeof(option) === 'object' ? option : {};
						var method = typeof option === 'string' ? option : 'start';

						if (init) {
							if (data) data.stop();
							$this.data('countTo', data = new CountTo(this, options));
						}

						data[method].call(data);
					});
				};
			});

			/***/
		}),

/***/ "./src/assets/js/libs/lightslider.js":
/*!*******************************************!*\
  !*** ./src/assets/js/libs/lightslider.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);


			(function ($, undefined) {
				'use strict';

				var defaults = {
					item: 3,
					autoWidth: false,
					slideMove: 1,
					slideMargin: 10,
					addClass: '',
					mode: 'slide',
					useCSS: true,
					cssEasing: 'ease',
					//'cubic-bezier(0.25, 0, 0.25, 1)',
					easing: 'linear',
					//'for jquery animation',//
					speed: 400,
					//ms'
					auto: false,
					pauseOnHover: false,
					loop: false,
					slideEndAnimation: true,
					pause: 2000,
					keyPress: false,
					controls: true,
					prevHtml: '',
					nextHtml: '',
					rtl: false,
					adaptiveHeight: false,
					vertical: false,
					verticalHeight: 500,
					vThumbWidth: 100,
					thumbItem: 10,
					pager: true,
					gallery: false,
					galleryMargin: 5,
					thumbMargin: 5,
					currentPagerPosition: 'middle',
					enableTouch: true,
					enableDrag: true,
					freeMove: true,
					swipeThreshold: 40,
					responsive: [],

					/* jshint ignore:start */
					onBeforeStart: function onBeforeStart($el) { },
					onSliderLoad: function onSliderLoad($el) { },
					onBeforeSlide: function onBeforeSlide($el, scene) { },
					onAfterSlide: function onAfterSlide($el, scene) { },
					onBeforeNextSlide: function onBeforeNextSlide($el, scene) { },
					onBeforePrevSlide: function onBeforePrevSlide($el, scene) { }
					/* jshint ignore:end */

				};

				$.fn.lightSlider = function (options) {
					if (this.length === 0) {
						return this;
					}

					if (this.length > 1) {
						this.each(function () {
							$(this).lightSlider(options);
						});
						return this;
					}

					var plugin = {},
						settings = $.extend(true, {}, defaults, options),
						settingsTemp = {},
						$el = this;
					plugin.$el = this;

					if (settings.mode === 'fade') {
						settings.vertical = false;
					}

					var $children = $el.children(),
						windowW = $(window).width(),
						breakpoint = null,
						resposiveObj = null,
						length = 0,
						w = 0,
						on = false,
						elSize = 0,
						$slide = '',
						scene = 0,
						property = settings.vertical === true ? 'height' : 'width',
						gutter = settings.vertical === true ? 'margin-bottom' : 'margin-right',
						slideValue = 0,
						pagerWidth = 0,
						slideWidth = 0,
						thumbWidth = 0,
						interval = null,
						isTouch = ('ontouchstart' in document.documentElement);
					var refresh = {};

					refresh.chbreakpoint = function () {
						windowW = $(window).width();

						if (settings.responsive.length) {
							var item;

							if (settings.autoWidth === false) {
								item = settings.item;
							}

							if (windowW < settings.responsive[0].breakpoint) {
								for (var i = 0; i < settings.responsive.length; i++) {
									if (windowW < settings.responsive[i].breakpoint) {
										breakpoint = settings.responsive[i].breakpoint;
										resposiveObj = settings.responsive[i];
									}
								}
							}

							if (typeof resposiveObj !== 'undefined' && resposiveObj !== null) {
								for (var j in resposiveObj.settings) {
									if (resposiveObj.settings.hasOwnProperty(j)) {
										if (typeof settingsTemp[j] === 'undefined' || settingsTemp[j] === null) {
											settingsTemp[j] = settings[j];
										}

										settings[j] = resposiveObj.settings[j];
									}
								}
							}

							if (!$.isEmptyObject(settingsTemp) && windowW > settings.responsive[0].breakpoint) {
								for (var k in settingsTemp) {
									if (settingsTemp.hasOwnProperty(k)) {
										settings[k] = settingsTemp[k];
									}
								}
							}

							if (settings.autoWidth === false) {
								if (slideValue > 0 && slideWidth > 0) {
									if (item !== settings.item) {
										scene = Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove));
									}
								}
							}
						}
					};

					refresh.calSW = function () {
						if (settings.autoWidth === false) {
							slideWidth = (elSize - (settings.item * settings.slideMargin - settings.slideMargin)) / settings.item;
						}
					};

					refresh.calWidth = function (cln) {
						var ln = cln === true ? $slide.find('.lslide').length : $children.length;

						if (settings.autoWidth === false) {
							w = ln * (slideWidth + settings.slideMargin);
						} else {
							w = 0;

							for (var i = 0; i < ln; i++) {
								w += parseInt($children.eq(i).width()) + settings.slideMargin;
							}
						}

						return w;
					};

					plugin = {
						doCss: function doCss() {
							var support = function support() {
								var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
								var root = document.documentElement;

								for (var i = 0; i < transition.length; i++) {
									if (transition[i] in root.style) {
										return true;
									}
								}
							};

							if (settings.useCSS && support()) {
								return true;
							}

							return false;
						},
						keyPress: function keyPress() {
							if (settings.keyPress) {
								$(document).on('keyup.lightslider', function (e) {
									if (!$(':focus').is('input, textarea')) {
										if (e.preventDefault) {
											e.preventDefault();
										} else {
											e.returnValue = false;
										}

										if (e.keyCode === 37) {
											$el.goToPrevSlide();
										} else if (e.keyCode === 39) {
											$el.goToNextSlide();
										}
									}
								});
							}
						},
						controls: function controls() {
							if (settings.controls) {
								$el.after('<div class="lSAction"><a class="lSPrev">' + settings.prevHtml + '</a><a class="lSNext">' + settings.nextHtml + '</a></div>');

								if (!settings.autoWidth) {
									if (length <= settings.item) {
										$slide.find('.lSAction').hide();
									}
								} else {
									if (refresh.calWidth(false) < elSize) {
										$slide.find('.lSAction').hide();
									}
								}

								$slide.find('.lSAction a').on('click', function (e) {
									if (e.preventDefault) {
										e.preventDefault();
									} else {
										e.returnValue = false;
									}

									if ($(this).attr('class') === 'lSPrev') {
										$el.goToPrevSlide();
									} else {
										$el.goToNextSlide();
									}

									return false;
								});
							}
						},
						initialStyle: function initialStyle() {
							var $this = this;

							if (settings.mode === 'fade') {
								settings.autoWidth = false;
								settings.slideEndAnimation = false;
							}

							if (settings.auto) {
								settings.slideEndAnimation = false;
							}

							if (settings.autoWidth) {
								settings.slideMove = 1;
								settings.item = 1;
							}

							if (settings.loop) {
								settings.slideMove = 1;
								settings.freeMove = false;
							}

							settings.onBeforeStart.call(this, $el);
							refresh.chbreakpoint();
							$el.addClass('lightSlider').wrap('<div class="lSSlideOuter ' + settings.addClass + '"><div class="lSSlideWrapper"></div></div>');
							$slide = $el.parent('.lSSlideWrapper');

							if (settings.rtl === true) {
								$slide.parent().addClass('lSrtl');
							}

							if (settings.vertical) {
								$slide.parent().addClass('vertical');
								elSize = settings.verticalHeight;
								$slide.css('height', elSize + 'px');
							} else {
								elSize = $el.outerWidth();
							}

							$children.addClass('lslide');

							if (settings.loop === true && settings.mode === 'slide') {
								refresh.calSW();

								refresh.clone = function () {
									if (refresh.calWidth(true) > elSize) {
										/**/
										var tWr = 0,
											tI = 0;

										for (var k = 0; k < $children.length; k++) {
											tWr += parseInt($el.find('.lslide').eq(k).width()) + settings.slideMargin;
											tI++;

											if (tWr >= elSize + settings.slideMargin) {
												break;
											}
										}

										var tItem = settings.autoWidth === true ? tI : settings.item;
										/**/

										if (tItem < $el.find('.clone.left').length) {
											for (var i = 0; i < $el.find('.clone.left').length - tItem; i++) {
												$children.eq(i).remove();
											}
										}

										if (tItem < $el.find('.clone.right').length) {
											for (var j = $children.length - 1; j > $children.length - 1 - $el.find('.clone.right').length; j--) {
												scene--;
												$children.eq(j).remove();
											}
										}
										/**/


										for (var n = $el.find('.clone.right').length; n < tItem; n++) {
											$el.find('.lslide').eq(n).clone().removeClass('lslide').addClass('clone right').appendTo($el);
											scene++;
										}

										for (var m = $el.find('.lslide').length - $el.find('.clone.left').length; m > $el.find('.lslide').length - tItem; m--) {
											$el.find('.lslide').eq(m - 1).clone().removeClass('lslide').addClass('clone left').prependTo($el);
										}

										$children = $el.children();
									} else {
										if ($children.hasClass('clone')) {
											$el.find('.clone').remove();
											$this.move($el, 0);
										}
									}
								};

								refresh.clone();
							}

							refresh.sSW = function () {
								length = $children.length;

								if (settings.rtl === true && settings.vertical === false) {
									gutter = 'margin-left';
								}

								if (settings.autoWidth === false) {
									$children.css(property, slideWidth + 'px');
								}

								$children.css(gutter, settings.slideMargin + 'px');
								w = refresh.calWidth(false);
								$el.css(property, w + 'px');

								if (settings.loop === true && settings.mode === 'slide') {
									if (on === false) {
										scene = $el.find('.clone.left').length;
									}
								}
							};

							refresh.calL = function () {
								$children = $el.children();
								length = $children.length;
							};

							if (this.doCss()) {
								$slide.addClass('usingCss');
							}

							refresh.calL();

							if (settings.mode === 'slide') {
								refresh.calSW();
								refresh.sSW();

								if (settings.loop === true) {
									slideValue = $this.slideValue();
									this.move($el, slideValue);
								}

								if (settings.vertical === false) {
									this.setHeight($el, false);
								}
							} else {
								this.setHeight($el, true);
								$el.addClass('lSFade');

								if (!this.doCss()) {
									$children.fadeOut(0);
									$children.eq(scene).fadeIn(0);
								}
							}

							if (settings.loop === true && settings.mode === 'slide') {
								$children.eq(scene).addClass('active');
							} else {
								$children.first().addClass('active');
							}
						},
						pager: function pager() {
							var $this = this;

							refresh.createPager = function () {
								thumbWidth = (elSize - (settings.thumbItem * settings.thumbMargin - settings.thumbMargin)) / settings.thumbItem;
								var $children = $slide.find('.lslide');
								var length = $slide.find('.lslide').length;
								var i = 0,
									pagers = '',
									v = 0;

								for (i = 0; i < length; i++) {
									if (settings.mode === 'slide') {
										// calculate scene * slide value
										if (!settings.autoWidth) {
											v = i * ((slideWidth + settings.slideMargin) * settings.slideMove);
										} else {
											v += (parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove;
										}
									}

									var thumb = $children.eq(i * settings.slideMove).attr('data-thumb');
									var modelData = "<div class='slide-data'>";
									modelData += $children.eq(i * settings.slideMove).find('.model-data').html();
									modelData += "</div>";

									if (settings.gallery === true) {
										pagers += '<li style="width:100%;' + property + ':' + thumbWidth + 'px;' + gutter + ':' + settings.thumbMargin + 'px"><a href="#"><img src="' + thumb + '" />' + modelData + '</a></li>';
									} else {
										pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
									}

									if (settings.mode === 'slide') {
										if (v >= w - elSize - settings.slideMargin) {
											i = i + 1;
											var minPgr = 2;

											if (settings.autoWidth) {
												pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
												minPgr = 1;
											}

											if (i < minPgr) {
												pagers = null;
												$slide.parent().addClass('noPager');
											} else {
												$slide.parent().removeClass('noPager');
											}

											break;
										}
									}
								}

								var $cSouter = $slide.parent();
								$cSouter.find('.lSPager').html(pagers);

								if (settings.gallery === true) {
									if (settings.vertical === true) {
										// set Gallery thumbnail width
										$cSouter.find('.lSPager').css('width', settings.vThumbWidth + 'px');
									}

									pagerWidth = i * (settings.thumbMargin + thumbWidth) + 0.5;
									$cSouter.find('.lSPager').css({
										property: pagerWidth + 'px',
										'transition-duration': settings.speed + 'ms'
									});

									if (settings.vertical === true) {
										$slide.parent().css('padding-right', settings.vThumbWidth + settings.galleryMargin + 'px');
									}

									$cSouter.find('.lSPager').css(property, pagerWidth + 'px');
								}

								var $pager = $cSouter.find('.lSPager').find('li');
								$pager.first().addClass('active');
								$pager.on('click', function () {
									if (settings.loop === true && settings.mode === 'slide') {
										scene = scene + ($pager.index(this) - $cSouter.find('.lSPager').find('li.active').index());
									} else {
										scene = $pager.index(this);
									}

									$el.mode(false);

									if (settings.gallery === true) {
										$this.slideThumb();
									}

									return false;
								});
							};

							if (settings.pager) {
								var cl = 'lSpg';

								if (settings.gallery) {
									cl = 'lSGallery';
								}

								$slide.after('<ul class="lSPager ' + cl + '"></ul>');
								var gMargin = settings.vertical ? 'margin-left' : 'margin-top';
								$slide.parent().find('.lSPager').css(gMargin, settings.galleryMargin + 'px');
								refresh.createPager();
							}

							setTimeout(function () {
								refresh.init();
							}, 0);
						},
						setHeight: function setHeight(ob, fade) {
							var obj = null,
								$this = this;

							if (settings.loop) {
								obj = ob.children('.lslide ').first();
							} else {
								obj = ob.children().first();
							}

							var setCss = function setCss() {
								var tH = obj.outerHeight(),
									tP = 0,
									tHT = tH;

								if (fade) {
									tH = 0;
									tP = tHT * 100 / elSize;
								}

								ob.css({
									'height': tH + 'px',
									'padding-bottom': tP + '%'
								});
							};

							setCss();

							if (obj.find('img').length) {
								if (obj.find('img')[0].complete) {
									setCss();

									if (!interval) {
										$this.auto();
									}
								} else {
									obj.find('img').on('load', function () {
										setTimeout(function () {
											setCss();

											if (!interval) {
												$this.auto();
											}
										}, 100);
									});
								}
							} else {
								if (!interval) {
									$this.auto();
								}
							}
						},
						active: function active(ob, t) {
							if (this.doCss() && settings.mode === 'fade') {
								$slide.addClass('on');
							}

							var sc = 0;

							if (scene * settings.slideMove < length) {
								ob.removeClass('active');

								if (!this.doCss() && settings.mode === 'fade' && t === false) {
									ob.fadeOut(settings.speed);
								}

								if (t === true) {
									sc = scene;
								} else {
									sc = scene * settings.slideMove;
								} //t === true ? sc = scene : sc = scene * settings.slideMove;


								var l, nl;

								if (t === true) {
									l = ob.length;
									nl = l - 1;

									if (sc + 1 >= l) {
										sc = nl;
									}
								}

								if (settings.loop === true && settings.mode === 'slide') {
									//t === true ? sc = scene - $el.find('.clone.left').length : sc = scene * settings.slideMove;
									if (t === true) {
										sc = scene - $el.find('.clone.left').length;
									} else {
										sc = scene * settings.slideMove;
									}

									if (t === true) {
										l = ob.length;
										nl = l - 1;

										if (sc + 1 === l) {
											sc = nl;
										} else if (sc + 1 > l) {
											sc = 0;
										}
									}
								}

								if (!this.doCss() && settings.mode === 'fade' && t === false) {
									ob.eq(sc).fadeIn(settings.speed);
								}

								ob.eq(sc).addClass('active');
							} else {
								ob.removeClass('active');
								ob.eq(ob.length - 1).addClass('active');

								if (!this.doCss() && settings.mode === 'fade' && t === false) {
									ob.fadeOut(settings.speed);
									ob.eq(sc).fadeIn(settings.speed);
								}
							}
						},
						move: function move(ob, v) {
							if (settings.rtl === true) {
								v = -v;
							}

							if (this.doCss()) {
								if (settings.vertical === true) {
									ob.css({
										'transform': 'translate3d(0px, ' + -v + 'px, 0px)',
										'-webkit-transform': 'translate3d(0px, ' + -v + 'px, 0px)'
									});
								} else {
									ob.css({
										'transform': 'translate3d(' + -v + 'px, 0px, 0px)',
										'-webkit-transform': 'translate3d(' + -v + 'px, 0px, 0px)'
									});
								}
							} else {
								if (settings.vertical === true) {
									ob.css('position', 'relative').animate({
										top: -v + 'px'
									}, settings.speed, settings.easing);
								} else {
									ob.css('position', 'relative').animate({
										left: -v + 'px'
									}, settings.speed, settings.easing);
								}
							}

							var $thumb = $slide.parent().find('.lSPager').find('li');
							this.active($thumb, true);
						},
						fade: function fade() {
							this.active($children, false);
							var $thumb = $slide.parent().find('.lSPager').find('li');
							this.active($thumb, true);
						},
						slide: function slide() {
							var $this = this;

							refresh.calSlide = function () {
								if (w > elSize) {
									slideValue = $this.slideValue();
									$this.active($children, false);

									if (slideValue > w - elSize - settings.slideMargin) {
										slideValue = w - elSize - settings.slideMargin;
									} else if (slideValue < 0) {
										slideValue = 0;
									}

									$this.move($el, slideValue);

									if (settings.loop === true && settings.mode === 'slide') {
										if (scene >= length - $el.find('.clone.left').length / settings.slideMove) {
											$this.resetSlide($el.find('.clone.left').length);
										}

										if (scene === 0) {
											$this.resetSlide($slide.find('.lslide').length);
										}
									}
								}
							};

							refresh.calSlide();
						},
						resetSlide: function resetSlide(s) {
							var $this = this;
							$slide.find('.lSAction a').addClass('disabled');
							setTimeout(function () {
								scene = s;
								$slide.css('transition-duration', '0ms');
								slideValue = $this.slideValue();
								$this.active($children, false);
								plugin.move($el, slideValue);
								setTimeout(function () {
									$slide.css('transition-duration', settings.speed + 'ms');
									$slide.find('.lSAction a').removeClass('disabled');
								}, 50);
							}, settings.speed + 100);
						},
						slideValue: function slideValue() {
							var _sV = 0;

							if (settings.autoWidth === false) {
								_sV = scene * ((slideWidth + settings.slideMargin) * settings.slideMove);
							} else {
								_sV = 0;

								for (var i = 0; i < scene; i++) {
									_sV += parseInt($children.eq(i).width()) + settings.slideMargin;
								}
							}

							return _sV;
						},
						slideThumb: function slideThumb() {
							var position;

							switch (settings.currentPagerPosition) {
								case 'left':
									position = 0;
									break;

								case 'middle':
									position = elSize / 2 - thumbWidth / 2;
									break;

								case 'right':
									position = elSize - thumbWidth;
							}

							var sc = scene - $el.find('.clone.left').length;
							var $pager = $slide.parent().find('.lSPager');

							if (settings.mode === 'slide' && settings.loop === true) {
								if (sc >= $pager.children().length) {
									sc = 0;
								} else if (sc < 0) {
									sc = $pager.children().length;
								}
							}

							var thumbSlide = sc * (thumbWidth + settings.thumbMargin) - position;

							if (thumbSlide + elSize > pagerWidth) {
								thumbSlide = pagerWidth - elSize - settings.thumbMargin;
							}

							if (thumbSlide < 0) {
								thumbSlide = 0;
							}

							this.move($pager, thumbSlide);
						},
						auto: function auto() {
							if (settings.auto) {
								clearInterval(interval);
								interval = setInterval(function () {
									$el.goToNextSlide();
								}, settings.pause);
							}
						},
						pauseOnHover: function pauseOnHover() {
							var $this = this;

							if (settings.auto && settings.pauseOnHover) {
								$slide.on('mouseenter', function () {
									$(this).addClass('ls-hover');
									$el.pause();
									settings.auto = true;
								});
								$slide.on('mouseleave', function () {
									$(this).removeClass('ls-hover');

									if (!$slide.find('.lightSlider').hasClass('lsGrabbing')) {
										$this.auto();
									}
								});
							}
						},
						touchMove: function touchMove(endCoords, startCoords) {
							$slide.css('transition-duration', '0ms');

							if (settings.mode === 'slide') {
								var distance = endCoords - startCoords;
								var swipeVal = slideValue - distance;

								if (swipeVal >= w - elSize - settings.slideMargin) {
									if (settings.freeMove === false) {
										swipeVal = w - elSize - settings.slideMargin;
									} else {
										var swipeValT = w - elSize - settings.slideMargin;
										swipeVal = swipeValT + (swipeVal - swipeValT) / 5;
									}
								} else if (swipeVal < 0) {
									if (settings.freeMove === false) {
										swipeVal = 0;
									} else {
										swipeVal = swipeVal / 5;
									}
								}

								this.move($el, swipeVal);
							}
						},
						touchEnd: function touchEnd(distance) {
							$slide.css('transition-duration', settings.speed + 'ms');

							if (settings.mode === 'slide') {
								var mxVal = false;
								var _next = true;
								slideValue = slideValue - distance;

								if (slideValue > w - elSize - settings.slideMargin) {
									slideValue = w - elSize - settings.slideMargin;

									if (settings.autoWidth === false) {
										mxVal = true;
									}
								} else if (slideValue < 0) {
									slideValue = 0;
								}

								var gC = function gC(next) {
									var ad = 0;

									if (!mxVal) {
										if (next) {
											ad = 1;
										}
									}

									if (!settings.autoWidth) {
										var num = slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove);
										scene = parseInt(num) + ad;

										if (slideValue >= w - elSize - settings.slideMargin) {
											if (num % 1 !== 0) {
												scene++;
											}
										}
									} else {
										var tW = 0;

										for (var i = 0; i < $children.length; i++) {
											tW += parseInt($children.eq(i).width()) + settings.slideMargin;
											scene = i + ad;

											if (tW >= slideValue) {
												break;
											}
										}
									}
								};

								if (distance >= settings.swipeThreshold) {
									gC(false);
									_next = false;
								} else if (distance <= -settings.swipeThreshold) {
									gC(true);
									_next = false;
								}

								$el.mode(_next);
								this.slideThumb();
							} else {
								if (distance >= settings.swipeThreshold) {
									$el.goToPrevSlide();
								} else if (distance <= -settings.swipeThreshold) {
									$el.goToNextSlide();
								}
							}
						},
						enableDrag: function enableDrag() {
							var $this = this;

							if (!isTouch) {
								var startCoords = 0,
									endCoords = 0,
									isDraging = false;
								$slide.find('.lightSlider').addClass('lsGrab');
								$slide.on('mousedown', function (e) {
									if (w < elSize) {
										if (w !== 0) {
											return false;
										}
									}

									if ($(e.target).attr('class') !== 'lSPrev' && $(e.target).attr('class') !== 'lSNext') {
										startCoords = settings.vertical === true ? e.pageY : e.pageX;
										isDraging = true;

										if (e.preventDefault) {
											e.preventDefault();
										} else {
											e.returnValue = false;
										} // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723


										$slide.scrollLeft += 1;
										$slide.scrollLeft -= 1; // *

										$slide.find('.lightSlider').removeClass('lsGrab').addClass('lsGrabbing');
										clearInterval(interval);
									}
								});
								$(window).on('mousemove', function (e) {
									if (isDraging) {
										endCoords = settings.vertical === true ? e.pageY : e.pageX;
										$this.touchMove(endCoords, startCoords);
									}
								});
								$(window).on('mouseup', function (e) {
									if (isDraging) {
										$slide.find('.lightSlider').removeClass('lsGrabbing').addClass('lsGrab');
										isDraging = false;
										endCoords = settings.vertical === true ? e.pageY : e.pageX;
										var distance = endCoords - startCoords;

										if (Math.abs(distance) >= settings.swipeThreshold) {
											$(window).on('click.ls', function (e) {
												if (e.preventDefault) {
													e.preventDefault();
												} else {
													e.returnValue = false;
												}

												e.stopImmediatePropagation();
												e.stopPropagation();
												$(window).off('click.ls');
											});
										}

										$this.touchEnd(distance);
									}
								});
							}
						},
						enableTouch: function enableTouch() {
							var $this = this;

							if (isTouch) {
								var startCoords = {},
									endCoords = {};
								$slide.on('touchstart', function (e) {
									endCoords = e.originalEvent.targetTouches[0];
									startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
									startCoords.pageY = e.originalEvent.targetTouches[0].pageY;
									clearInterval(interval);
								});
								$slide.on('touchmove', function (e) {
									if (w < elSize) {
										if (w !== 0) {
											return false;
										}
									}

									var orig = e.originalEvent;
									endCoords = orig.targetTouches[0];
									var xMovement = Math.abs(endCoords.pageX - startCoords.pageX);
									var yMovement = Math.abs(endCoords.pageY - startCoords.pageY);

									if (settings.vertical === true) {
										if (yMovement * 3 > xMovement) {
											e.preventDefault();
										}

										$this.touchMove(endCoords.pageY, startCoords.pageY);
									} else {
										if (xMovement * 3 > yMovement) {
											e.preventDefault();
										}

										$this.touchMove(endCoords.pageX, startCoords.pageX);
									}
								});
								$slide.on('touchend', function () {
									if (w < elSize) {
										if (w !== 0) {
											return false;
										}
									}

									var distance;

									if (settings.vertical === true) {
										distance = endCoords.pageY - startCoords.pageY;
									} else {
										distance = endCoords.pageX - startCoords.pageX;
									}

									$this.touchEnd(distance);
								});
							}
						},
						build: function build() {
							var $this = this;
							$this.initialStyle();

							if (this.doCss()) {
								if (settings.enableTouch === true) {
									$this.enableTouch();
								}

								if (settings.enableDrag === true) {
									$this.enableDrag();
								}
							}

							$(window).on('focus', function () {
								$this.auto();
							});
							$(window).on('blur', function () {
								clearInterval(interval);
							});
							$this.pager();
							$this.pauseOnHover();
							$this.controls();
							$this.keyPress();
						}
					};
					plugin.build();

					refresh.init = function () {
						refresh.chbreakpoint();

						if (settings.vertical === true) {
							if (settings.item > 1) {
								elSize = settings.verticalHeight;
							} else {
								elSize = $children.outerHeight();
							}

							$slide.css('height', elSize + 'px');
						} else {
							elSize = $slide.outerWidth();
						}

						if (settings.loop === true && settings.mode === 'slide') {
							refresh.clone();
						}

						refresh.calL();

						if (settings.mode === 'slide') {
							$el.removeClass('lSSlide');
						}

						if (settings.mode === 'slide') {
							refresh.calSW();
							refresh.sSW();
						}

						setTimeout(function () {
							if (settings.mode === 'slide') {
								$el.addClass('lSSlide');
							}
						}, 1000);

						if (settings.pager) {
							refresh.createPager();
						}

						if (settings.adaptiveHeight === true && settings.vertical === false) {
							$el.css('height', $children.eq(scene).outerHeight(true));
						}

						if (settings.adaptiveHeight === false) {
							if (settings.mode === 'slide') {
								if (settings.vertical === false) {
									plugin.setHeight($el, false);
								} else {
									plugin.auto();
								}
							} else {
								plugin.setHeight($el, true);
							}
						}

						if (settings.gallery === true) {
							plugin.slideThumb();
						}

						if (settings.mode === 'slide') {
							plugin.slide();
						}

						if (settings.autoWidth === false) {
							if ($children.length <= settings.item) {
								$slide.find('.lSAction').hide();
							} else {
								$slide.find('.lSAction').show();
							}
						} else {
							if (refresh.calWidth(false) < elSize && w !== 0) {
								$slide.find('.lSAction').hide();
							} else {
								$slide.find('.lSAction').show();
							}
						}
					};

					$el.goToPrevSlide = function () {
						if (scene > 0) {
							settings.onBeforePrevSlide.call(this, $el, scene);
							scene--;
							$el.mode(false);

							if (settings.gallery === true) {
								plugin.slideThumb();
							}
						} else {
							if (settings.loop === true) {
								settings.onBeforePrevSlide.call(this, $el, scene);

								if (settings.mode === 'fade') {
									var l = length - 1;
									scene = parseInt(l / settings.slideMove);
								}

								$el.mode(false);

								if (settings.gallery === true) {
									plugin.slideThumb();
								}
							} else if (settings.slideEndAnimation === true) {
								$el.addClass('leftEnd');
								setTimeout(function () {
									$el.removeClass('leftEnd');
								}, 400);
							}
						}
					};

					$el.goToNextSlide = function () {
						var nextI = true;

						if (settings.mode === 'slide') {
							var _slideValue = plugin.slideValue();

							nextI = _slideValue < w - elSize - settings.slideMargin;
						}

						if (scene * settings.slideMove < length - settings.slideMove && nextI) {
							settings.onBeforeNextSlide.call(this, $el, scene);
							scene++;
							$el.mode(false);

							if (settings.gallery === true) {
								plugin.slideThumb();
							}
						} else {
							if (settings.loop === true) {
								settings.onBeforeNextSlide.call(this, $el, scene);
								scene = 0;
								$el.mode(false);

								if (settings.gallery === true) {
									plugin.slideThumb();
								}
							} else if (settings.slideEndAnimation === true) {
								$el.addClass('rightEnd');
								setTimeout(function () {
									$el.removeClass('rightEnd');
								}, 400);
							}
						}
					};

					$el.mode = function (_touch) {
						if (settings.adaptiveHeight === true && settings.vertical === false) {
							$el.css('height', $children.eq(scene).outerHeight(true));
						}

						if (on === false) {
							if (settings.mode === 'slide') {
								if (plugin.doCss()) {
									$el.addClass('lSSlide');

									if (settings.speed !== '') {
										$slide.css('transition-duration', settings.speed + 'ms');
									}

									if (settings.cssEasing !== '') {
										$slide.css('transition-timing-function', settings.cssEasing);
									}
								}
							} else {
								if (plugin.doCss()) {
									if (settings.speed !== '') {
										$el.css('transition-duration', settings.speed + 'ms');
									}

									if (settings.cssEasing !== '') {
										$el.css('transition-timing-function', settings.cssEasing);
									}
								}
							}
						}

						if (!_touch) {
							settings.onBeforeSlide.call(this, $el, scene);
						}

						if (settings.mode === 'slide') {
							plugin.slide();
						} else {
							plugin.fade();
						}

						if (!$slide.hasClass('ls-hover')) {
							plugin.auto();
						}

						setTimeout(function () {
							if (!_touch) {
								settings.onAfterSlide.call(this, $el, scene);
							}
						}, settings.speed);
						on = true;
					};

					$el.play = function () {
						$el.goToNextSlide();
						settings.auto = true;
						plugin.auto();
					};

					$el.pause = function () {
						settings.auto = false;
						clearInterval(interval);
					};

					$el.refresh = function () {
						refresh.init();
					};

					$el.getCurrentSlideCount = function () {
						var sc = scene;

						if (settings.loop) {
							var ln = $slide.find('.lslide').length,
								cl = $el.find('.clone.left').length;

							if (scene <= cl - 1) {
								sc = ln + (scene - cl);
							} else if (scene >= ln + cl) {
								sc = scene - ln - cl;
							} else {
								sc = scene - cl;
							}
						}

						return sc + 1;
					};

					$el.getTotalSlideCount = function () {
						return $slide.find('.lslide').length;
					};

					$el.goToSlide = function (s) {
						if (settings.loop) {
							scene = s + $el.find('.clone.left').length - 1;
						} else {
							scene = s;
						}

						$el.mode(false);

						if (settings.gallery === true) {
							plugin.slideThumb();
						}
					};

					$el.destroy = function () {
						if ($el.lightSlider) {
							$el.goToPrevSlide = function () { };

							$el.goToNextSlide = function () { };

							$el.mode = function () { };

							$el.play = function () { };

							$el.pause = function () { };

							$el.refresh = function () { };

							$el.getCurrentSlideCount = function () { };

							$el.getTotalSlideCount = function () { };

							$el.goToSlide = function () { };

							$el.lightSlider = null;
							refresh = {
								init: function init() { }
							};
							$el.parent().parent().find('.lSAction, .lSPager').remove();
							$el.removeClass('lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right').removeAttr('style').unwrap().unwrap();
							$el.children().removeAttr('style');
							$children.removeClass('lslide active');
							$el.find('.clone').remove();
							$children = null;
							interval = null;
							on = false;
							scene = 0;
						}
					};

					setTimeout(function () {
						settings.onSliderLoad.call(this, $el);
					}, 10);
					$(window).on('resize orientationchange', function (e) {
						setTimeout(function () {
							if (e.preventDefault) {
								e.preventDefault();
							} else {
								e.returnValue = false;
							}

							refresh.init();
						}, 200);
					});
					return this;
				};
			})(jQuery);

			/***/
		}),

/***/ "./src/assets/js/libs/slick-animation.js":
/*!***********************************************!*\
  !*** ./src/assets/js/libs/slick-animation.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2__);




			/*
			 slick-animation.js
			 Version: 0.3.3 Beta
			 Author: Marvin Hbner
			 Docs: https://github.com/marvinhuebner/slick-animation
			 Repo: https://github.com/marvinhuebner/slick-animation
			 */
			!function (a) {
				a.fn.slickAnimation = function () {
					function n(a, n, t, i, o) {
						o = "undefined" != typeof o ? o : !1, 1 == n.opacity ? (a.addClass(t), a.addClass(i)) : (a.removeClass(t), a.removeClass(i)), o && a.css(n);
					}

					function t(a, n) {
						return a ? 1e3 * a + 1e3 : n ? 1e3 * n : a || n ? 1e3 * a + 1e3 * n : 1e3;
					}

					function i(a, n, t) {
						var i = ["animation-" + n, "-webkit-animation-" + n, "-moz-animation-" + n, "-o-animation-" + n, "-ms-animation-" + n],
							o = {};
						i.forEach(function (a) {
							o[a] = t + "s";
						}), a.css(o);
					}

					var o = a(this),
						e = o.find(".slick-list .slick-track > div"),
						s = o.find('[data-slick-index="0"]'),
						r = "animated",
						c = {
							opacity: "1"
						},
						d = {
							opacity: "0"
						};
					return e.each(function () {
						var e = a(this);
						e.find("[data-animation-in]").each(function () {
							var u = a(this);
							u.css(d);
							var l = u.attr("data-animation-in"),
								f = u.attr("data-animation-out"),
								h = u.attr("data-delay-in"),
								m = u.attr("data-duration-in"),
								y = u.attr("data-delay-out"),
								C = u.attr("data-duration-out");
							f ? (s.length > 0 && e.hasClass("slick-current") && (n(u, c, l, r, !0), h && i(u, "delay", h), m && i(u, "duration", m), setTimeout(function () {
								n(u, d, l, r), n(u, c, f, r), y && i(u, "delay", y), C && i(u, "duration", C);
							}, t(h, m))), o.on("afterChange", function (a, o, s) {
								e.hasClass("slick-current") && (n(u, c, l, r, !0), h && i(u, "delay", h), m && i(u, "duration", m), setTimeout(function () {
									n(u, d, l, r), n(u, c, f, r), y && i(u, "delay", y), C && i(u, "duration", C);
								}, t(h, m)));
							}), o.on("beforeChange", function (a, t, i) {
								n(u, d, f, r, !0);
							})) : (s.length > 0 && e.hasClass("slick-current") && (n(u, c, l, r, !0), h && i(u, "delay", h), m && i(u, "duration", m)), o.on("afterChange", function (a, t, o) {
								e.hasClass("slick-current") && (n(u, c, l, r, !0), h && i(u, "delay", h), m && i(u, "duration", m));
							}), o.on("beforeChange", function (a, t, i) {
								n(u, d, l, r, !0);
							}));
						});
					}), this;
				};
			}(jQuery);

			/***/
		}),

/***/ "./src/assets/js/modules/accordion-module.js":
/*!***************************************************!*\
  !*** ./src/assets/js/modules/accordion-module.js ***!
  \***************************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
			// Open N tab by default


			$(".project-accordion li:nth-child(4) .toggle").toggleClass("active");
			$(".project-accordion li:nth-child(4) .inner").toggleClass("show").slideToggle(350); // wrap all .inner > p in div

			$(".project-accordion > li").each(function () {
				$(this).find(".inner p").wrapAll("<div class='accordion-paragraphs-wrapper'></div>");
			}); // Accordion tabs

			$(".toggle").click(function (e) {
				e.preventDefault();
				var $this = $(this);

				if ($this.next().hasClass("show")) {
					$this.next().removeClass("show");
					$this.next().slideUp(350);
				} else {
					$this.parent().parent().find("li .inner").removeClass("show");
					$this.parent().parent().find("li .inner").slideUp(350);
					$this.next().toggleClass("show");
					$this.next().slideToggle(350);
				}

				$(this).toggleClass("active");
			});

			/***/
		}),

/***/ "./src/assets/js/modules/carousel-module.js":
/*!**************************************************!*\
  !*** ./src/assets/js/modules/carousel-module.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_4__);







			var lightSlider = __webpack_require__(/*! ./../libs/lightslider */ "./src/assets/js/libs/lightslider.js");

			__webpack_require__(/*! jquerykeyframes */ "./node_modules/jquerykeyframes/dist/jquery.keyframes.min.js");



			__webpack_require__(/*! ../libs/slick-animation */ "./src/assets/js/libs/slick-animation.js");

			var owl_carousel = __webpack_require__(/*! owl.carousel */ "./node_modules/owl.carousel/dist/owl.carousel.js");

			window.fn = owl_carousel; // new-arrivals widget

			jquery__WEBPACK_IMPORTED_MODULE_2___default()(".new-arrivals-slider").slick({
				//infinite: true,
				slidesToShow: 3,
				slidesToScroll: 1,
				arrows: false,
				//autoplay: true,
				autoplaySpeed: 5000,
				responsive: [{
					breakpoint: 768,
					settings: {
						slidesToShow: 1,
						slidesToScroll: 1
					}
				}, {
					breakpoint: 992,
					settings: {
						slidesToShow: 2,
						slidesToScroll: 1
					}
				}, {
					breakpoint: 1200,
					settings: {
						slidesToShow: 2,
						slidesToScroll: 1
					}
				}]
			}); // car presentation widget

			jquery__WEBPACK_IMPORTED_MODULE_2___default()(".car-presentation-slider").on("init", function (event, slick) {
				var dots = jquery__WEBPACK_IMPORTED_MODULE_2___default()(".slick-dots li");
				dots.each(function (k, v) {
					// add animations to menu item
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).addClass("wow fadeInUp").attr("data-wow-delay", "".concat(k + 1, "00ms"));
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).find("button").addClass("dots-text" + k);
				});
				var items = slick.$slides;
				items.each(function (k, v) {
					var text = jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).find(".slide__item").attr("data-brand");
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".dots-text" + k).text(text);
				});
			});
			jquery__WEBPACK_IMPORTED_MODULE_2___default()(".car-presentation-slider").slick({
				dots: true,
				focusOnSelect: true,
				infinite: true,
				arrows: false,
				speed: 300,
				slidesToShow: 1
			}); // content preview slider widget

			if (jquery__WEBPACK_IMPORTED_MODULE_2___default()(".content__preview__slider").length) {
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".content__preview__slider").slick({
					autoplay: false,
					speed: 800,
					lazyLoad: "progressive",
					arrows: false,
					dots: true
				}).slickAnimation();
			}

			jquery__WEBPACK_IMPORTED_MODULE_2___default.a.keyframe.define([{
				name: "slideLoading",
				"0%": {
					height: "0"
				},
				"100%": {
					height: "100%"
				}
			}]); // carousel at testimonials widget

			jquery__WEBPACK_IMPORTED_MODULE_2___default()(".testimonials-box").owlCarousel({
				loop: false,
				dots: true,
				items: 1,
				autoplay: false,
				autoplayTimeout: 10000,
				autoplayHoverPause: true,
				nav: false,
				navText: ['<svg width="14" height="24" viewBox="0 0 24 24"><path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"/></svg>', '<svg width="14" height="24" viewBox="0 0 24 24"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"/></svg>'
					/* icons from https://iconmonstr.com */
				]
			}); // colors carousel model builder widget

			jquery__WEBPACK_IMPORTED_MODULE_2___default()(".color-filter").owlCarousel({
				loop: false,
				dots: false,
				autoplay: false,
				autoplayTimeout: 10000,
				autoplayHoverPause: true,
				nav: true,
				navText: ['<svg width="14" height="23" viewBox="0 0 24 24"><path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"/></svg>', '<svg width="14" height="23" viewBox="0 0 24 24"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"/></svg>'
					/* icons from https://iconmonstr.com */
				],
				responsive: {
					320: {
						items: 3
					},
					375: {
						items: 4
					},
					575: {
						items: 5
					},
					768: {
						items: 5
					},
					992: {
						items: 3
					},
					1100: {
						items: 4
					},
					1200: {
						items: 4
					},
					1440: {
						items: 4
					},
					1780: {
						items: 5
					}
				}
			}); // init Slider for new model widget

			if (jquery__WEBPACK_IMPORTED_MODULE_2___default()("#new-model-vertical-list").length) {
				var container = jquery__WEBPACK_IMPORTED_MODULE_2___default()("#new-model-vertical-list");
				container.imagesLoaded(function () {
					// new models slider at model page, use lightslider
					jquery__WEBPACK_IMPORTED_MODULE_2___default()("#new-model-vertical-list").lightSlider({
						gallery: true,
						item: 1,
						vertical: true,
						verticalHeight: 131,
						vThumbWidth: 195,
						thumbItem: 4,
						thumbMargin: 10,
						slideMargin: 0,
						controls: false,
						auto: true,
						pause: 15000
					});
				});
			} // init Owl Carousel full width slider

			/*JS way for setting height: 100vh to slides' height*/
			// const $slides = $(".owl-carousel .owl-slide");
			// $slides.css("height", $(window).height());
			// $(window).resize(() => {
			//   $slides.css("height", $(window).height());
			// });


			jquery__WEBPACK_IMPORTED_MODULE_2___default()("#header-slide").on("initialized.owl.carousel", function () {
				setTimeout(function () {
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".owl-item.active .owl-slide-animated").addClass("is-transitioned");
					jquery__WEBPACK_IMPORTED_MODULE_2___default()("section").show();
				}, 200);
			});
			var owlCarousel = jquery__WEBPACK_IMPORTED_MODULE_2___default()("#header-slide").owlCarousel({
				items: 1,
				loop: false,
				nav: true,
				dots: true,
				autoplay: false,
				autoplayTimeout: 10000,
				autoplayHoverPause: true,
				navText: ['<svg width="15" height="24" viewBox="0 0 24 24"><path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"/></svg>', '<svg width="15" height="24" viewBox="0 0 24 24"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"/></svg>'
					/* icons from https://iconmonstr.com */
				]
			});
			owlCarousel.on("changed.owl.carousel", function (e) {
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".owl-slide-animated").removeClass("is-transitioned");
				var currentOwlItem = jquery__WEBPACK_IMPORTED_MODULE_2___default()(".owl-item").eq(e.item.index);
				currentOwlItem.find(".owl-slide-animated").addClass("is-transitioned");
			});
			/*if there isn't content underneath the carousel*/

			owlCarousel.trigger("refresh.owl.carousel"); // Start models slider

			jquery__WEBPACK_IMPORTED_MODULE_2___default()("#models-slider").owlCarousel({
				loop: true,
				dots: false,
				items: 1,
				autoplay: false,
				autoplayTimeout: 10000,
				autoplayHoverPause: true,
				nav: true,
				navText: ['<svg width="16" height="26" viewBox="0 0 24 24"><path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"/></svg>', '<svg width="16" height="26" viewBox="0 0 24 24"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"/></svg>'
					/* icons from https://iconmonstr.com */
				],
				responsive: {
					575: {
						items: 1
					},
					768: {
						items: 2,
						margin: 40
					},
					992: {
						items: 2,
						margin: 40
					},
					1200: {
						items: 3,
						margin: 40
					},
					1440: {
						items: 3,
						margin: 65
					}
				}
			}); // enable owl-nav fix

			jquery__WEBPACK_IMPORTED_MODULE_2___default()("#models-slider").find(".owl-nav").removeClass("disabled");
			jquery__WEBPACK_IMPORTED_MODULE_2___default()("#models-slider").on("changed.owl.carousel", function (event) {
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).find(".owl-nav").removeClass("disabled");
			}); // models slider, enable hover effect at screens bigger 992px

			if (window.matchMedia("(min-width: 992px)").matches) {
				//models slider model detail box showing
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".models-slider a").hover(function () {
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).find(".model-details").fadeIn();
				}, function () {
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).find(".model-details").fadeOut();
				});
			}
			/* ==========================
					Start Members slider section
					============================*/
			// members slider var inits


			var membersSlider = jquery__WEBPACK_IMPORTED_MODULE_2___default()(".members-slider"),
				membersSliderTimeIteration = 20000,
				membersSliderOptions = {
					center: true,
					autoWidth: false,
					stagePadding: 0,
					loop: true,
					margin: 25,
					items: 1,
					navigation: false,
					mouseDrag: false,
					autoplay: true,
					// customer can enable of disable autoplay, default enable
					autoplayTimeout: membersSliderTimeIteration,
					// customer can change value of it, default 5s,
					autoplayHoverPause: true,
					nav: false,
					dots: false,
					onInitialized: function onInitialized() {
						// enable slider line animation
						if (membersSliderOptions.autoplay == true) {
							jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").addClass("active-slide");
							jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").playKeyframe({
								name: "slideLoading",
								duration: membersSliderTimeIteration + "ms",
								timingFunction: "linear",
								iterationCount: "infinite",
								direction: "normal",
								fillMode: "forwards",
								complete: function complete() {
									jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").removeClass("active-slide");
								}
							});
						} // check classes


						checkClasses(); // set new info about member

						showMemberInfo(); // init conuter helper

						counter;
					},
					onChanged: counter,
					responsive: {
						620: {
							items: 3,
							margin: 15
						},
						768: {
							items: 3,
							margin: 15
						},
						992: {
							items: 3
						},
						1200: {
							items: 3
						}
					}
				}; // init members slider

			membersSlider.owlCarousel(membersSliderOptions); // marked first and last slides

			function checkClasses() {
				var total = jquery__WEBPACK_IMPORTED_MODULE_2___default()(".members-slider .owl-stage .owl-item.active").length;
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".members-slider .owl-stage .owl-item").removeClass("firstActiveItem lastActiveItem");
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".members-slider .owl-stage .owl-item.active").each(function (index) {
					if (index === 0) {
						// this is the first one
						jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).addClass("firstActiveItem");
					}

					if (index === total - 1 && total > 1) {
						// this is the last one
						jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).addClass("lastActiveItem");
					}
				});
			} // show member hidden info


			function showMemberInfo() {
				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".member-details").html("");

				if (window.matchMedia("(max-width: 574px)").matches) {
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".member-details").append(jquery__WEBPACK_IMPORTED_MODULE_2___default()(".center .hidden-data").html());
				} else {
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".member-details").append(jquery__WEBPACK_IMPORTED_MODULE_2___default()(".lastActiveItem .hidden-data").html());
				}
			} // owl event after slider translated


			membersSlider.on("translated.owl.carousel", function (event) {
				checkClasses();
				showMemberInfo();
			}); // Members slider line animation, work only slider param `autoplay`: true

			if (membersSliderOptions.autoplay == true) {
				membersSlider.on("translated.owl.carousel", function (event) {
					// enable slider line animation
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").addClass("active-slide");
					jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").playKeyframe({
						name: "slideLoading",
						duration: membersSliderTimeIteration + "ms",
						timingFunction: "ease",
						iterationCount: "infinite",
						direction: "normal",
						fillMode: "forwards",
						complete: function complete() {
							jquery__WEBPACK_IMPORTED_MODULE_2___default()(".separator > span").removeClass("active-slide");
						}
					});
				});
			} // event click next slide


			jquery__WEBPACK_IMPORTED_MODULE_2___default()(document).on("click", "#next-slide", function () {
				membersSlider.trigger("next.owl.carousel");
			}); // event click prev slide

			jquery__WEBPACK_IMPORTED_MODULE_2___default()(document).on("click", "#prev-slide", function () {
				membersSlider.trigger("prev.owl.carousel");
			}); // slider counter

			function counter(event) {
				var element = event.target; // DOM element, in this example .owl-carousel

				var items = event.item.count; // Number of items

				var item = event.item.index + 1; // Position of the current item
				// it loop is true then reset counter from 1

				if (item > items) {
					item = item - items;
				}

				jquery__WEBPACK_IMPORTED_MODULE_2___default()(".current-slide-number").html(("0" + item).slice(-2));
			}
			/* ==========================
					End Members slider section
					============================*/

			/***/
		}),

/***/ "./src/assets/js/modules/masonry-grid-module.js":
/*!******************************************************!*\
  !*** ./src/assets/js/modules/masonry-grid-module.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_bridget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-bridget */ "./node_modules/jquery-bridget/jquery-bridget.js");
/* harmony import */ var jquery_bridget__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_bridget__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var masonry_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! masonry-layout */ "./node_modules/masonry-layout/masonry.js");
/* harmony import */ var masonry_layout__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(masonry_layout__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_3__);






			jquery_bridget__WEBPACK_IMPORTED_MODULE_1___default()("masonry", masonry_layout__WEBPACK_IMPORTED_MODULE_2___default.a, jquery__WEBPACK_IMPORTED_MODULE_0___default.a);
			jquery_bridget__WEBPACK_IMPORTED_MODULE_1___default()("imagesLoaded", imagesloaded__WEBPACK_IMPORTED_MODULE_3___default.a, jquery__WEBPACK_IMPORTED_MODULE_0___default.a);

			if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(".advantages-box").length) {
				var container = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".advantages-box");
				container.imagesLoaded(function () {
					container.masonry({
						itemSelector: ".grid-item",
						columnWidth: 1,
						horizontalOrder: true
					});
				});
			} // init masonry grid models gallery


			if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(".project-gallery").length) {
				var container = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".project-gallery");
				container.imagesLoaded(function () {
					container.masonry({
						columnWidth: ".grid-sizer",
						itemSelector: ".grid-item",
						gutter: ".gutter-sizer",
						percentPosition: true
					});
				});
			} // init masonry grid blog posts


			if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(".posts-masonry").length) {
				var container = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".posts-masonry");
				container.imagesLoaded(function () {
					container.masonry({
						columnWidth: ".grid-sizer",
						itemSelector: ".grid-item",
						gutter: ".gutter-sizer",
						percentPosition: true
					});
				});
			}

			/***/
		}),

/***/ "./src/assets/js/modules/nav-module.js":
/*!*********************************************!*\
  !*** ./src/assets/js/modules/nav-module.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);




			var Moby = function Moby(a) {
				Moby.instances++;
				this.breakpoint = "undefined" == typeof a.breakpoint ? 1024 : a.breakpoint;
				this.enableEscape = "undefined" == typeof a.enableEscape || a.enableEscape;
				this.menu = "undefined" == typeof a.menu ? $("#main-nav") : a.menu;
				this.menuClass = "undefined" == typeof a.menuClass ? "right-side" : a.menuClass;
				this.mobyTrigger = "undefined" == typeof a.mobyTrigger ? $("#moby-button") : a.mobyTrigger;
				this.onClose = "undefined" != typeof a.onClose && a.onClose;
				this.onOpen = "undefined" != typeof a.onOpen && a.onOpen;
				this.overlay = "undefined" == typeof a.overlay || a.overlay;
				this.overlayClass = "undefined" == typeof a.overlayClass ? "dark" : a.overlayClass;
				this.subMenuOpenIcon = "undefined" == typeof a.subMenuOpenIcon ? "<span>&#x25BC;</span>" : a.subMenuOpenIcon;
				this.subMenuCloseIcon = "undefined" == typeof a.subMenuCloseIcon ? "<span>&#x25B2;</span>" : a.subMenuCloseIcon;
				this.template = "undefined" != typeof a.template && a.template;

				if (this.overlay === !0) {
					$("body").prepend('<div class="moby-overlay ' + this.overlayClass + '" id="moby-overlay' + Moby.instances + '"></div>');
					this.overlaySelector = $("body").find("#moby-overlay" + Moby.instances);
					this.overlaySelector.on("click", this.closeMoby.bind(this));
				}

				$("body").prepend('<div class="moby moby-hidden ' + this.menuClass + '" id="moby' + Moby.instances + '"></div>');
				this.mobySelector = $("body").find("#moby" + Moby.instances);
				this.cloneMenu();
				this.mobySelector.on("click", ".moby-close", this.closeMoby.bind(this));
				this.enableEscape === !0 && $(document).on("keydown", function (a) {
					27 == a.keyCode && this.closeMoby();
				}.bind(this));
				this.mobyTrigger.on("click", this.openMoby.bind(this));
				$(window).on("resize", this.breakpointResize.bind(this));
				this.mobySelector.on("click", ".moby-expand", function (a) {
					a.preventDefault();
					a.stopPropagation();
					this.mobyExpandSubMenu($(a.currentTarget));
				}.bind(this));
				this.mobySelector.on("click", "a", this.mobyPreventDummyLinks.bind(this));
			};

			Moby.instances = 0;
			Moby.slideTransition = 200;

			Moby.prototype.closeMoby = function () {
				var a = $("body").find(".moby.moby-active");

				if (a.length > 0) {
					this.overlay === !0 && $("body").find(".moby-overlay.moby-overlay-active").removeClass("moby-overlay-active");
					a.removeClass("moby-active");
					$("body").removeClass("moby-body-fixed");
					this.onClose !== !1 && this.onClose();
				}
			};

			Moby.prototype.cloneMenu = function () {
				var a = "",
					b = this.subMenuOpenIcon;

				if (this.template === !1) {
					a = '<div class="moby-wrap">';
					a += '<div class="moby-close"><span class="moby-close-icon"></span> Close Menu</div>';
					a += '<div class="moby-menu"></div>';
					a += "</div>";
				} else a = this.template;

				this.mobySelector.append(a);

				if (this.mobySelector.find(".moby-menu").length < 1) {
					console.error("You must have a moby-menu class in your template!");
					return !1;
				}

				this.menu.clone().appendTo(this.mobySelector.find(".moby-menu"));
				this.mobySelector.find(".moby-menu *[id]").removeAttr("id");
				this.mobySelector.find(".moby-menu li").each(function () {
					$(this).find("ul").length > 0 && $(this).find("> a").append("<span class='moby-expand'>" + b + "</span>");
				});
				this.mobySelector.removeClass("moby-hidden");
			};

			Moby.prototype.openMoby = function () {
				this.mobySelector.addClass("moby-active");
				$("body").addClass("moby-body-fixed");
				this.overlay === !0 && this.overlaySelector.addClass("moby-overlay-active");
				this.onOpen !== !1 && this.onOpen();
			};

			Moby.prototype.breakpointResize = function () {
				var a = window.outerWidth;
				if (this.breakpoint === !1) return !1;
				a >= this.breakpoint && this.mobySelector.hasClass("moby-active") && this.closeMoby();
			};

			Moby.prototype.mobyExpandSubMenu = function (a) {
				if (a.hasClass("moby-submenu-open")) {
					a.removeClass("moby-submenu-open");
					a.html(this.subMenuOpenIcon);
					a.parents("li").first().find("> ul").slideUp(Moby.slideTransition);
				} else {
					a.addClass("moby-submenu-open");
					a.html(this.subMenuCloseIcon);
					a.parents("li").first().find("> ul").slideDown(Moby.slideTransition);
				}
			};

			Moby.prototype.mobyPreventDummyLinks = function (a) {
				var b = $(this).find("> .moby-expand");

				if ("#" == $(this).attr("href")) {
					a.preventDefault();
					b.length > 0 && b.trigger("click");
				}
			};
			/* =====================================
					Init code
			/* =====================================*/
			// burger button


			$("#hamburger").click(function () {
				$(this).toggleClass("active");
			}); // init moby.js nav

			new Moby({
				menu: $(".main-menu-2"),
				// The menu that will be cloned
				mobyTrigger: $("#hamburger"),
				// Button that will trigger the Moby menu to open
				menuClass: "right-side",
				subMenuOpenIcon: '<span><img src="./assets/i/nav-arrow-down-mint.png"></span>',
				subMenuCloseIcon: '<span><img src="./assets/i/nav-arrow-up-mint.png"></span>',
				template: '<div class="moby-wrap"><div class="moby-close"><span class="moby-close-icon"></span></div><div class="moby-menu"></div></div>',
				onClose: function onClose() {
					$("#hamburger").removeClass("active");
				}
			}); // header menus drop down sum menus

			$("#main-menu ul li, #main-menu-2 ul li").on({
				mouseenter: function mouseenter() {
					$(this).find(">ul").stop(true, true).delay(200).fadeIn(200);
					$(this).addClass("selected");
				},
				mouseleave: function mouseleave() {
					$(this).find(">ul").stop(true, true).delay(200).fadeOut(200);
					$(this).removeClass("selected");
				}
			}); // hover event to sub-menu li:first, while hover add .menu-arrow-selected to sub-menu

			$("#main-menu ul li > ul li:first-child").on({
				mouseenter: function mouseenter() {
					$(this).parent("ul").addClass("menu-arrow-selected");
				},
				mouseleave: function mouseleave() {
					$(this).parent("ul").removeClass("menu-arrow-selected");
				}
			});

			/***/
		}),

/***/ "./src/assets/js/modules/popup-module.js":
/*!***********************************************!*\
  !*** ./src/assets/js/modules/popup-module.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");
/* harmony import */ var core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_1__);





			__webpack_require__(/*! jquery-colorbox */ "./node_modules/jquery-colorbox/jquery.colorbox.js"); // call now popup window


			$(".callNow__icon").colorbox({
				inline: true,
				width: "90%",
				maxWidth: "400px"
			}); // test drive popup window

			/* $(".testDrive__icon").colorbox({
				inline: true,
				width: "90%",
				maxWidth: "400px"
			}); */ // order consultation popup window

			$(".orderConsultation__icon").colorbox({
				inline: true,
				width: "90%",
				maxWidth: "430px"
			}); // close btn

			$(".close-btn-popup").click(function () {
				$.colorbox.close();
			}); // disable scroll when popup open

			$(document).bind("cbox_open", function () {
				$("html").addClass("noScrollSimple");
			}).bind("cbox_cleanup", function () {
				$("html").removeClass("noScrollSimple");
			}); // search form popup

			var search = $(".search-icon, .search-icon-2").colorbox({
				inline: true,
				width: "90%",
				maxWidth: "400px",
				onLoad: function onLoad() {
					$("#search-form-box").show();
					$("body").addClass("openSearchBar");
				},
				onCleanup: function onCleanup() {
					$("#search-form-box").hide();
				},
				onClosed: function onClosed() {
					$("body").removeClass("openSearchBar");
				}
			}); // video in popup box from youtube, vimeo src with auto play

			(function ($) {
				$(".video-source[href*='vimeo.com']").each(function () {
					var href = $(this).attr("href");
					var vimeoId = href.split("/").pop();
					$(this).colorbox({
						iframe: true,
						closeButton: false,
						width: "85%",
						height: "85%",
						maxWidth: "95%",
						maxHeight: "95%",
						href: function href() {
							return "http://player.vimeo.com/video/" + vimeoId + "?autoplay=1";
						}
					});
				});
				$(".video-source[href*='youtube.com']").each(function () {
					var href = $(this).attr("href");
					var youtubeId = href.split("=").pop();
					$(this).colorbox({
						iframe: true,
						closeButton: false,
						width: "85%",
						height: "85%",
						maxWidth: "95%",
						maxHeight: "95%",
						href: function href() {
							return "http://www.youtube.com/embed/" + youtubeId + "?autoplay=1";
						}
					});
				});
			})(jQuery);

			/***/
		}),

/***/ "./src/assets/js/modules/tabs-module.js":
/*!**********************************************!*\
  !*** ./src/assets/js/modules/tabs-module.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/assets/js/modules/utilities.js");


			// Start model viewver tabs

			if ($(".model-viever-tabs-list").length && $(".model-viever--tab").length && $(".model-viever-tab--content").length) {
				var modelViewverTabsParent = document.querySelector(".model-viever-tabs-list"),
					modelViewverTabs = document.querySelectorAll(".model-viever--tab"),
					modelVieverTabsContent = document.querySelectorAll(".model-viever-tab--content"); // hide all model tab content exept first one

				Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["hideTabContent"])(1, modelVieverTabsContent); // add event listener to click by color item and showing current content tab

				modelViewverTabsParent.addEventListener("click", function (event) {
					event.preventDefault();
					var target = event.target;

					if (target && target.classList.contains("model-viever--tab")) {
						// remove all avtive classes from tabs
						$(".model-viever--tab").closest("li").removeClass("active"); // add target active class

						$(target).closest("li").addClass("active");

						for (var i = 0; i < modelViewverTabs.length; i++) {
							if (target == modelViewverTabs[i]) {
								// hide all model tab content
								Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["hideTabContent"])(0, modelVieverTabsContent); // show special tab content

								Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["showTabContent"])(i, modelVieverTabsContent);
								break;
							}
						}
					}
				});
			} // End model viewver tabs
			// Start model tabs


			if ($(".color-filter").length && $(".model-tab").length && $(".model-tab-content").length) {
				var modelTabContent = document.querySelectorAll(".model-tab-content"),
					modelTab = document.querySelectorAll(".model-tab"),
					colorFilter = document.querySelector(".color-filter"); // hide all model tab content exept first one

				Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["hideTabContent"])(1, modelTabContent); // add event listener to click by color item and showing current content tab

				colorFilter.addEventListener("click", function (event) {
					var target = event.target;

					if (target && target.classList.contains("model-tab")) {
						// remove all avtive classes from tabs
						$(".model-tab").removeClass("active"); // add target active class

						$(target).addClass("active");

						for (var i = 0; i < modelTab.length; i++) {
							if (target == modelTab[i]) {
								// hide all model tab content
								Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["hideTabContent"])(0, modelTabContent); // show special tab content

								Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["showTabContent"])(i, modelTabContent); // set model parms to car main image

								Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["setModelParams"])();
								break;
							}
						}
					}
				});
			} // End model tabs
			// Start tabs


			if ($("#tabs").length) {
				$("#tabs li a:first").addClass("active");
				$("#tabs li a:not(:first)").addClass("inactive");
				$(".tab-content").hide();
				$(".tab-content:first").show();
				$("#tabs li a").click(function (e) {
					e.preventDefault();
					var t = $(this).attr("id");

					if ($(this).hasClass("inactive")) {
						//this is the start of our condition
						$("#tabs li a").addClass("inactive").removeClass("active");
						$(this).removeClass("inactive").addClass("active");
						$(".tab-content").hide();
						$("#" + t + "C").fadeIn("slow");
					}
				});
			} // End tabs

			/***/
		}),

/***/ "./src/assets/js/modules/utilities.js":
/*!********************************************!*\
  !*** ./src/assets/js/modules/utilities.js ***!
  \********************************************/
/*! exports provided: hideTabContent, showTabContent, setModelParams, toggleDisableFormButton, fadeEffectForContent, closeAlertMessages, animationsForComments, containerToContainerFluid */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

			"use strict";
			__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideTabContent", function () { return hideTabContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showTabContent", function () { return showTabContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setModelParams", function () { return setModelParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleDisableFormButton", function () { return toggleDisableFormButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeEffectForContent", function () { return fadeEffectForContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closeAlertMessages", function () { return closeAlertMessages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationsForComments", function () { return animationsForComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containerToContainerFluid", function () { return containerToContainerFluid; });
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_2__);





			var hideTabContent = function hideTabContent(a, element) {
				for (var i = a; i < element.length; i++) {
					element[i].classList.remove("show");
					element[i].classList.add("hide");
				}
			};
			var showTabContent = function showTabContent(b, element) {
				if (element[b].classList.contains("hide")) {
					element[b].classList.remove("hide");
					element[b].classList.add("show"); // fix for starting animation for tabs, (+1px move then -1px move)

					$(window).scrollTop($(window).scrollTop() + 1);
					$(window).scrollTop($(window).scrollTop() - 1);
				}
			}; // grab car model params and set in to main car image function

			var setModelParams = function setModelParams() {
				// get all params
				var url = "";
				var wheelSize = $(".wheels-list li.active").data("wheel");
				var carColor = $(".owl-item div.active").data("color");
				var carEngineType = $(".engines-list li.active").data("engine"); // create parms string

				url += "/model-single.html?wheels=" + wheelSize + "&color=" + carColor + "&engine=" + carEngineType; // set to main model image

				$(".model-image").attr("href", url);
			};
			/**
			 * toggleDisableFormButton
			 *
			 * Allow or deny sending form,
			 * need check checkbox for site privacy
			 *
			 * @param forms
			 */

			var toggleDisableFormButton = function toggleDisableFormButton(forms) {
				forms.forEach(function (form, i, arr) {
					if ($(form).length) {
						var testDriveFormButton = $(form).find("button"),
							agreementCheckBox = $(form).find('input[type="checkbox"]'); // set disabled button by default

						$(testDriveFormButton).prop("disabled", true);
						$(agreementCheckBox).on("click", function () {
							if ($(this).is(":checked")) {
								// remove attr disable
								$(testDriveFormButton).prop("disabled", false);
								$(testDriveFormButton).removeClass("btn-disabled").addClass("btn-primary");
							} else {
								// set disabled button by default
								$(testDriveFormButton).prop("disabled", true);
								$(testDriveFormButton).removeClass("btn-primary ").addClass("btn-disabled");
							}
						});
					}
				});
			};
			/**
			 * General fade in effect for content function
			 */

			var fadeEffectForContent = function fadeEffectForContent() {
				var elements;
				var windowHeight;

				function init() {
					elements = document.querySelectorAll(".fade-effect");
					windowHeight = window.innerHeight;
				}

				function checkPosition() {
					for (var i = 0; i < elements.length; i++) {
						var element = elements[i];
						var positionFromTop = elements[i].getBoundingClientRect().top;

						if (positionFromTop - windowHeight <= 0) {
							element.classList.add("fade-in-element");
							element.classList.remove("fade-effect");
						}
					}
				}

				window.addEventListener("scroll", checkPosition);
				window.addEventListener("resize", init);
				init();
				checkPosition();
			}; // Start close alert messages

			var closeAlertMessages = function closeAlertMessages() {
				var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "closebtn";
				var close = document.getElementsByClassName(selector); // Loop through all close buttons

				for (var i = 0; i < close.length; i++) {
					// When someone clicks on a close button
					close[i].onclick = function () {
						// Get the parent of <span class="closebtn"> (<div class="alert">)
						var div = this.parentElement; // Set the opacity of div to 0 (transparent)

						div.style.opacity = "0"; // Hide the div after 600ms (the same amount of milliseconds it takes to fade out)

						setTimeout(function () {
							div.style.display = "none";
						}, 600);
					};
				}
			};
			var animationsForComments = function animationsForComments() {
				var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ".comment";
				var commentTimer = 100;
				$(selector).each(function (el) {
					$(el).addClass("wow fadeInLeft").attr("data-wow-delay", commentTimer);
					commentTimer += 100;
				});
			};
			/**
			 * Change class of html div,
			 * on mobile container-fluid, on desktop container
			 *
			 * @param elementId
			 */

			var containerToContainerFluid = function containerToContainerFluid(elementId) {
				if ($(window).width() < 767) {
					$(elementId).removeClass("container").addClass("container-fluid");
				} else {
					$(elementId).removeClass("container-fluid").addClass("container");
				}
			};

			/***/
		})

	/******/
});
//# sourceMappingURL=index.min.js.map